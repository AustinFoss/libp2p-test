{
  "version": 3,
  "sources": ["../../.pnpm/@libp2p+interface@2.9.0/node_modules/@libp2p/interface/src/connection.ts", "../../.pnpm/@libp2p+interface@2.9.0/node_modules/@libp2p/interface/src/content-routing.ts", "../../.pnpm/@libp2p+interface@2.9.0/node_modules/@libp2p/interface/src/peer-discovery.ts", "../../.pnpm/@libp2p+interface@2.9.0/node_modules/@libp2p/interface/src/peer-id.ts", "../../.pnpm/@libp2p+interface@2.9.0/node_modules/@libp2p/interface/src/peer-routing.ts", "../../.pnpm/@libp2p+interface@2.9.0/node_modules/@libp2p/interface/src/pubsub.ts", "../../.pnpm/@libp2p+interface@2.9.0/node_modules/@libp2p/interface/src/transport.ts", "../../.pnpm/@libp2p+interface@2.9.0/node_modules/@libp2p/interface/src/errors.ts", "../../.pnpm/@libp2p+interface@2.9.0/node_modules/@libp2p/interface/src/index.ts", "../../.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/src/keys/rsa/der.ts", "../../.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/src/keys/ecdsa/index.ts", "../../.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/src/keys/ecdsa/utils.ts", "../../.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/src/keys/ecdsa/ecdsa.ts", "../../.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/src/keys/ed25519/index.browser.ts", "../../.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/src/keys/ed25519/ed25519.ts", "../../.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/src/keys/ed25519/utils.ts", "../../.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/src/keys/keys.ts", "../../.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/src/errors.ts", "../../.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/src/keys/rsa/utils.ts", "../../.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/src/util.ts", "../../.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/src/keys/secp256k1/index.browser.ts", "../../.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/src/keys/secp256k1/secp256k1.ts", "../../.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/src/keys/secp256k1/utils.ts", "../../.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/src/keys/ecdh/index.browser.ts", "../../.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/src/keys/index.ts", "../../.pnpm/@libp2p+peer-id@5.1.2/node_modules/@libp2p/peer-id/src/peer-id.ts", "../../.pnpm/@libp2p+peer-id@5.1.2/node_modules/@libp2p/peer-id/src/index.ts"],
  "sourcesContent": ["import type { AbortOptions, Logger } from './index.js'\nimport type { PeerId } from './peer-id.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Duplex, Source } from 'it-stream-types'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface ConnectionTimeline {\n  /**\n   * When the connection was opened\n   */\n  open: number\n\n  /**\n   * When the MultiaddrConnection was upgraded to a Connection - e.g. the type\n   * of connection encryption and multiplexing was negotiated.\n   */\n  upgraded?: number\n\n  /**\n   * When the connection was closed.\n   */\n  close?: number\n}\n\n/**\n * Outbound connections are opened by the local node, inbound streams are opened by the remote\n */\nexport type Direction = 'inbound' | 'outbound'\n\nexport interface StreamTimeline {\n  /**\n   * A timestamp of when the stream was opened\n   */\n  open: number\n\n  /**\n   * A timestamp of when the stream was closed for both reading and writing\n   */\n  close?: number\n\n  /**\n   * A timestamp of when the stream was closed for reading\n   */\n  closeRead?: number\n\n  /**\n   * A timestamp of when the stream was closed for writing\n   */\n  closeWrite?: number\n\n  /**\n   * A timestamp of when the stream was reset\n   */\n  reset?: number\n\n  /**\n   * A timestamp of when the stream was aborted\n   */\n  abort?: number\n}\n\n/**\n * The states a stream can be in\n */\nexport type StreamStatus = 'open' | 'closing' | 'closed' | 'aborted' | 'reset'\n\n/**\n * The states the readable end of a stream can be in\n *\n * ready - the readable end is ready for reading\n * closing - the readable end is closing\n * closed - the readable end has closed\n */\nexport type ReadStatus = 'ready' | 'closing' | 'closed'\n\n/**\n * The states the writable end of a stream can be in\n *\n * ready - the writable end is ready for writing\n * writing - the writable end is in the process of being written to\n * done - the source passed to the `.sink` function yielded all values without error\n * closing - the writable end is closing\n * closed - the writable end has closed\n */\nexport type WriteStatus = 'ready' | 'writing' | 'done' | 'closing' | 'closed'\n\n/**\n * A Stream is a data channel between two peers that\n * can be written to and read from at both ends.\n *\n * It may be encrypted and multiplexed depending on the\n * configuration of the nodes.\n */\nexport interface Stream extends Duplex<AsyncGenerator<Uint8ArrayList>, Source<Uint8ArrayList | Uint8Array>, Promise<void>> {\n  /**\n   * Closes the stream for **reading** *and* **writing**.\n   *\n   * Any buffered data in the source can still be consumed and the stream will end normally.\n   *\n   * This will cause a `CLOSE` message to be sent to the remote, *unless* the sink has already ended.\n   *\n   * The sink and the source will return normally.\n   */\n  close(options?: AbortOptions): Promise<void>\n\n  /**\n   * Closes the stream for **reading**. If iterating over the source of this stream in a `for await of` loop, it will return (exit the loop) after any buffered data has been consumed.\n   *\n   * This function is called automatically by the muxer when it receives a `CLOSE` message from the remote.\n   *\n   * The source will return normally, the sink will continue to consume.\n   */\n  closeRead(options?: AbortOptions): Promise<void>\n\n  /**\n   * Closes the stream for **writing**. If iterating over the source of this stream in a `for await of` loop, it will return (exit the loop) after any buffered data has been consumed.\n   *\n   * The source will return normally, the sink will continue to consume.\n   */\n  closeWrite(options?: AbortOptions): Promise<void>\n\n  /**\n   * Closes the stream for **reading** *and* **writing**. This should be called when a *local error* has occurred.\n   *\n   * Note, if called without an error any buffered data in the source can still be consumed and the stream will end normally.\n   *\n   * This will cause a `RESET` message to be sent to the remote, *unless* the sink has already ended.\n   *\n   * The sink will return and the source will throw.\n   */\n  abort(err: Error): void\n\n  /**\n   * Unique identifier for a stream. Identifiers are not unique across muxers.\n   */\n  id: string\n\n  /**\n   * Outbound streams are opened by the local node, inbound streams are opened by the remote\n   */\n  direction: Direction\n\n  /**\n   * Lifecycle times for the stream\n   */\n  timeline: StreamTimeline\n\n  /**\n   * The protocol negotiated for this stream\n   */\n  protocol?: string\n\n  /**\n   * User defined stream metadata\n   */\n  metadata: Record<string, any>\n\n  /**\n   * The current status of the stream\n   */\n  status: StreamStatus\n\n  /**\n   * The current status of the readable end of the stream\n   */\n  readStatus: ReadStatus\n\n  /**\n   * The current status of the writable end of the stream\n   */\n  writeStatus: WriteStatus\n\n  /**\n   * The stream logger\n   */\n  log: Logger\n}\n\nexport interface NewStreamOptions extends AbortOptions {\n  /**\n   * If specified, and no handler has been registered with the registrar for the\n   * successfully negotiated protocol, use this as the max outbound stream limit\n   * for the protocol\n   */\n  maxOutboundStreams?: number\n\n  /**\n   * Opt-in to running over a limited connection - one that has restrictions\n   * on the amount of data that may be transferred or how long it may be open for.\n   *\n   * These limits are typically enforced by a relay server, if the protocol\n   * will be transferring a lot of data or the stream will be open for a long time\n   * consider upgrading to a direct connection before opening the stream.\n   *\n   * @default false\n   */\n  runOnLimitedConnection?: boolean\n\n  /**\n   * By default when negotiating a protocol the dialer writes then protocol name\n   * then reads the response.\n   *\n   * When a only a single protocol is being negotiated on an outbound stream,\n   * and the stream is written to before being read from, we can optimistically\n   * write the protocol name and the first chunk of data together in the first\n   * message.\n   *\n   * Reading and handling the protocol response is done asynchronously, which\n   * means we can skip a round trip on writing to newly opened streams which\n   * significantly reduces the time-to-first-byte on a stream.\n   *\n   * The side-effect of this is that the underlying stream won't negotiate the\n   * protocol until either data is written to or read from the stream so it will\n   * not be opened on the remote until this is done.\n   *\n   * Pass `false` here to optimistically write the protocol name and first chunk\n   * of data in the first message.\n   *\n   * If multiple protocols are being negotiated, negotiation is always completed\n   * in full before the stream is returned so this option has no effect.\n   *\n   * @default true\n   */\n  negotiateFully?: boolean\n}\n\nexport type ConnectionStatus = 'open' | 'closing' | 'closed'\n\n/**\n * Connection limits are present on connections that are only allowed to\n * transfer a certain amount of bytes or be open for a certain number\n * of seconds.\n *\n * These limits are applied by Circuit Relay v2 servers, for example and\n * the connection will normally be closed abruptly if the limits are\n * exceeded.\n */\nexport interface ConnectionLimits {\n  /**\n   * If present this is the number of bytes remaining that may be\n   * transferred over this connection\n   */\n  bytes?: bigint\n\n  /**\n   * If present this is the number of seconds that this connection will\n   * remain open for\n   */\n  seconds?: number\n}\n\n/**\n * A Connection is a high-level representation of a connection\n * to a remote peer that may have been secured by encryption and\n * multiplexed, depending on the configuration of the nodes\n * between which the connection is made.\n */\nexport interface Connection {\n  /**\n   * The unique identifier for this connection\n   */\n  id: string\n\n  /**\n   * The address of the remote end of the connection\n   */\n  remoteAddr: Multiaddr\n\n  /**\n   * The id of the peer at the remote end of the connection\n   */\n  remotePeer: PeerId\n\n  /**\n   * A list of tags applied to this connection\n   */\n  tags: string[]\n\n  /**\n   * A list of open streams on this connection\n   */\n  streams: Stream[]\n\n  /**\n   * Outbound connections are opened by the local node, inbound streams are opened by the remote\n   */\n  direction: Direction\n\n  /**\n   * Lifecycle times for the connection\n   */\n  timeline: ConnectionTimeline\n\n  /**\n   * The multiplexer negotiated for this connection\n   */\n  multiplexer?: string\n\n  /**\n   * The encryption protocol negotiated for this connection\n   */\n  encryption?: string\n\n  /**\n   * The current status of the connection\n   */\n  status: ConnectionStatus\n\n  /**\n   * If present, this connection has limits applied to it, perhaps by an\n   * intermediate relay. Once the limits have been reached the connection will\n   * be closed by the relay.\n   */\n  limits?: ConnectionLimits\n\n  /**\n   * The time in milliseconds it takes to make a round trip to the remote peer.\n   *\n   * This is updated periodically by the connection monitor.\n   */\n  rtt?: number\n\n  /**\n   * Create a new stream on this connection and negotiate one of the passed protocols\n   */\n  newStream(protocols: string | string[], options?: NewStreamOptions): Promise<Stream>\n\n  /**\n   * Gracefully close the connection. All queued data will be written to the\n   * underlying transport.\n   */\n  close(options?: AbortOptions): Promise<void>\n\n  /**\n   * Immediately close the connection, any queued data will be discarded\n   */\n  abort(err: Error): void\n\n  /**\n   * The connection logger\n   */\n  log: Logger\n}\n\nexport const connectionSymbol = Symbol.for('@libp2p/connection')\n\nexport function isConnection (other: any): other is Connection {\n  return other != null && Boolean(other[connectionSymbol])\n}\n\nexport interface ConnectionProtector {\n  /**\n   * Takes a given Connection and creates a private encryption stream\n   * between its two peers from the PSK the Protector instance was\n   * created with.\n   */\n  protect(connection: MultiaddrConnection, options?: AbortOptions): Promise<MultiaddrConnection>\n}\n\nexport interface MultiaddrConnectionTimeline {\n  /**\n   * When the connection was opened\n   */\n  open: number\n\n  /**\n   * When the MultiaddrConnection was upgraded to a Connection - the type of\n   * connection encryption and multiplexing was negotiated.\n   */\n  upgraded?: number\n\n  /**\n   * When the connection was closed.\n   */\n  close?: number\n}\n\n/**\n * A MultiaddrConnection is returned by transports after dialing\n * a peer. It is a low-level primitive and is the raw connection\n * without encryption or stream multiplexing.\n */\nexport interface MultiaddrConnection extends Duplex<AsyncGenerator<Uint8Array | Uint8ArrayList>> {\n  /**\n   * Gracefully close the connection. All queued data will be written to the\n   * underlying transport.\n   */\n  close(options?: AbortOptions): Promise<void>\n\n  /**\n   * Immediately close the connection, any queued data will be discarded\n   */\n  abort(err: Error): void\n\n  /**\n   * The address of the remote end of the connection\n   */\n  remoteAddr: Multiaddr\n\n  /**\n   * When connection life cycle events occurred\n   */\n  timeline: MultiaddrConnectionTimeline\n\n  /**\n   * The multiaddr connection logger\n   */\n  log: Logger\n}\n", "import type { RoutingOptions } from './index.js'\nimport type { PeerInfo } from './peer-info.js'\nimport type { CID } from 'multiformats/cid'\n\n/**\n * Any object that implements this Symbol as a property should return a\n * ContentRouting instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```TypeScript\n * import { contentRoutingSymbol, ContentRouting } from '@libp2p/content-routing'\n *\n * class MyContentRouter implements ContentRouting {\n *   get [contentRoutingSymbol] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const contentRoutingSymbol = Symbol.for('@libp2p/content-routing')\n\n/**\n * Implementers of this interface can provide a ContentRouting implementation to\n * interested callers.\n */\nexport interface ContentRoutingProvider {\n  [contentRoutingSymbol]: ContentRouting\n}\n\nexport interface ContentRouting {\n  /**\n   * The implementation of this method should ensure that network peers know the\n   * caller can provide content that corresponds to the passed CID.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // ...\n   * await contentRouting.provide(cid)\n   * ```\n   */\n  provide(cid: CID, options?: RoutingOptions): Promise<void>\n\n  /**\n   * If network peers need to be periodically reminded that the caller can\n   * provide content corresponding to the passed CID, call this function to no\n   * longer remind them.\n   */\n  cancelReprovide (key: CID, options?: RoutingOptions): Promise<void>\n\n  /**\n   * Find the providers of the passed CID.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // Iterate over the providers found for the given cid\n   * for await (const provider of contentRouting.findProviders(cid)) {\n   *  console.log(provider.id, provider.multiaddrs)\n   * }\n   * ```\n   */\n  findProviders(cid: CID, options?: RoutingOptions): AsyncIterable<PeerInfo>\n\n  /**\n   * Puts a value corresponding to the passed key in a way that can later be\n   * retrieved by another network peer using the get method.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // ...\n   * const key = '/key'\n   * const value = uint8ArrayFromString('oh hello there')\n   *\n   * await contentRouting.put(key, value)\n   * ```\n   */\n  put(key: Uint8Array, value: Uint8Array, options?: RoutingOptions): Promise<void>\n\n  /**\n   * Retrieves a value from the network corresponding to the passed key.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // ...\n   *\n   * const key = '/key'\n   * const value = await contentRouting.get(key)\n   * ```\n   */\n  get(key: Uint8Array, options?: RoutingOptions): Promise<Uint8Array>\n}\n", "import type { TypedEventTarget } from './event-target.js'\nimport type { PeerInfo } from './peer-info.js'\n\n/**\n * Any object that implements this Symbol as a property should return a\n * PeerDiscovery instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```TypeScript\n * import { peerDiscovery, PeerDiscovery } from '@libp2p/peer-discovery'\n *\n * class MyPeerDiscoverer implements PeerDiscovery {\n *   get [peerDiscovery] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const peerDiscoverySymbol = Symbol.for('@libp2p/peer-discovery')\n\n/**\n * Implementers of this interface can provide a PeerDiscovery implementation to\n * interested callers.\n */\nexport interface PeerDiscoveryProvider {\n  [peerDiscoverySymbol]: PeerDiscovery\n}\n\nexport interface PeerDiscoveryEvents {\n  'peer': CustomEvent<PeerInfo>\n}\n\nexport interface PeerDiscovery extends TypedEventTarget<PeerDiscoveryEvents> {}\n", "import type { Ed25519PublicKey, KeyType, RSAPublicKey, Secp256k1PublicKey } from './keys.js'\nimport type { CID } from 'multiformats/cid'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\n\nexport type PeerIdType = KeyType | string\n\n/**\n * A PeerId generated from an RSA public key - it is a base58btc encoded sha-256\n * hash of the public key.\n *\n * RSA public keys are too large to pass around freely, instead Ed25519 or\n * secp256k1 should be preferred as they can embed their public key in the\n * PeerId itself.\n *\n * @deprecated Ed25519 or secp256k1 keys are preferred to RSA\n */\nexport interface RSAPeerId {\n  readonly type: 'RSA'\n\n  /**\n   * RSA public keys are too large to embed in the multihash commonly used to\n   * refer to peers, so this will only be defined if the public key has\n   * previously been found through a routing query or during normal protocol\n   * operations\n   */\n  readonly publicKey?: RSAPublicKey\n\n  /**\n   * Returns the multihash from `toMultihash()` as a base58btc encoded string\n   */\n  toString(): string\n\n  /**\n   * Returns a multihash, the digest of which is the SHA2-256 hash of the public\n   * key\n   */\n  toMultihash(): MultihashDigest<0x12>\n\n  /**\n   * Returns a CID with the libp2p key code and the same multihash as\n   * `toMultihash()`\n   */\n  toCID(): CID<Uint8Array, 0x72, 0x12, 1>\n\n  /**\n   * Returns true if the passed argument is equivalent to this PeerId\n   */\n  equals(other?: any): boolean\n}\n\nexport interface Ed25519PeerId {\n  readonly type: 'Ed25519'\n\n  /**\n   * This will always be defined as the public key is embedded in the multihash\n   * of this PeerId\n   */\n  readonly publicKey: Ed25519PublicKey\n\n  /**\n   * Returns the multihash from `toMultihash()` as a base58btc encoded string\n   */\n  toString(): string\n\n  /**\n   * Returns a multihash, the digest of which is the protobuf-encoded public key\n   * encoded as an identity hash\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Returns a CID with the libp2p key code and the same multihash as\n   * `toMultihash()`\n   */\n  toCID(): CID<Uint8Array, 0x72, 0x0, 1>\n\n  /**\n   * Returns true if the passed argument is equivalent to this PeerId\n   */\n  equals(other?: any): boolean\n}\n\nexport interface Secp256k1PeerId {\n  readonly type: 'secp256k1'\n\n  /**\n   * This will always be defined as the public key is embedded in the multihash\n   * of this PeerId\n   */\n  readonly publicKey: Secp256k1PublicKey\n\n  /**\n   * Returns the multihash from `toMultihash()` as a base58btc encoded string\n   */\n  toString(): string\n\n  /**\n   * Returns a multihash, the digest of which is the protobuf-encoded public key\n   * encoded as an identity hash\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Returns a CID with the libp2p key code and the same multihash as\n   * `toMultihash()`\n   */\n  toCID(): CID<Uint8Array, 0x72, 0x0, 1>\n\n  /**\n   * Returns true if the passed argument is equivalent to this PeerId\n   */\n  equals(other?: any): boolean\n}\n\nexport interface URLPeerId {\n  readonly type: 'url'\n\n  /**\n   * This will always be undefined as URL Peers do not have public keys\n   */\n  readonly publicKey: undefined\n\n  /**\n   * Returns CID from `toCID()` encoded as a base36 string\n   */\n  toString(): string\n\n  /**\n   * Returns a multihash, the digest of which is the URL encoded as an identity\n   * hash\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Returns a CID with the Transport IPFS Gateway HTTP code and the same\n   * multihash as `toMultihash()`\n   */\n  toCID(): CID<Uint8Array, 0x0920, 0x0, 1>\n\n  /**\n   * Returns true if the passed argument is equivalent to this PeerId\n   */\n  equals(other?: any): boolean\n}\n\n/**\n * This is a union of all known PeerId types - use the `.type` field to\n * disambiguate them\n */\nexport type PeerId = RSAPeerId | Ed25519PeerId | Secp256k1PeerId | URLPeerId\n\n/**\n * All PeerId implementations must use this symbol as the name of a property\n * with a boolean `true` value\n */\nexport const peerIdSymbol = Symbol.for('@libp2p/peer-id')\n\n/**\n * Returns true if the passed argument is a PeerId implementation\n */\nexport function isPeerId (other?: any): other is PeerId {\n  return Boolean(other?.[peerIdSymbol])\n}\n", "import type { RoutingOptions } from './index.js'\nimport type { PeerId } from './peer-id.js'\nimport type { PeerInfo } from './peer-info.js'\n\n/**\n * Any object that implements this Symbol as a property should return a\n * PeerRouting instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```TypeScript\n * import { peerRouting, PeerRouting } from '@libp2p/peer-routing'\n *\n * class MyPeerRouter implements PeerRouting {\n *   get [peerRouting] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const peerRoutingSymbol = Symbol.for('@libp2p/peer-routing')\n\n/**\n * Implementers of this interface can provide a PeerRouting implementation to\n * interested callers.\n */\nexport interface PeerRoutingProvider {\n  [peerRoutingSymbol]: PeerRouting\n}\n\nexport interface PeerRouting {\n  /**\n   * Searches the network for peer info corresponding to the passed peer id.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // ...\n   * const peer = await peerRouting.findPeer(peerId, options)\n   * ```\n   */\n  findPeer(peerId: PeerId, options?: RoutingOptions): Promise<PeerInfo>\n\n  /**\n   * Search the network for peers that are closer to the passed key. Peer\n   * info should be yielded in ever-increasing closeness to the key.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // Iterate over the closest peers found for the given key\n   * for await (const peer of peerRouting.getClosestPeers(key)) {\n   *   console.log(peer.id, peer.multiaddrs)\n   * }\n   * ```\n   */\n  getClosestPeers(key: Uint8Array, options?: RoutingOptions): AsyncIterable<PeerInfo>\n}\n", "import type { Stream } from './connection.js'\nimport type { TypedEventTarget } from './event-target.js'\nimport type { PublicKey } from './keys.js'\nimport type { PeerId } from './peer-id.js'\nimport type { Pushable } from 'it-pushable'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\n/**\n * On the producing side:\n * * Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n *\n * On the consuming side:\n * * Enforce the fields to be present, reject otherwise.\n * * Propagate only if the fields are valid and signature can be verified, reject otherwise.\n */\nexport const StrictSign = 'StrictSign'\n\n/**\n * On the producing side:\n * * Build messages without the signature, key, from and seqno fields.\n * * The corresponding protobuf key-value pairs are absent from the marshaled message, not just empty.\n *\n * On the consuming side:\n * * Enforce the fields to be absent, reject otherwise.\n * * Propagate only if the fields are absent, reject otherwise.\n * * A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n */\nexport const StrictNoSign = 'StrictNoSign'\n\nexport type SignaturePolicy = typeof StrictSign | typeof StrictNoSign\n\nexport interface SignedMessage {\n  type: 'signed'\n  from: PeerId\n  topic: string\n  data: Uint8Array\n  sequenceNumber: bigint\n  signature: Uint8Array\n  key: PublicKey\n}\n\nexport interface UnsignedMessage {\n  type: 'unsigned'\n  topic: string\n  data: Uint8Array\n}\n\nexport type Message = SignedMessage | UnsignedMessage\n\nexport interface PubSubRPCMessage {\n  from?: Uint8Array\n  topic?: string\n  data?: Uint8Array\n  sequenceNumber?: Uint8Array\n  signature?: Uint8Array\n  key?: Uint8Array\n}\n\nexport interface PubSubRPCSubscription {\n  subscribe?: boolean\n  topic?: string\n}\n\nexport interface PubSubRPC {\n  subscriptions: PubSubRPCSubscription[]\n  messages: PubSubRPCMessage[]\n}\n\nexport interface PeerStreams extends TypedEventTarget<PeerStreamEvents> {\n  id: PeerId\n  protocol: string\n  outboundStream?: Pushable<Uint8ArrayList>\n  inboundStream?: AsyncIterable<Uint8ArrayList>\n  isWritable: boolean\n\n  close(): void\n  write(buf: Uint8Array | Uint8ArrayList): void\n  attachInboundStream(stream: Stream): AsyncIterable<Uint8ArrayList>\n  attachOutboundStream(stream: Stream): Promise<Pushable<Uint8ArrayList>>\n}\n\nexport interface PubSubInit {\n  enabled?: boolean\n\n  multicodecs?: string[]\n\n  /**\n   * defines how signatures should be handled\n   */\n  globalSignaturePolicy?: SignaturePolicy\n\n  /**\n   * if can relay messages not subscribed\n   */\n  canRelayMessage?: boolean\n\n  /**\n   * if publish should emit to self, if subscribed\n   */\n  emitSelf?: boolean\n\n  /**\n   * handle this many incoming pubsub messages concurrently\n   */\n  messageProcessingConcurrency?: number\n\n  /**\n   * How many parallel incoming streams to allow on the pubsub protocol per-connection\n   */\n  maxInboundStreams?: number\n\n  /**\n   * How many parallel outgoing streams to allow on the pubsub protocol per-connection\n   */\n  maxOutboundStreams?: number\n}\n\nexport interface Subscription {\n  topic: string\n  subscribe: boolean\n}\n\nexport interface SubscriptionChangeData {\n  peerId: PeerId\n  subscriptions: Subscription[]\n}\n\nexport interface PubSubEvents {\n  'subscription-change': CustomEvent<SubscriptionChangeData>\n  'message': CustomEvent<Message>\n}\n\nexport interface PublishResult {\n  recipients: PeerId[]\n}\n\nexport enum TopicValidatorResult {\n  /**\n   * The message is considered valid, and it should be delivered and forwarded to the network\n   */\n  Accept = 'accept',\n  /**\n   * The message is neither delivered nor forwarded to the network\n   */\n  Ignore = 'ignore',\n  /**\n   * The message is considered invalid, and it should be rejected\n   */\n  Reject = 'reject'\n}\n\nexport interface TopicValidatorFn {\n  (peer: PeerId, message: Message): TopicValidatorResult | Promise<TopicValidatorResult>\n}\n\nexport interface PubSub<Events extends Record<string, any> = PubSubEvents> extends TypedEventTarget<Events> {\n  /**\n   * The global signature policy controls whether or not we sill send and receive\n   * signed or unsigned messages.\n   *\n   * Signed messages prevent spoofing message senders and should be preferred to\n   * using unsigned messages.\n   */\n  globalSignaturePolicy: typeof StrictSign | typeof StrictNoSign\n\n  /**\n   * A list of multicodecs that contain the pubsub protocol name.\n   */\n  multicodecs: string[]\n\n  /**\n   * Pubsub routers support message validators per topic, which will validate the message\n   * before its propagations. They are stored in a map where keys are the topic name and\n   * values are the validators.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const validateMessage = (msgTopic, msg) => {\n   *   const input = uint8ArrayToString(msg.data)\n   *   const validInputs = ['a', 'b', 'c']\n   *\n   *   if (!validInputs.includes(input)) {\n   *     throw new Error('no valid input received')\n   *   }\n   * }\n   * libp2p.pubsub.topicValidators.set(topic, validateMessage)\n   * ```\n   */\n  topicValidators: Map<string, TopicValidatorFn>\n\n  getPeers(): PeerId[]\n\n  /**\n   * Gets a list of topics the node is subscribed to.\n   *\n   * ```TypeScript\n   * const topics = libp2p.pubsub.getTopics()\n   * ```\n   */\n  getTopics(): string[]\n\n  /**\n   * Subscribes to a pubsub topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const handler = (msg) => {\n   *   if (msg.topic === topic) {\n   *     // msg.data - pubsub data received\n   *   }\n   * }\n   *\n   * libp2p.pubsub.addEventListener('message', handler)\n   * libp2p.pubsub.subscribe(topic)\n   * ```\n   */\n  subscribe(topic: string): void\n\n  /**\n   * Unsubscribes from a pubsub topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const handler = (msg) => {\n   *   // msg.data - pubsub data received\n   * }\n   *\n   * libp2p.pubsub.removeEventListener(topic handler)\n   * libp2p.pubsub.unsubscribe(topic)\n   * ```\n   */\n  unsubscribe(topic: string): void\n\n  /**\n   * Gets a list of the PeerIds that are subscribed to one topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peerIds = libp2p.pubsub.getSubscribers(topic)\n   * ```\n   */\n  getSubscribers(topic: string): PeerId[]\n\n  /**\n   * Publishes messages to the given topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const data = uint8ArrayFromString('data')\n   *\n   * await libp2p.pubsub.publish(topic, data)\n   * ```\n   */\n  publish(topic: string, data: Uint8Array): Promise<PublishResult>\n}\n\nexport interface PeerStreamEvents {\n  'stream:inbound': CustomEvent<never>\n  'stream:outbound': CustomEvent<never>\n  'close': CustomEvent<never>\n}\n\n/**\n * All Pubsub implementations must use this symbol as the name of a property\n * with a boolean `true` value\n */\nexport const pubSubSymbol = Symbol.for('@libp2p/pubsub')\n\n/**\n * Returns true if the passed argument is a PubSub implementation\n */\nexport function isPubSub (obj?: any): obj is PubSub {\n  return Boolean(obj?.[pubSubSymbol])\n}\n", "import type { Connection, ConnectionLimits, MultiaddrConnection } from './connection.js'\nimport type { TypedEventTarget } from './event-target.js'\nimport type { AbortOptions, ClearableSignal, ConnectionEncrypter } from './index.js'\nimport type { StreamMuxerFactory } from './stream-muxer.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\nexport interface ListenerEvents {\n  /**\n   * This event signals to the transport manager that the listening addresses\n   * have changed and may be emitted at any point and/or multiple times\n   */\n  'listening': CustomEvent\n\n  /**\n   * Emitted if listening on an address failed\n   */\n  'error': CustomEvent<Error>\n\n  /**\n   * Emitted when the listener has been shut down, has no open connections and\n   * will no longer accept new connections\n   */\n  'close': CustomEvent\n}\n\nexport interface Listener extends TypedEventTarget<ListenerEvents> {\n  /**\n   * Start a listener\n   */\n  listen(multiaddr: Multiaddr): Promise<void>\n  /**\n   * Get listen addresses\n   */\n  getAddrs(): Multiaddr[]\n  /**\n   * Close listener\n   *\n   * @returns {Promise<void>}\n   */\n  close(): Promise<void>\n  /**\n   * Allows transports to amend announce addresses - to add certificate hashes\n   * or other metadata that cannot be known before runtime\n   */\n  updateAnnounceAddrs(addrs: Multiaddr[]): void\n}\n\nexport const transportSymbol = Symbol.for('@libp2p/transport')\n\nexport interface MultiaddrFilter { (multiaddrs: Multiaddr[]): Multiaddr[] }\n\nexport interface CreateListenerOptions {\n  /**\n   * The upgrader turns a MultiaddrConnection into a Connection and notifies\n   * other libp2p components about a new incoming connection.\n   */\n  upgrader: Upgrader\n}\n\nexport interface DialTransportOptions<DialEvents extends ProgressEvent = ProgressEvent> extends Required<AbortOptions>, ProgressOptions<DialEvents> {\n  /**\n   * The upgrader turns a MultiaddrConnection into a Connection which should be\n   * returned by the transport's dial method\n   */\n  upgrader: Upgrader\n}\n\n/**\n * A libp2p transport offers dial and listen methods to establish connections.\n */\nexport interface Transport<DialEvents extends ProgressEvent = ProgressEvent> {\n  /**\n   * Used to identify the transport\n   */\n  [Symbol.toStringTag]: string\n\n  /**\n   * Used by the isTransport function\n   */\n  [transportSymbol]: true\n\n  /**\n   * Dial a given multiaddr.\n   */\n  dial(ma: Multiaddr, options: DialTransportOptions<DialEvents>): Promise<Connection>\n\n  /**\n   * Create transport listeners.\n   */\n  createListener(options: CreateListenerOptions): Listener\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only addresses that are valid for\n   * the transport to listen on\n   */\n  listenFilter: MultiaddrFilter\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only addresses that are valid for\n   * the transport to dial\n   */\n  dialFilter: MultiaddrFilter\n}\n\nexport function isTransport (other: any): other is Transport {\n  return other != null && Boolean(other[transportSymbol])\n}\n\n/**\n * Enum Transport Manager Fault Tolerance values\n */\nexport enum FaultTolerance {\n  /**\n   * should be used for failing in any listen circumstance\n   */\n  FATAL_ALL = 0,\n\n  /**\n   * should be used for not failing when not listening\n   */\n  NO_FATAL\n}\n\nexport interface UpgraderOptions<ConnectionUpgradeEvents extends ProgressEvent = ProgressEvent> extends ProgressOptions<ConnectionUpgradeEvents>, Required<AbortOptions> {\n  skipEncryption?: boolean\n  skipProtection?: boolean\n  muxerFactory?: StreamMuxerFactory\n  limits?: ConnectionLimits\n  initiator?: boolean\n}\n\nexport type InboundConnectionUpgradeEvents =\nProgressEvent<'upgrader:encrypt-inbound-connection'> |\nProgressEvent<'upgrader:multiplex-inbound-connection'>\n\nexport type OutboundConnectionUpgradeEvents =\nProgressEvent<'upgrader:encrypt-outbound-connection'> |\nProgressEvent<'upgrader:multiplex-outbound-connection'>\n\nexport interface Upgrader {\n  /**\n   * Upgrades an outbound connection created by the `dial` method of a transport\n   */\n  upgradeOutbound(maConn: MultiaddrConnection, opts?: UpgraderOptions<OutboundConnectionUpgradeEvents>): Promise<Connection>\n\n  /**\n   * Upgrades an inbound connection received by a transport listener and\n   * notifies other libp2p components about the new connection\n   */\n  upgradeInbound(maConn: MultiaddrConnection, opts?: UpgraderOptions<InboundConnectionUpgradeEvents>): Promise<void>\n\n  /**\n   * Used by transports that perform part of the upgrade process themselves and\n   * do some async work. This allows configuring inbound upgrade timeouts from a\n   * single location.\n   *\n   * Regular transports should just pass the signal from their shutdown\n   * controller to `upgradeInbound`.\n   */\n  createInboundAbortSignal (signal: AbortSignal): ClearableSignal\n\n  /**\n   * Returns configured stream muxers\n   */\n  getStreamMuxers (): Map<string, StreamMuxerFactory>\n\n  /**\n   * Returns configured connection encrypters\n   */\n  getConnectionEncrypters (): Map<string, ConnectionEncrypter>\n}\n", "/**\n * When this error is thrown it means an operation was aborted,\n * usually in response to the `abort` event being emitted by an\n * AbortSignal.\n */\nexport class AbortError extends Error {\n  static name = 'AbortError'\n\n  constructor (message: string = 'The operation was aborted') {\n    super(message)\n    this.name = 'AbortError'\n  }\n}\n\n/**\n * Thrown when a remote Peer ID does not match the expected one\n */\nexport class UnexpectedPeerError extends Error {\n  static name = 'UnexpectedPeerError'\n\n  constructor (message = 'Unexpected Peer') {\n    super(message)\n    this.name = 'UnexpectedPeerError'\n  }\n}\n\n/**\n * Thrown when a crypto exchange fails\n */\nexport class InvalidCryptoExchangeError extends Error {\n  static name = 'InvalidCryptoExchangeError'\n\n  constructor (message = 'Invalid crypto exchange') {\n    super(message)\n    this.name = 'InvalidCryptoExchangeError'\n  }\n}\n\n/**\n * Thrown when invalid parameters are passed to a function or method call\n */\nexport class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n\n  constructor (message = 'Invalid parameters') {\n    super(message)\n    this.name = 'InvalidParametersError'\n  }\n}\n\n/**\n * Thrown when a public key is invalid\n */\nexport class InvalidPublicKeyError extends Error {\n  static name = 'InvalidPublicKeyError'\n\n  constructor (message = 'Invalid public key') {\n    super(message)\n    this.name = 'InvalidPublicKeyError'\n  }\n}\n\n/**\n * Thrown when a private key is invalid\n */\nexport class InvalidPrivateKeyError extends Error {\n  static name = 'InvalidPrivateKeyError'\n\n  constructor (message = 'Invalid private key') {\n    super(message)\n    this.name = 'InvalidPrivateKeyError'\n  }\n}\n\n/**\n * Thrown when a operation is unsupported\n */\nexport class UnsupportedOperationError extends Error {\n  static name = 'UnsupportedOperationError'\n\n  constructor (message = 'Unsupported operation') {\n    super(message)\n    this.name = 'UnsupportedOperationError'\n  }\n}\n\n/**\n * Thrown when a connection is closing\n */\nexport class ConnectionClosingError extends Error {\n  static name = 'ConnectionClosingError'\n\n  constructor (message = 'The connection is closing') {\n    super(message)\n    this.name = 'ConnectionClosingError'\n  }\n}\n\n/**\n * Thrown when a connection is closed\n */\nexport class ConnectionClosedError extends Error {\n  static name = 'ConnectionClosedError'\n\n  constructor (message = 'The connection is closed') {\n    super(message)\n    this.name = 'ConnectionClosedError'\n  }\n}\n\n/**\n * Thrown when a connection fails\n */\nexport class ConnectionFailedError extends Error {\n  static name = 'ConnectionFailedError'\n\n  constructor (message = 'Connection failed') {\n    super(message)\n    this.name = 'ConnectionFailedError'\n  }\n}\n\n/**\n * Thrown when the muxer is closed and an attempt to open a stream occurs\n */\nexport class MuxerClosedError extends Error {\n  static name = 'MuxerClosedError'\n\n  constructor (message = 'The muxer is closed') {\n    super(message)\n    this.name = 'MuxerClosedError'\n  }\n}\n\n/**\n * Thrown when a protocol stream is reset by the remote muxer\n */\nexport class StreamResetError extends Error {\n  static name = 'StreamResetError'\n\n  constructor (message = 'The stream has been reset') {\n    super(message)\n    this.name = 'StreamResetError'\n  }\n}\n\n/**\n * Thrown when a stream is in an invalid state\n */\nexport class StreamStateError extends Error {\n  static name = 'StreamStateError'\n\n  constructor (message = 'The stream is in an invalid state') {\n    super(message)\n    this.name = 'StreamStateError'\n  }\n}\n\n/**\n * Thrown when a value could not be found\n */\nexport class NotFoundError extends Error {\n  static name = 'NotFoundError'\n\n  constructor (message = 'Not found') {\n    super(message)\n    this.name = 'NotFoundError'\n  }\n}\n\n/**\n * Thrown when an invalid peer ID is encountered\n */\nexport class InvalidPeerIdError extends Error {\n  static name = 'InvalidPeerIdError'\n\n  constructor (message = 'Invalid PeerID') {\n    super(message)\n    this.name = 'InvalidPeerIdError'\n  }\n}\n\n/**\n * Thrown when an invalid multiaddr is encountered\n */\nexport class InvalidMultiaddrError extends Error {\n  static name = 'InvalidMultiaddrError'\n\n  constructor (message = 'Invalid multiaddr') {\n    super(message)\n    this.name = 'InvalidMultiaddrError'\n  }\n}\n\n/**\n * Thrown when an invalid CID is encountered\n */\nexport class InvalidCIDError extends Error {\n  static name = 'InvalidCIDError'\n\n  constructor (message = 'Invalid CID') {\n    super(message)\n    this.name = 'InvalidCIDError'\n  }\n}\n\n/**\n * Thrown when an invalid multihash is encountered\n */\nexport class InvalidMultihashError extends Error {\n  static name = 'InvalidMultihashError'\n\n  constructor (message = 'Invalid Multihash') {\n    super(message)\n    this.name = 'InvalidMultihashError'\n  }\n}\n\n/**\n * Thrown when a protocol is not supported\n */\nexport class UnsupportedProtocolError extends Error {\n  static name = 'UnsupportedProtocolError'\n\n  constructor (message = 'Unsupported protocol error') {\n    super(message)\n    this.name = 'UnsupportedProtocolError'\n  }\n}\n\n/**\n * An invalid or malformed message was encountered during a protocol exchange\n */\nexport class InvalidMessageError extends Error {\n  static name = 'InvalidMessageError'\n\n  constructor (message = 'Invalid message') {\n    super(message)\n    this.name = 'InvalidMessageError'\n  }\n}\n\n/**\n * Thrown when a remote peer sends a structurally valid message that does not\n * comply with the protocol\n */\nexport class ProtocolError extends Error {\n  static name = 'ProtocolError'\n\n  constructor (message = 'Protocol error') {\n    super(message)\n    this.name = 'ProtocolError'\n  }\n}\n\n/**\n * Throw when an operation times out\n */\nexport class TimeoutError extends Error {\n  static name = 'TimeoutError'\n\n  constructor (message = 'Timed out') {\n    super(message)\n    this.name = 'TimeoutError'\n  }\n}\n\n/**\n * Thrown when a startable component is interacted with but it has not been\n * started yet\n */\nexport class NotStartedError extends Error {\n  static name = 'NotStartedError'\n\n  constructor (message = 'Not started') {\n    super(message)\n    this.name = 'NotStartedError'\n  }\n}\n\n/**\n * Thrown when a component is started that has already been started\n */\nexport class AlreadyStartedError extends Error {\n  static name = 'AlreadyStartedError'\n\n  constructor (message = 'Already started') {\n    super(message)\n    this.name = 'AlreadyStartedError'\n  }\n}\n\n/**\n * Thrown when dialing an address failed\n */\nexport class DialError extends Error {\n  static name = 'DialError'\n\n  constructor (message = 'Dial error') {\n    super(message)\n    this.name = 'DialError'\n  }\n}\n\n/**\n * Thrown when listening on an address failed\n */\nexport class ListenError extends Error {\n  static name = 'ListenError'\n\n  constructor (message = 'Listen error') {\n    super(message)\n    this.name = 'ListenError'\n  }\n}\n\n/**\n * This error is thrown when a limited connection is encountered, i.e. if the\n * user tried to open a stream on a connection for a protocol that is not\n * configured to run over limited connections.\n */\nexport class LimitedConnectionError extends Error {\n  static name = 'LimitedConnectionError'\n\n  constructor (message = 'Limited connection') {\n    super(message)\n    this.name = 'LimitedConnectionError'\n  }\n}\n\n/**\n * This error is thrown where there are too many inbound protocols streams open\n */\nexport class TooManyInboundProtocolStreamsError extends Error {\n  static name = 'TooManyInboundProtocolStreamsError'\n\n  constructor (message = 'Too many inbound protocol streams') {\n    super(message)\n    this.name = 'TooManyInboundProtocolStreamsError'\n  }\n}\n\n/**\n * This error is thrown where there are too many outbound protocols streams open\n */\nexport class TooManyOutboundProtocolStreamsError extends Error {\n  static name = 'TooManyOutboundProtocolStreamsError'\n\n  constructor (message = 'Too many outbound protocol streams') {\n    super(message)\n    this.name = 'TooManyOutboundProtocolStreamsError'\n  }\n}\n\n/**\n * Thrown when and attempt to operate on an unsupported key was made\n */\nexport class UnsupportedKeyTypeError extends Error {\n  static name = 'UnsupportedKeyTypeError'\n\n  constructor (message = 'Unsupported key type') {\n    super(message)\n    this.name = 'UnsupportedKeyTypeError'\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Exports a `Libp2p` type for modules to use as a type argument.\n *\n * @example\n *\n * ```typescript\n * import type { Libp2p } from '@libp2p/interface'\n *\n * function doSomethingWithLibp2p (node: Libp2p) {\n *   // ...\n * }\n * ```\n */\n\nimport type { Connection, NewStreamOptions, Stream } from './connection.js'\nimport type { ContentRouting } from './content-routing.js'\nimport type { TypedEventTarget } from './event-target.js'\nimport type { Ed25519PublicKey, PublicKey, RSAPublicKey, Secp256k1PublicKey } from './keys.js'\nimport type { Metrics } from './metrics.js'\nimport type { Ed25519PeerId, PeerId, RSAPeerId, Secp256k1PeerId, URLPeerId } from './peer-id.js'\nimport type { PeerInfo } from './peer-info.js'\nimport type { PeerRouting } from './peer-routing.js'\nimport type { Address, Peer, PeerStore } from './peer-store.js'\nimport type { Startable } from './startable.js'\nimport type { StreamHandler, StreamHandlerOptions } from './stream-handler.js'\nimport type { Topology } from './topology.js'\nimport type { Listener, OutboundConnectionUpgradeEvents } from './transport.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\n/**\n * Used by the connection manager to sort addresses into order before dialling\n */\nexport interface AddressSorter {\n  (a: Address, b: Address): -1 | 0 | 1\n}\n\n/**\n * Event detail emitted when peer data changes\n */\nexport interface PeerUpdate {\n  peer: Peer\n  previous?: Peer\n}\n\n/**\n * Peer data signed by the remote Peer's public key\n */\nexport interface SignedPeerRecord {\n  addresses: Multiaddr[]\n  seq: bigint\n}\n\nexport interface TLSCertificate {\n  /**\n   * The private key that corresponds to the certificate in PEM format\n   */\n  key: string\n\n  /**\n   * The certificate chain in PEM format\n   */\n  cert: string\n}\n\n/**\n * Data returned from a successful identify response\n */\nexport interface IdentifyResult {\n  /**\n   * The remote Peer's PeerId\n   */\n  peerId: PeerId\n\n  /**\n   * The unsigned addresses they are listening on. Note - any multiaddrs present\n   * in the signed peer record should be preferred to the value here.\n   */\n  listenAddrs: Multiaddr[]\n\n  /**\n   * The protocols the remote peer supports\n   */\n  protocols: string[]\n\n  /**\n   * The remote protocol version\n   */\n  protocolVersion?: string\n\n  /**\n   * The remote agent version\n   */\n  agentVersion?: string\n\n  /**\n   * The public key part of the remote PeerId - this is only useful for older\n   * RSA-based PeerIds, the more modern Ed25519 and secp256k1 types have the\n   * public key embedded in them\n   */\n  publicKey?: Uint8Array\n\n  /**\n   * If set this is the address that the remote peer saw the identify request\n   * originate from\n   */\n  observedAddr?: Multiaddr\n\n  /**\n   * If sent by the remote peer this is the deserialized signed peer record\n   */\n  signedPeerRecord?: SignedPeerRecord\n\n  /**\n   * The connection that the identify protocol ran over\n   */\n  connection: Connection\n}\n\n/**\n * Logger component for libp2p\n */\nexport interface Logger {\n  (formatter: any, ...args: any[]): void\n  error(formatter: any, ...args: any[]): void\n  trace(formatter: any, ...args: any[]): void\n  enabled: boolean\n}\n\n/**\n * Peer logger component for libp2p\n */\nexport interface ComponentLogger {\n  forComponent(name: string): Logger\n}\n\n/**\n * Once you have a libp2p instance, you can listen to several events it emits,\n * so that you can be notified of relevant network events.\n *\n * Event names are `noun:verb` so the first part is the name of the object\n * being acted on and the second is the action.\n */\nexport interface Libp2pEvents<T extends ServiceMap = ServiceMap> {\n  /**\n   * This event is dispatched when a new network peer is discovered.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:discovery', (event) => {\n   *    const peerInfo = event.detail\n   *    // ...\n   * })\n   * ```\n   */\n  'peer:discovery': CustomEvent<PeerInfo>\n\n  /**\n   * This event will be triggered any time a new peer connects.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:connect', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:connect': CustomEvent<PeerId>\n\n  /**\n   * This event will be triggered any time we are disconnected from another\n   * peer, regardless of the circumstances of that disconnection. If we happen\n   * to have multiple connections to a peer, this event will **only** be\n   * triggered when the last connection is closed.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:disconnect', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:disconnect': CustomEvent<PeerId>\n\n  /**\n   * When a peer tagged with `keep-alive` disconnects, we will make multiple\n   * attempts to reconnect to it with a backoff factor (see the connection\n   * manager settings for details). If these all fail, the `keep-alive` tag will\n   * be removed and this event will be emitted.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:reconnect-failure', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:reconnect-failure': CustomEvent<PeerId>\n\n  /**\n   * This event is dispatched after a remote peer has successfully responded to\n   * the identify protocol. Note that for this to be emitted, both peers must\n   * have an identify service configured.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:identify', (event) => {\n   *   const identifyResult = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:identify': CustomEvent<IdentifyResult>\n\n  /**\n   * This event is dispatched when the peer store data for a peer has been\n   * updated - e.g. their multiaddrs, protocols etc have changed.\n   *\n   * If they were previously known to this node, the old peer data will be\n   * set in the `previous` field.\n   *\n   * This may be in response to the identify protocol running, a manual\n   * update or some other event.\n   */\n  'peer:update': CustomEvent<PeerUpdate>\n\n  /**\n   * This event is dispatched when the current node's peer record changes -\n   * for example a transport started listening on a new address or a new\n   * protocol handler was registered.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('self:peer:update', (event) => {\n   *   const { peer } = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'self:peer:update': CustomEvent<PeerUpdate>\n\n  /**\n   * This event is dispatched when a transport begins listening on a new address\n   */\n  'transport:listening': CustomEvent<Listener>\n\n  /**\n   * This event is dispatched when a transport stops listening on an address\n   */\n  'transport:close': CustomEvent<Listener>\n\n  /**\n   * This event is dispatched when the connection manager has more than the\n   * configured allowable max connections and has closed some connections to\n   * bring the node back under the limit.\n   */\n  'connection:prune': CustomEvent<Connection[]>\n\n  /**\n   * This event notifies listeners when new incoming or outgoing connections\n   * are opened.\n   */\n  'connection:open': CustomEvent<Connection>\n\n  /**\n   * This event notifies listeners when incoming or outgoing connections are\n   * closed.\n   */\n  'connection:close': CustomEvent<Connection>\n\n  /**\n   * This event notifies listeners that a TLS certificate is available for use\n   */\n  'certificate:provision': CustomEvent<TLSCertificate>\n\n  /**\n   * This event notifies listeners that a new TLS certificate is available for\n   * use. Any previous certificate may no longer be valid.\n   */\n  'certificate:renew': CustomEvent<TLSCertificate>\n\n  /**\n   * This event notifies listeners that the node has started\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('start', (event) => {\n   *   console.info(libp2p.isStarted()) // true\n   * })\n   * ```\n   */\n  'start': CustomEvent<Libp2p<T>>\n\n  /**\n   * This event notifies listeners that the node has stopped\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('stop', (event) => {\n   *   console.info(libp2p.isStarted()) // false\n   * })\n   * ```\n   */\n  'stop': CustomEvent<Libp2p<T>>\n}\n\n/**\n * A map of user defined services available on the libp2p node via the\n * `services` key\n *\n * @example\n *\n * ```TypeScript\n * const node = await createLibp2p({\n *   // ...other options\n *   services: {\n *     myService: myService({\n *       // ...service options\n *     })\n *   }\n * })\n *\n * // invoke methods on the service\n * node.services.myService.anOperation()\n * ```\n */\nexport type ServiceMap = Record<string, unknown>\n\nexport type PendingDialStatus = 'queued' | 'active' | 'error' | 'success'\n\n/**\n * An item in the dial queue\n */\nexport interface PendingDial {\n  /**\n   * A unique identifier for this dial\n   */\n  id: string\n\n  /**\n   * The current status of the dial\n   */\n  status: PendingDialStatus\n\n  /**\n   * If known, this is the peer id that libp2p expects to be dialling\n   */\n  peerId?: PeerId\n\n  /**\n   * The list of multiaddrs that will be dialled. The returned connection will\n   * use the first address that succeeds, all other dials part of this pending\n   * dial will be cancelled.\n   */\n  multiaddrs: Multiaddr[]\n}\n\nexport type Libp2pStatus = 'starting' | 'started' | 'stopping' | 'stopped'\n\nexport interface IsDialableOptions extends AbortOptions {\n  /**\n   * If the dial attempt would open a protocol, and the multiaddr being dialed\n   * is a circuit relay address, passing true here would cause the test to fail\n   * because that protocol would not be allowed to run over a data/time limited\n   * connection.\n   */\n  runOnLimitedConnection?: boolean\n}\n\nexport type TransportManagerDialProgressEvents =\n  ProgressEvent<'transport-manager:selected-transport', string>\n\nexport type OpenConnectionProgressEvents =\n  TransportManagerDialProgressEvents |\n  ProgressEvent<'dial-queue:already-connected'> |\n  ProgressEvent<'dial-queue:already-in-dial-queue'> |\n  ProgressEvent<'dial-queue:add-to-dial-queue'> |\n  ProgressEvent<'dial-queue:start-dial'> |\n  ProgressEvent<'dial-queue:calculated-addresses', Address[]> |\n  OutboundConnectionUpgradeEvents\n\nexport interface DialOptions extends AbortOptions, ProgressOptions {\n  /**\n   * If true, open a new connection to the remote even if one already exists\n   */\n  force?: boolean\n}\n\nexport interface DialProtocolOptions extends NewStreamOptions {\n\n}\n\n/**\n * Libp2p nodes implement this interface.\n */\nexport interface Libp2p<T extends ServiceMap = ServiceMap> extends Startable, TypedEventTarget<Libp2pEvents<T>> {\n  /**\n   * The PeerId is a unique identifier for a node on the network.\n   *\n   * It is the hash of an RSA public key or, for Ed25519 or secp256k1 keys,\n   * the key itself.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * console.info(libp2p.peerId)\n   * // PeerId(12D3Foo...)\n   * ````\n   */\n  peerId: PeerId\n\n  /**\n   * The peer store holds information we know about other peers on the network.\n   * - multiaddrs, supported protocols, etc.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peer = await libp2p.peerStore.get(peerId)\n   * console.info(peer)\n   * // { id: PeerId(12D3Foo...), addresses: [] ... }\n   * ```\n   */\n  peerStore: PeerStore\n\n  /**\n   * The peer routing subsystem allows the user to find peers on the network\n   * or to find peers close to binary keys.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peerInfo = await libp2p.peerRouting.findPeer(peerId)\n   * console.info(peerInfo)\n   * // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * ```\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for await (const peerInfo of libp2p.peerRouting.getClosestPeers(key)) {\n   *   console.info(peerInfo)\n   *   // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * }\n   * ```\n   */\n  peerRouting: PeerRouting\n\n  /**\n   * The content routing subsystem allows the user to find providers for content,\n   * let the network know they are providers for content, and get/put values to\n   * the DHT.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for await (const peerInfo of libp2p.contentRouting.findProviders(cid)) {\n   *   console.info(peerInfo)\n   *   // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * }\n   * ```\n   */\n  contentRouting: ContentRouting\n\n  /**\n   * The metrics subsystem allows recording values to assess the health/performance\n   * of the running node.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const metric = libp2p.metrics.registerMetric({\n   *   'my-metric'\n   * })\n   *\n   * // later\n   * metric.update(5)\n   * ```\n   */\n  metrics?: Metrics\n\n  /**\n   * The logger used by this libp2p node\n   */\n  logger: ComponentLogger\n\n  /**\n   * The current status of the libp2p node\n   */\n  status: Libp2pStatus\n\n  /**\n   * Get a deduplicated list of peer advertising multiaddrs by concatenating\n   * the listen addresses used by transports with any configured\n   * announce addresses as well as observed addresses reported by peers.\n   *\n   * If Announce addrs are specified, configured listen addresses will be\n   * ignored though observed addresses will still be included.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const listenMa = libp2p.getMultiaddrs()\n   * // [ <Multiaddr 047f00000106f9ba - /ip4/127.0.0.1/tcp/63930> ]\n   * ```\n   */\n  getMultiaddrs(): Multiaddr[]\n\n  /**\n   * Returns a list of supported protocols\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const protocols = libp2p.getProtocols()\n   * // [ '/ipfs/ping/1.0.0', '/ipfs/id/1.0.0' ]\n   * ```\n   */\n  getProtocols(): string[]\n\n  /**\n   * Return a list of all connections this node has open, optionally filtering\n   * by a PeerId\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for (const connection of libp2p.getConnections()) {\n   *   console.log(peerId, connection.remoteAddr.toString())\n   *   // Logs the PeerId string and the observed remote multiaddr of each Connection\n   * }\n   * ```\n   */\n  getConnections(peerId?: PeerId): Connection[]\n\n  /**\n   * Return the list of dials currently in progress or queued to start\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for (const pendingDial of libp2p.getDialQueue()) {\n   *   console.log(pendingDial)\n   * }\n   * ```\n   */\n  getDialQueue(): PendingDial[]\n\n  /**\n   * Return a list of all peers we currently have a connection open to\n   */\n  getPeers(): PeerId[]\n\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`.\n   *\n   * If a PeerId is passed as the first argument, the peer will need to have known multiaddrs for it in the PeerStore.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const conn = await libp2p.dial(remotePeerId)\n   *\n   * // create a new stream within the connection\n   * const stream = await conn.newStream(['/echo/1.1.0', '/echo/1.0.0'])\n   *\n   * // protocol negotiated: 'echo/1.0.0' means that the other party only supports the older version\n   *\n   * // ...\n   * await conn.close()\n   * ```\n   */\n  dial(peer: PeerId | Multiaddr | Multiaddr[], options?: DialOptions): Promise<Connection>\n\n  /**\n   * Dials to the provided peer and tries to handshake with the given protocols in order.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `MuxedStream` will be returned together with the successful negotiated protocol.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * import { pipe } from 'it-pipe'\n   *\n   * const { stream, protocol } = await libp2p.dialProtocol(remotePeerId, protocols)\n   *\n   * // Use this new stream like any other duplex stream\n   * pipe([1, 2, 3], stream, consume)\n   * ```\n   */\n  dialProtocol(peer: PeerId | Multiaddr | Multiaddr[], protocols: string | string[], options?: DialProtocolOptions): Promise<Stream>\n\n  /**\n   * Attempts to gracefully close an open connection to the given peer. If the\n   * connection is not closed in the grace period, it will be forcefully closed.\n   *\n   * An AbortSignal can optionally be passed to control when the connection is\n   * forcefully closed.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await libp2p.hangUp(remotePeerId)\n   * ```\n   */\n  hangUp(peer: PeerId | Multiaddr, options?: AbortOptions): Promise<void>\n\n  /**\n   * Sets up [multistream-select routing](https://github.com/multiformats/multistream-select) of protocols to their application handlers. Whenever a stream is opened on one of the provided protocols, the handler will be called. `handle` must be called in order to register a handler and support for a given protocol. This also informs other peers of the protocols you support.\n   *\n   * `libp2p.handle(protocols, handler, options)`\n   *\n   * In the event of a new handler for the same protocol being added and error\n   * will be thrown. Pass `force: true` to override this.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const handler = ({ connection, stream, protocol }) => {\n   *   // use stream or connection according to the needs\n   * }\n   *\n   * libp2p.handle('/echo/1.0.0', handler, {\n   *   maxInboundStreams: 5,\n   *   maxOutboundStreams: 5\n   * })\n   * ```\n   */\n  handle(protocol: string | string[], handler: StreamHandler, options?: StreamHandlerOptions): Promise<void>\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.unhandle(['/echo/1.0.0'])\n   * ```\n   */\n  unhandle(protocols: string[] | string): Promise<void>\n\n  /**\n   * Register a topology to be informed when peers are encountered that\n   * support the specified protocol\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const id = await libp2p.register('/echo/1.0.0', {\n   *   onConnect: (peer, connection) => {\n   *     // handle connect\n   *   },\n   *   onDisconnect: (peer, connection) => {\n   *     // handle disconnect\n   *   }\n   * })\n   * ```\n   */\n  register(protocol: string, topology: Topology): Promise<string>\n\n  /**\n   * Unregister topology to no longer be informed when peers connect or\n   * disconnect.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const id = await libp2p.register(...)\n   *\n   * libp2p.unregister(id)\n   * ```\n   */\n  unregister(id: string): void\n\n  /**\n   * Returns the public key for the passed PeerId. If the PeerId is of the 'RSA'\n   * type this may mean searching the routing if the peer's key is not present\n   * in the peer store.\n   */\n  getPublicKey(peer: Ed25519PeerId, options?: AbortOptions): Promise<Ed25519PublicKey>\n  getPublicKey(peer: Secp256k1PeerId, options?: AbortOptions): Promise<Secp256k1PublicKey>\n  getPublicKey(peer: RSAPeerId, options?: AbortOptions): Promise<RSAPublicKey>\n  getPublicKey(peer: URLPeerId, options?: AbortOptions): Promise<never>\n  getPublicKey(peer: PeerId, options?: AbortOptions): Promise<PublicKey>\n\n  /**\n   * Given the current node configuration, returns a promise of `true` or\n   * `false` if the node would attempt to dial the passed multiaddr.\n   *\n   * This means a relevant transport is configured, and the connection gater\n   * would not block the dial attempt.\n   *\n   * This may involve resolving DNS addresses so you should pass an AbortSignal.\n   */\n  isDialable(multiaddr: Multiaddr | Multiaddr[], options?: IsDialableOptions): Promise<boolean>\n\n  /**\n   * A set of user defined services\n   */\n  services: T\n}\n\n/**\n * Metadata about the current node\n */\nexport interface NodeInfo {\n  /**\n   * The implementation name\n   */\n  name: string\n\n  /**\n   * The implementation version\n   */\n  version: string\n\n  /**\n   * A string that contains information about the implementation and runtime\n   */\n  userAgent: string\n}\n\n/**\n * An object that contains an AbortSignal as\n * the optional `signal` property.\n *\n * @example\n *\n * ```TypeScript\n * const controller = new AbortController()\n *\n * aLongRunningOperation({\n *   signal: controller.signal\n * })\n *\n * // later\n *\n * controller.abort()\n */\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\n/**\n * An object that contains a Logger as the `log` property.\n */\nexport interface LoggerOptions {\n  log: Logger\n}\n\n/**\n * An object that includes a trace object that is passed onwards.\n *\n * This is used by metrics method tracing to link function calls together.\n */\nexport interface TraceOptions {\n  trace?: any\n}\n\n/**\n * A signal that needs to be cleared when no longer in use\n */\nexport interface ClearableSignal extends AbortSignal {\n  clear(): void\n}\n\n/**\n * When a routing operation involves reading values, these options allow\n * controlling where the values are read from. By default libp2p will check\n * local caches but may not use the network if a valid local value is found,\n * these options allow tuning that behavior.\n */\nexport interface RoutingOptions extends AbortOptions, ProgressOptions, TraceOptions {\n  /**\n   * Pass `false` to not use the network\n   *\n   * @default true\n   */\n  useNetwork?: boolean\n\n  /**\n   * Pass `false` to not use cached values\n   *\n   * @default true\n   */\n  useCache?: boolean\n}\n\n/**\n * This symbol is used by libp2p services to define the capabilities they can\n * provide to other libp2p services.\n *\n * The service should define a property with this symbol as the key and the\n * value should be a string array of provided capabilities.\n */\nexport const serviceCapabilities = Symbol.for('@libp2p/service-capabilities')\n\n/**\n * This symbol is used by libp2p services to define the capabilities they\n * require from other libp2p services.\n *\n * The service should define a property with this symbol as the key and the\n * value should be a string array of required capabilities.\n */\nexport const serviceDependencies = Symbol.for('@libp2p/service-dependencies')\n\nexport * from './connection.js'\nexport * from './connection-encrypter.js'\nexport * from './connection-gater.js'\nexport * from './content-routing.js'\nexport * from './keys.js'\nexport * from './metrics.js'\nexport * from './peer-discovery.js'\nexport * from './peer-id.js'\nexport * from './peer-info.js'\nexport * from './peer-routing.js'\nexport * from './peer-store.js'\nexport * from './pubsub.js'\nexport * from './record.js'\nexport * from './stream-handler.js'\nexport * from './stream-muxer.js'\nexport * from './topology.js'\nexport * from './transport.js'\nexport * from './errors.js'\nexport * from './event-target.js'\nexport * from './events.js'\nexport * from './startable.js'\n", "import { Uint8ArrayList } from 'uint8arraylist'\n\ninterface Context {\n  offset: number\n}\n\nconst TAG_MASK = parseInt('11111', 2)\nconst LONG_LENGTH_MASK = parseInt('10000000', 2)\nconst LONG_LENGTH_BYTES_MASK = parseInt('01111111', 2)\n\ninterface Decoder {\n  (buf: Uint8Array, context: Context): any\n}\n\nconst decoders: Record<number, Decoder> = {\n  0x0: readSequence,\n  0x1: readSequence,\n  0x2: readInteger,\n  0x3: readBitString,\n  0x4: readOctetString,\n  0x5: readNull,\n  0x6: readObjectIdentifier,\n  0x10: readSequence,\n  0x16: readSequence,\n  0x30: readSequence\n}\n\nexport function decodeDer (buf: Uint8Array, context: Context = { offset: 0 }): any {\n  const tag = buf[context.offset] & TAG_MASK\n  context.offset++\n\n  if (decoders[tag] != null) {\n    return decoders[tag](buf, context)\n  }\n\n  throw new Error('No decoder for tag ' + tag)\n}\n\nfunction readLength (buf: Uint8Array, context: Context): number {\n  let length = 0\n\n  if ((buf[context.offset] & LONG_LENGTH_MASK) === LONG_LENGTH_MASK) {\n    // long length\n    const count = buf[context.offset] & LONG_LENGTH_BYTES_MASK\n    let str = '0x'\n    context.offset++\n\n    for (let i = 0; i < count; i++, context.offset++) {\n      str += buf[context.offset].toString(16).padStart(2, '0')\n    }\n\n    length = parseInt(str, 16)\n  } else {\n    length = buf[context.offset]\n    context.offset++\n  }\n\n  return length\n}\n\nfunction readSequence (buf: Uint8Array, context: Context): any[] {\n  readLength(buf, context)\n  const entries: any[] = []\n\n  while (true) {\n    if (context.offset >= buf.byteLength) {\n      break\n    }\n\n    const result = decodeDer(buf, context)\n\n    if (result === null) {\n      break\n    }\n\n    entries.push(result)\n  }\n\n  return entries\n}\n\nfunction readInteger (buf: Uint8Array, context: Context): Uint8Array {\n  const length = readLength(buf, context)\n  const start = context.offset\n  const end = context.offset + length\n\n  const vals: number[] = []\n\n  for (let i = start; i < end; i++) {\n    if (i === start && buf[i] === 0) {\n      continue\n    }\n\n    vals.push(buf[i])\n  }\n\n  context.offset += length\n\n  return Uint8Array.from(vals)\n}\n\nfunction readObjectIdentifier (buf: Uint8Array, context: Context): string {\n  const count = readLength(buf, context)\n  const finalOffset = context.offset + count\n\n  const byte = buf[context.offset]\n  context.offset++\n\n  let val1 = 0\n  let val2 = 0\n\n  if (byte < 40) {\n    val1 = 0\n    val2 = byte\n  } else if (byte < 80) {\n    val1 = 1\n    val2 = byte - 40\n  } else {\n    val1 = 2\n    val2 = byte - 80\n  }\n\n  let oid = `${val1}.${val2}`\n  let num: number[] = []\n\n  while (context.offset < finalOffset) {\n    const byte = buf[context.offset]\n    context.offset++\n\n    // remove msb\n    num.push(byte & 0b01111111)\n\n    if (byte < 128) {\n      num.reverse()\n\n      // reached the end of the encoding\n      let val = 0\n\n      for (let i = 0; i < num.length; i++) {\n        val += num[i] << (i * 7)\n      }\n\n      oid += `.${val}`\n      num = []\n    }\n  }\n\n  return oid\n}\n\nfunction readNull (buf: Uint8Array, context: Context): null {\n  context.offset++\n\n  return null\n}\n\nfunction readBitString (buf: Uint8Array, context: Context): any {\n  const length = readLength(buf, context)\n  const unusedBits = buf[context.offset]\n  context.offset++\n  const bytes = buf.subarray(context.offset, context.offset + length - 1)\n  context.offset += length\n\n  if (unusedBits !== 0) {\n    // need to shift all bytes along by this many bits\n    throw new Error('Unused bits in bit string is unimplemented')\n  }\n\n  return bytes\n}\n\nfunction readOctetString (buf: Uint8Array, context: Context): any {\n  const length = readLength(buf, context)\n  const bytes = buf.subarray(context.offset, context.offset + length)\n  context.offset += length\n\n  return bytes\n}\n\nfunction encodeNumber (value: number): Uint8ArrayList {\n  let number = value.toString(16)\n\n  if (number.length % 2 === 1) {\n    number = '0' + number\n  }\n\n  const array = new Uint8ArrayList()\n\n  for (let i = 0; i < number.length; i += 2) {\n    array.append(Uint8Array.from([parseInt(`${number[i]}${number[i + 1]}`, 16)]))\n  }\n\n  return array\n}\n\nfunction encodeLength (bytes: { byteLength: number }): Uint8Array | Uint8ArrayList {\n  if (bytes.byteLength < 128) {\n    return Uint8Array.from([bytes.byteLength])\n  }\n\n  // long length\n  const length = encodeNumber(bytes.byteLength)\n\n  return new Uint8ArrayList(\n    Uint8Array.from([\n      length.byteLength | LONG_LENGTH_MASK\n    ]),\n    length\n  )\n}\n\nexport function encodeInteger (value: Uint8Array | Uint8ArrayList): Uint8ArrayList {\n  const contents = new Uint8ArrayList()\n\n  const mask = 0b10000000\n  const positive = (value.subarray()[0] & mask) === mask\n\n  if (positive) {\n    contents.append(Uint8Array.from([0]))\n  }\n\n  contents.append(value)\n\n  return new Uint8ArrayList(\n    Uint8Array.from([0x02]),\n    encodeLength(contents),\n    contents\n  )\n}\n\nexport function encodeBitString (value: Uint8Array | Uint8ArrayList): Uint8ArrayList {\n  // unused bits is always 0 with full-byte-only values\n  const unusedBits = Uint8Array.from([0])\n\n  const contents = new Uint8ArrayList(\n    unusedBits,\n    value\n  )\n\n  return new Uint8ArrayList(\n    Uint8Array.from([0x03]),\n    encodeLength(contents),\n    contents\n  )\n}\n\nexport function encodeOctetString (value: Uint8Array | Uint8ArrayList): Uint8ArrayList {\n  return new Uint8ArrayList(\n    Uint8Array.from([0x04]),\n    encodeLength(value),\n    value\n  )\n}\n\nexport function encodeSequence (values: Array<Uint8Array | Uint8ArrayList>, tag = 0x30): Uint8ArrayList {\n  const output = new Uint8ArrayList()\n\n  for (const buf of values) {\n    output.append(\n      buf\n    )\n  }\n\n  return new Uint8ArrayList(\n    Uint8Array.from([tag]),\n    encodeLength(output),\n    output\n  )\n}\n", "import type { JWKKeyPair } from '../interface.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport type Curve = 'P-256' | 'P-384' | 'P-521'\n\nexport const ECDSA_P_256_OID = '1.2.840.10045.3.1.7'\nexport const ECDSA_P_384_OID = '1.3.132.0.34'\nexport const ECDSA_P_521_OID = '1.3.132.0.35'\n\nexport async function generateECDSAKey (curve: Curve = 'P-256'): Promise<JWKKeyPair> {\n  const keyPair = await crypto.subtle.generateKey({\n    name: 'ECDSA',\n    namedCurve: curve\n  }, true, ['sign', 'verify'])\n\n  return {\n    publicKey: await crypto.subtle.exportKey('jwk', keyPair.publicKey),\n    privateKey: await crypto.subtle.exportKey('jwk', keyPair.privateKey)\n  }\n}\n\nexport async function hashAndSign (key: JsonWebKey, msg: Uint8Array | Uint8ArrayList): Promise<Uint8Array> {\n  const privateKey = await crypto.subtle.importKey('jwk', key, {\n    name: 'ECDSA',\n    namedCurve: key.crv ?? 'P-256'\n  }, false, ['sign'])\n\n  const signature = await crypto.subtle.sign({\n    name: 'ECDSA',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, privateKey, msg.subarray())\n\n  return new Uint8Array(signature, 0, signature.byteLength)\n}\n\nexport async function hashAndVerify (key: JsonWebKey, sig: Uint8Array, msg: Uint8Array | Uint8ArrayList): Promise<boolean> {\n  const publicKey = await crypto.subtle.importKey('jwk', key, {\n    name: 'ECDSA',\n    namedCurve: key.crv ?? 'P-256'\n  }, false, ['verify'])\n\n  return crypto.subtle.verify({\n    name: 'ECDSA',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, publicKey, sig, msg.subarray())\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { decodeDer, encodeBitString, encodeInteger, encodeOctetString, encodeSequence } from '../rsa/der.js'\nimport { ECDSAPrivateKey as ECDSAPrivateKeyClass, ECDSAPublicKey as ECDSAPublicKeyClass } from './ecdsa.js'\nimport { generateECDSAKey } from './index.js'\nimport type { Curve } from '../ecdh/index.js'\nimport type { ECDSAPublicKey, ECDSAPrivateKey } from '@libp2p/interface'\n\n// 1.2.840.10045.3.1.7 prime256v1 (ANSI X9.62 named elliptic curve)\nconst OID_256 = Uint8Array.from([0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07])\n// 1.3.132.0.34 secp384r1 (SECG (Certicom) named elliptic curve)\nconst OID_384 = Uint8Array.from([0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x22])\n// 1.3.132.0.35 secp521r1 (SECG (Certicom) named elliptic curve)\nconst OID_521 = Uint8Array.from([0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x23])\n\nconst P_256_KEY_JWK = {\n  ext: true,\n  kty: 'EC',\n  crv: 'P-256'\n}\n\nconst P_384_KEY_JWK = {\n  ext: true,\n  kty: 'EC',\n  crv: 'P-384'\n}\n\nconst P_521_KEY_JWK = {\n  ext: true,\n  kty: 'EC',\n  crv: 'P-521'\n}\n\nconst P_256_KEY_LENGTH = 32\nconst P_384_KEY_LENGTH = 48\nconst P_521_KEY_LENGTH = 66\n\nexport function unmarshalECDSAPrivateKey (bytes: Uint8Array): ECDSAPrivateKey {\n  const message = decodeDer(bytes)\n\n  return pkiMessageToECDSAPrivateKey(message)\n}\n\nexport function pkiMessageToECDSAPrivateKey (message: any): ECDSAPrivateKey {\n  const privateKey = message[1]\n  const d = uint8ArrayToString(privateKey, 'base64url')\n  const coordinates: Uint8Array = message[2][1][0]\n  const offset = 1\n  let x: string\n  let y: string\n\n  if (privateKey.byteLength === P_256_KEY_LENGTH) {\n    x = uint8ArrayToString(coordinates.subarray(offset, offset + P_256_KEY_LENGTH), 'base64url')\n    y = uint8ArrayToString(coordinates.subarray(offset + P_256_KEY_LENGTH), 'base64url')\n\n    return new ECDSAPrivateKeyClass({\n      ...P_256_KEY_JWK,\n      key_ops: ['sign'],\n      d,\n      x,\n      y\n    })\n  }\n\n  if (privateKey.byteLength === P_384_KEY_LENGTH) {\n    x = uint8ArrayToString(coordinates.subarray(offset, offset + P_384_KEY_LENGTH), 'base64url')\n    y = uint8ArrayToString(coordinates.subarray(offset + P_384_KEY_LENGTH), 'base64url')\n\n    return new ECDSAPrivateKeyClass({\n      ...P_384_KEY_JWK,\n      key_ops: ['sign'],\n      d,\n      x,\n      y\n    })\n  }\n\n  if (privateKey.byteLength === P_521_KEY_LENGTH) {\n    x = uint8ArrayToString(coordinates.subarray(offset, offset + P_521_KEY_LENGTH), 'base64url')\n    y = uint8ArrayToString(coordinates.subarray(offset + P_521_KEY_LENGTH), 'base64url')\n\n    return new ECDSAPrivateKeyClass({\n      ...P_521_KEY_JWK,\n      key_ops: ['sign'],\n      d,\n      x,\n      y\n    })\n  }\n\n  throw new InvalidParametersError(`Private key length was wrong length, got ${privateKey.byteLength}, expected 32, 48 or 66`)\n}\n\nexport function unmarshalECDSAPublicKey (bytes: Uint8Array): ECDSAPublicKey {\n  const message = decodeDer(bytes)\n\n  return pkiMessageToECDSAPublicKey(message)\n}\n\nexport function pkiMessageToECDSAPublicKey (message: any): ECDSAPublicKey {\n  const coordinates = message[1][1][0]\n  const offset = 1\n  let x: string\n  let y: string\n\n  if (coordinates.byteLength === ((P_256_KEY_LENGTH * 2) + 1)) {\n    x = uint8ArrayToString(coordinates.subarray(offset, offset + P_256_KEY_LENGTH), 'base64url')\n    y = uint8ArrayToString(coordinates.subarray(offset + P_256_KEY_LENGTH), 'base64url')\n\n    return new ECDSAPublicKeyClass({\n      ...P_256_KEY_JWK,\n      key_ops: ['verify'],\n      x,\n      y\n    })\n  }\n\n  if (coordinates.byteLength === ((P_384_KEY_LENGTH * 2) + 1)) {\n    x = uint8ArrayToString(coordinates.subarray(offset, offset + P_384_KEY_LENGTH), 'base64url')\n    y = uint8ArrayToString(coordinates.subarray(offset + P_384_KEY_LENGTH), 'base64url')\n\n    return new ECDSAPublicKeyClass({\n      ...P_384_KEY_JWK,\n      key_ops: ['verify'],\n      x,\n      y\n    })\n  }\n\n  if (coordinates.byteLength === ((P_521_KEY_LENGTH * 2) + 1)) {\n    x = uint8ArrayToString(coordinates.subarray(offset, offset + P_521_KEY_LENGTH), 'base64url')\n    y = uint8ArrayToString(coordinates.subarray(offset + P_521_KEY_LENGTH), 'base64url')\n\n    return new ECDSAPublicKeyClass({\n      ...P_521_KEY_JWK,\n      key_ops: ['verify'],\n      x,\n      y\n    })\n  }\n\n  throw new InvalidParametersError(`coordinates were wrong length, got ${coordinates.byteLength}, expected 65, 97 or 133`)\n}\n\nexport function privateKeyToPKIMessage (privateKey: JsonWebKey): Uint8Array {\n  return encodeSequence([\n    encodeInteger(Uint8Array.from([1])), // header\n    encodeOctetString(uint8ArrayFromString(privateKey.d ?? '', 'base64url')), // body\n    encodeSequence([ // PKIProtection\n      getOID(privateKey.crv)\n    ], 0xA0),\n    encodeSequence([ // extraCerts\n      encodeBitString(\n        new Uint8ArrayList(\n          Uint8Array.from([0x04]),\n          uint8ArrayFromString(privateKey.x ?? '', 'base64url'),\n          uint8ArrayFromString(privateKey.y ?? '', 'base64url')\n        )\n      )\n    ], 0xA1)\n  ]).subarray()\n}\n\nexport function publicKeyToPKIMessage (publicKey: JsonWebKey): Uint8Array {\n  return encodeSequence([\n    encodeInteger(Uint8Array.from([1])), // header\n    encodeSequence([ // PKIProtection\n      getOID(publicKey.crv)\n    ], 0xA0),\n    encodeSequence([ // extraCerts\n      encodeBitString(\n        new Uint8ArrayList(\n          Uint8Array.from([0x04]),\n          uint8ArrayFromString(publicKey.x ?? '', 'base64url'),\n          uint8ArrayFromString(publicKey.y ?? '', 'base64url')\n        )\n      )\n    ], 0xA1)\n  ]).subarray()\n}\n\nfunction getOID (curve?: string): Uint8Array {\n  if (curve === 'P-256') {\n    return OID_256\n  }\n\n  if (curve === 'P-384') {\n    return OID_384\n  }\n\n  if (curve === 'P-521') {\n    return OID_521\n  }\n\n  throw new InvalidParametersError(`Invalid curve ${curve}`)\n}\n\nexport async function generateECDSAKeyPair (curve: Curve = 'P-256'): Promise<ECDSAPrivateKey> {\n  const key = await generateECDSAKey(curve)\n\n  return new ECDSAPrivateKeyClass(key.privateKey)\n}\n\nexport function ensureECDSAKey (key: Uint8Array, length: number): Uint8Array {\n  key = Uint8Array.from(key ?? [])\n  if (key.length !== length) {\n    throw new InvalidParametersError(`Key must be a Uint8Array of length ${length}, got ${key.length}`)\n  }\n  return key\n}\n", "import { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { identity } from 'multiformats/hashes/identity'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { publicKeyToProtobuf } from '../index.js'\nimport { privateKeyToPKIMessage, publicKeyToPKIMessage } from './utils.js'\nimport { hashAndVerify, hashAndSign } from './index.js'\nimport type { ECDSAPublicKey as ECDSAPublicKeyInterface, ECDSAPrivateKey as ECDSAPrivateKeyInterface } from '@libp2p/interface'\nimport type { Digest } from 'multiformats/hashes/digest'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport class ECDSAPublicKey implements ECDSAPublicKeyInterface {\n  public readonly type = 'ECDSA'\n  public readonly jwk: JsonWebKey\n  private _raw?: Uint8Array\n\n  constructor (jwk: JsonWebKey) {\n    this.jwk = jwk\n  }\n\n  get raw (): Uint8Array {\n    if (this._raw == null) {\n      this._raw = publicKeyToPKIMessage(this.jwk)\n    }\n\n    return this._raw\n  }\n\n  toMultihash (): Digest<0x0, number> {\n    return identity.digest(publicKeyToProtobuf(this))\n  }\n\n  toCID (): CID<unknown, 114, 0x0, 1> {\n    return CID.createV1(114, this.toMultihash())\n  }\n\n  toString (): string {\n    return base58btc.encode(this.toMultihash().bytes).substring(1)\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  async verify (data: Uint8Array | Uint8ArrayList, sig: Uint8Array): Promise<boolean> {\n    return hashAndVerify(this.jwk, sig, data)\n  }\n}\n\nexport class ECDSAPrivateKey implements ECDSAPrivateKeyInterface {\n  public readonly type = 'ECDSA'\n  public readonly jwk: JsonWebKey\n  public readonly publicKey: ECDSAPublicKey\n  private _raw?: Uint8Array\n\n  constructor (jwk: JsonWebKey) {\n    this.jwk = jwk\n    this.publicKey = new ECDSAPublicKey({\n      crv: jwk.crv,\n      ext: jwk.ext,\n      key_ops: ['verify'],\n      kty: 'EC',\n      x: jwk.x,\n      y: jwk.y\n    })\n  }\n\n  get raw (): Uint8Array {\n    if (this._raw == null) {\n      this._raw = privateKeyToPKIMessage(this.jwk)\n    }\n\n    return this._raw\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  async sign (message: Uint8Array | Uint8ArrayList): Promise<Uint8Array> {\n    return hashAndSign(this.jwk, message)\n  }\n}\n", "import { ed25519 as ed } from '@noble/curves/ed25519'\nimport type { Uint8ArrayKeyPair } from '../interface.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst PUBLIC_KEY_BYTE_LENGTH = 32\nconst PRIVATE_KEY_BYTE_LENGTH = 64 // private key is actually 32 bytes but for historical reasons we concat private and public keys\nconst KEYS_BYTE_LENGTH = 32\n\nexport { PUBLIC_KEY_BYTE_LENGTH as publicKeyLength }\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength }\n\nexport function generateKey (): Uint8ArrayKeyPair {\n  // the actual private key (32 bytes)\n  const privateKeyRaw = ed.utils.randomPrivateKey()\n  const publicKey = ed.getPublicKey(privateKeyRaw)\n\n  // concatenated the public key to the private key\n  const privateKey = concatKeys(privateKeyRaw, publicKey)\n\n  return {\n    privateKey,\n    publicKey\n  }\n}\n\n/**\n * Generate keypair from a 32 byte uint8array\n */\nexport function generateKeyFromSeed (seed: Uint8Array): Uint8ArrayKeyPair {\n  if (seed.length !== KEYS_BYTE_LENGTH) {\n    throw new TypeError('\"seed\" must be 32 bytes in length.')\n  } else if (!(seed instanceof Uint8Array)) {\n    throw new TypeError('\"seed\" must be a node.js Buffer, or Uint8Array.')\n  }\n\n  // based on node forges algorithm, the seed is used directly as private key\n  const privateKeyRaw = seed\n  const publicKey = ed.getPublicKey(privateKeyRaw)\n\n  const privateKey = concatKeys(privateKeyRaw, publicKey)\n\n  return {\n    privateKey,\n    publicKey\n  }\n}\n\nexport function hashAndSign (privateKey: Uint8Array, msg: Uint8Array | Uint8ArrayList): Uint8Array {\n  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH)\n\n  return ed.sign(msg instanceof Uint8Array ? msg : msg.subarray(), privateKeyRaw)\n}\n\nexport function hashAndVerify (publicKey: Uint8Array, sig: Uint8Array, msg: Uint8Array | Uint8ArrayList): boolean {\n  return ed.verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey)\n}\n\nfunction concatKeys (privateKeyRaw: Uint8Array, publicKey: Uint8Array): Uint8Array {\n  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH)\n  for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {\n    privateKey[i] = privateKeyRaw[i]\n    privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i]\n  }\n  return privateKey\n}\n", "import { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { type Digest } from 'multiformats/hashes/digest'\nimport { identity } from 'multiformats/hashes/identity'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { publicKeyToProtobuf } from '../index.js'\nimport { ensureEd25519Key } from './utils.js'\nimport * as crypto from './index.js'\nimport type { Ed25519PublicKey as Ed25519PublicKeyInterface, Ed25519PrivateKey as Ed25519PrivateKeyInterface } from '@libp2p/interface'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport class Ed25519PublicKey implements Ed25519PublicKeyInterface {\n  public readonly type = 'Ed25519'\n  public readonly raw: Uint8Array\n\n  constructor (key: Uint8Array) {\n    this.raw = ensureEd25519Key(key, crypto.publicKeyLength)\n  }\n\n  toMultihash (): Digest<0x0, number> {\n    return identity.digest(publicKeyToProtobuf(this))\n  }\n\n  toCID (): CID<unknown, 114, 0x0, 1> {\n    return CID.createV1(114, this.toMultihash())\n  }\n\n  toString (): string {\n    return base58btc.encode(this.toMultihash().bytes).substring(1)\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  verify (data: Uint8Array | Uint8ArrayList, sig: Uint8Array): boolean {\n    return crypto.hashAndVerify(this.raw, sig, data)\n  }\n}\n\nexport class Ed25519PrivateKey implements Ed25519PrivateKeyInterface {\n  public readonly type = 'Ed25519'\n  public readonly raw: Uint8Array\n  public readonly publicKey: Ed25519PublicKey\n\n  // key       - 64 byte Uint8Array containing private key\n  // publicKey - 32 byte Uint8Array containing public key\n  constructor (key: Uint8Array, publicKey: Uint8Array) {\n    this.raw = ensureEd25519Key(key, crypto.privateKeyLength)\n    this.publicKey = new Ed25519PublicKey(publicKey)\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  sign (message: Uint8Array | Uint8ArrayList): Uint8Array {\n    return crypto.hashAndSign(this.raw, message)\n  }\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { Ed25519PublicKey as Ed25519PublicKeyClass, Ed25519PrivateKey as Ed25519PrivateKeyClass } from './ed25519.js'\nimport * as crypto from './index.js'\nimport type { Ed25519PublicKey, Ed25519PrivateKey } from '@libp2p/interface'\n\nexport function unmarshalEd25519PrivateKey (bytes: Uint8Array): Ed25519PrivateKey {\n  // Try the old, redundant public key version\n  if (bytes.length > crypto.privateKeyLength) {\n    bytes = ensureEd25519Key(bytes, crypto.privateKeyLength + crypto.publicKeyLength)\n    const privateKeyBytes = bytes.subarray(0, crypto.privateKeyLength)\n    const publicKeyBytes = bytes.subarray(crypto.privateKeyLength, bytes.length)\n    return new Ed25519PrivateKeyClass(privateKeyBytes, publicKeyBytes)\n  }\n\n  bytes = ensureEd25519Key(bytes, crypto.privateKeyLength)\n  const privateKeyBytes = bytes.subarray(0, crypto.privateKeyLength)\n  const publicKeyBytes = bytes.subarray(crypto.publicKeyLength)\n  return new Ed25519PrivateKeyClass(privateKeyBytes, publicKeyBytes)\n}\n\nexport function unmarshalEd25519PublicKey (bytes: Uint8Array): Ed25519PublicKey {\n  bytes = ensureEd25519Key(bytes, crypto.publicKeyLength)\n  return new Ed25519PublicKeyClass(bytes)\n}\n\nexport async function generateEd25519KeyPair (): Promise<Ed25519PrivateKey> {\n  const { privateKey, publicKey } = crypto.generateKey()\n  return new Ed25519PrivateKeyClass(privateKey, publicKey)\n}\n\nexport async function generateEd25519KeyPairFromSeed (seed: Uint8Array): Promise<Ed25519PrivateKey> {\n  const { privateKey, publicKey } = crypto.generateKeyFromSeed(seed)\n  return new Ed25519PrivateKeyClass(privateKey, publicKey)\n}\n\nexport function ensureEd25519Key (key: Uint8Array, length: number): Uint8Array {\n  key = Uint8Array.from(key ?? [])\n  if (key.length !== length) {\n    throw new InvalidParametersError(`Key must be a Uint8Array of length ${length}, got ${key.length}`)\n  }\n  return key\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { type Codec, decodeMessage, type DecodeOptions, encodeMessage, enumeration, message } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport enum KeyType {\n  RSA = 'RSA',\n  Ed25519 = 'Ed25519',\n  secp256k1 = 'secp256k1',\n  ECDSA = 'ECDSA'\n}\n\nenum __KeyTypeValues {\n  RSA = 0,\n  Ed25519 = 1,\n  secp256k1 = 2,\n  ECDSA = 3\n}\n\nexport namespace KeyType {\n  export const codec = (): Codec<KeyType> => {\n    return enumeration<KeyType>(__KeyTypeValues)\n  }\n}\nexport interface PublicKey {\n  Type?: KeyType\n  Data?: Uint8Array\n}\n\nexport namespace PublicKey {\n  let _codec: Codec<PublicKey>\n\n  export const codec = (): Codec<PublicKey> => {\n    if (_codec == null) {\n      _codec = message<PublicKey>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8)\n          KeyType.codec().encode(obj.Type, w)\n        }\n\n        if (obj.Data != null) {\n          w.uint32(18)\n          w.bytes(obj.Data)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.Type = KeyType.codec().decode(reader)\n              break\n            }\n            case 2: {\n              obj.Data = reader.bytes()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PublicKey>): Uint8Array => {\n    return encodeMessage(obj, PublicKey.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<PublicKey>): PublicKey => {\n    return decodeMessage(buf, PublicKey.codec(), opts)\n  }\n}\n\nexport interface PrivateKey {\n  Type?: KeyType\n  Data?: Uint8Array\n}\n\nexport namespace PrivateKey {\n  let _codec: Codec<PrivateKey>\n\n  export const codec = (): Codec<PrivateKey> => {\n    if (_codec == null) {\n      _codec = message<PrivateKey>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8)\n          KeyType.codec().encode(obj.Type, w)\n        }\n\n        if (obj.Data != null) {\n          w.uint32(18)\n          w.bytes(obj.Data)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.Type = KeyType.codec().decode(reader)\n              break\n            }\n            case 2: {\n              obj.Data = reader.bytes()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PrivateKey>): Uint8Array => {\n    return encodeMessage(obj, PrivateKey.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<PrivateKey>): PrivateKey => {\n    return decodeMessage(buf, PrivateKey.codec(), opts)\n  }\n}\n", "/**\n * Signing a message failed\n */\nexport class SigningError extends Error {\n  constructor (message = 'An error occurred while signing a message') {\n    super(message)\n    this.name = 'SigningError'\n  }\n}\n\n/**\n * Verifying a message signature failed\n */\nexport class VerificationError extends Error {\n  constructor (message = 'An error occurred while verifying a message') {\n    super(message)\n    this.name = 'VerificationError'\n  }\n}\n\n/**\n * WebCrypto was not available in the current context\n */\nexport class WebCryptoMissingError extends Error {\n  constructor (message = 'Missing Web Crypto API') {\n    super(message)\n    this.name = 'WebCryptoMissingError'\n  }\n}\n", "import { InvalidParametersError, InvalidPublicKeyError } from '@libp2p/interface'\nimport { sha256 } from '@noble/hashes/sha256'\nimport { create } from 'multiformats/hashes/digest'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport * as pb from '../keys.js'\nimport { decodeDer, encodeBitString, encodeInteger, encodeSequence } from './der.js'\nimport { RSAPrivateKey as RSAPrivateKeyClass, RSAPublicKey as RSAPublicKeyClass } from './rsa.js'\nimport { generateRSAKey, rsaKeySize } from './index.js'\nimport type { JWKKeyPair } from '../interface.js'\nimport type { RSAPrivateKey, RSAPublicKey } from '@libp2p/interface'\nimport type { Digest } from 'multiformats/hashes/digest'\n\nexport const MAX_RSA_KEY_SIZE = 8192\nconst SHA2_256_CODE = 0x12\nconst MAX_RSA_JWK_SIZE = 1062\n\nconst RSA_ALGORITHM_IDENTIFIER = Uint8Array.from([\n  0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00\n])\n\n/**\n * Convert a PKCS#1 in ASN1 DER format to a JWK private key\n */\nexport function pkcs1ToJwk (bytes: Uint8Array): JsonWebKey {\n  const message = decodeDer(bytes)\n\n  return pkcs1MessageToJwk(message)\n}\n\n/**\n * Convert a PKCS#1 in ASN1 DER format to a JWK private key\n */\nexport function pkcs1MessageToJwk (message: any): JsonWebKey {\n  return {\n    n: uint8ArrayToString(message[1], 'base64url'),\n    e: uint8ArrayToString(message[2], 'base64url'),\n    d: uint8ArrayToString(message[3], 'base64url'),\n    p: uint8ArrayToString(message[4], 'base64url'),\n    q: uint8ArrayToString(message[5], 'base64url'),\n    dp: uint8ArrayToString(message[6], 'base64url'),\n    dq: uint8ArrayToString(message[7], 'base64url'),\n    qi: uint8ArrayToString(message[8], 'base64url'),\n    kty: 'RSA'\n  }\n}\n\n/**\n * Convert a JWK private key into PKCS#1 in ASN1 DER format\n */\nexport function jwkToPkcs1 (jwk: JsonWebKey): Uint8Array {\n  if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {\n    throw new InvalidParametersError('JWK was missing components')\n  }\n\n  return encodeSequence([\n    encodeInteger(Uint8Array.from([0])),\n    encodeInteger(uint8ArrayFromString(jwk.n, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.e, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.d, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.p, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.q, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.dp, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.dq, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.qi, 'base64url'))\n  ]).subarray()\n}\n\n/**\n * Convert a PKIX in ASN1 DER format to a JWK public key\n */\nexport function pkixToJwk (bytes: Uint8Array): JsonWebKey {\n  const message = decodeDer(bytes, {\n    offset: 0\n  })\n\n  return pkixMessageToJwk(message)\n}\n\nexport function pkixMessageToJwk (message: any): JsonWebKey {\n  const keys = decodeDer(message[1], {\n    offset: 0\n  })\n\n  // this looks fragile but DER is a canonical format so we are safe to have\n  // deeply property chains like this\n  return {\n    kty: 'RSA',\n    n: uint8ArrayToString(\n      keys[0],\n      'base64url'\n    ),\n    e: uint8ArrayToString(\n      keys[1],\n      'base64url'\n    )\n  }\n}\n\n/**\n * Convert a JWK public key to PKIX in ASN1 DER format\n */\nexport function jwkToPkix (jwk: JsonWebKey): Uint8Array {\n  if (jwk.n == null || jwk.e == null) {\n    throw new InvalidParametersError('JWK was missing components')\n  }\n\n  const subjectPublicKeyInfo = encodeSequence([\n    RSA_ALGORITHM_IDENTIFIER,\n    encodeBitString(\n      encodeSequence([\n        encodeInteger(uint8ArrayFromString(jwk.n, 'base64url')),\n        encodeInteger(uint8ArrayFromString(jwk.e, 'base64url'))\n      ])\n    )\n  ])\n\n  return subjectPublicKeyInfo.subarray()\n}\n\n/**\n * Turn PKCS#1 DER bytes into a PrivateKey\n */\nexport function pkcs1ToRSAPrivateKey (bytes: Uint8Array): RSAPrivateKey {\n  const message = decodeDer(bytes)\n\n  return pkcs1MessageToRSAPrivateKey(message)\n}\n\n/**\n * Turn PKCS#1 DER bytes into a PrivateKey\n */\nexport function pkcs1MessageToRSAPrivateKey (message: any): RSAPrivateKey {\n  const jwk = pkcs1MessageToJwk(message)\n\n  return jwkToRSAPrivateKey(jwk)\n}\n\n/**\n * Turn a PKIX message into a PublicKey\n */\nexport function pkixToRSAPublicKey (bytes: Uint8Array, digest?: Digest<18, number>): RSAPublicKey {\n  if (bytes.byteLength >= MAX_RSA_JWK_SIZE) {\n    throw new InvalidPublicKeyError('Key size is too large')\n  }\n\n  const message = decodeDer(bytes, {\n    offset: 0\n  })\n\n  return pkixMessageToRSAPublicKey(message, bytes, digest)\n}\n\nexport function pkixMessageToRSAPublicKey (message: any, bytes: Uint8Array, digest?: Digest<18, number>): RSAPublicKey {\n  const jwk = pkixMessageToJwk(message)\n\n  if (digest == null) {\n    const hash = sha256(pb.PublicKey.encode({\n      Type: pb.KeyType.RSA,\n      Data: bytes\n    }))\n    digest = create(SHA2_256_CODE, hash)\n  }\n\n  return new RSAPublicKeyClass(jwk, digest)\n}\n\nexport function jwkToRSAPrivateKey (jwk: JsonWebKey): RSAPrivateKey {\n  if (rsaKeySize(jwk) > MAX_RSA_KEY_SIZE) {\n    throw new InvalidParametersError('Key size is too large')\n  }\n\n  const keys = jwkToJWKKeyPair(jwk)\n  const hash = sha256(pb.PublicKey.encode({\n    Type: pb.KeyType.RSA,\n    Data: jwkToPkix(keys.publicKey)\n  }))\n  const digest = create(SHA2_256_CODE, hash)\n\n  return new RSAPrivateKeyClass(keys.privateKey, new RSAPublicKeyClass(keys.publicKey, digest))\n}\n\nexport async function generateRSAKeyPair (bits: number): Promise<RSAPrivateKey> {\n  if (bits > MAX_RSA_KEY_SIZE) {\n    throw new InvalidParametersError('Key size is too large')\n  }\n\n  const keys = await generateRSAKey(bits)\n  const hash = sha256(pb.PublicKey.encode({\n    Type: pb.KeyType.RSA,\n    Data: jwkToPkix(keys.publicKey)\n  }))\n  const digest = create(SHA2_256_CODE, hash)\n\n  return new RSAPrivateKeyClass(keys.privateKey, new RSAPublicKeyClass(keys.publicKey, digest))\n}\n\n/**\n * Takes a jwk key and returns a JWK KeyPair\n */\nexport function jwkToJWKKeyPair (key: JsonWebKey): JWKKeyPair {\n  if (key == null) {\n    throw new InvalidParametersError('Missing key parameter')\n  }\n\n  return {\n    privateKey: key,\n    publicKey: {\n      kty: key.kty,\n      n: key.n,\n      e: key.e\n    }\n  }\n}\n", "import { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\n\nexport function base64urlToBuffer (str: string, len?: number): Uint8Array {\n  let buf = uint8ArrayFromString(str, 'base64urlpad')\n\n  if (len != null) {\n    if (buf.length > len) throw new Error('byte array longer than desired length')\n    buf = uint8ArrayConcat([new Uint8Array(len - buf.length), buf])\n  }\n\n  return buf\n}\n\nexport function isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  if (thing == null) {\n    return false\n  }\n\n  return typeof thing.then === 'function' &&\n    typeof thing.catch === 'function' &&\n    typeof thing.finally === 'function'\n}\n", "import { secp256k1 as secp } from '@noble/curves/secp256k1'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { SigningError, VerificationError } from '../../errors.js'\nimport { isPromise } from '../../util.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst PUBLIC_KEY_BYTE_LENGTH = 33\nconst PRIVATE_KEY_BYTE_LENGTH = 32\n\nexport { PUBLIC_KEY_BYTE_LENGTH as publicKeyLength }\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength }\n\n/**\n * Hash and sign message with private key\n */\nexport function hashAndSign (key: Uint8Array, msg: Uint8Array | Uint8ArrayList): Uint8Array | Promise<Uint8Array> {\n  const p = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray())\n\n  if (isPromise(p)) {\n    return p.then(({ digest }) => secp.sign(digest, key).toDERRawBytes())\n      .catch(err => {\n        throw new SigningError(String(err))\n      })\n  }\n\n  try {\n    return secp.sign(p.digest, key).toDERRawBytes()\n  } catch (err) {\n    throw new SigningError(String(err))\n  }\n}\n\n/**\n * Hash message and verify signature with public key\n */\nexport function hashAndVerify (key: Uint8Array, sig: Uint8Array, msg: Uint8Array | Uint8ArrayList): boolean | Promise<boolean> {\n  const p = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray())\n\n  if (isPromise(p)) {\n    return p.then(({ digest }) => secp.verify(sig, digest, key))\n      .catch(err => {\n        throw new VerificationError(String(err))\n      })\n  }\n\n  try {\n    return secp.verify(sig, p.digest, key)\n  } catch (err) {\n    throw new VerificationError(String(err))\n  }\n}\n", "import { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { identity } from 'multiformats/hashes/identity'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { publicKeyToProtobuf } from '../index.js'\nimport { validateSecp256k1PublicKey, compressSecp256k1PublicKey, computeSecp256k1PublicKey, validateSecp256k1PrivateKey } from './utils.js'\nimport { hashAndVerify, hashAndSign } from './index.js'\nimport type { Secp256k1PublicKey as Secp256k1PublicKeyInterface, Secp256k1PrivateKey as Secp256k1PrivateKeyInterface } from '@libp2p/interface'\nimport type { Digest } from 'multiformats/hashes/digest'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport class Secp256k1PublicKey implements Secp256k1PublicKeyInterface {\n  public readonly type = 'secp256k1'\n  public readonly raw: Uint8Array\n  public readonly _key: Uint8Array\n\n  constructor (key: Uint8Array) {\n    this._key = validateSecp256k1PublicKey(key)\n    this.raw = compressSecp256k1PublicKey(this._key)\n  }\n\n  toMultihash (): Digest<0x0, number> {\n    return identity.digest(publicKeyToProtobuf(this))\n  }\n\n  toCID (): CID<unknown, 114, 0x0, 1> {\n    return CID.createV1(114, this.toMultihash())\n  }\n\n  toString (): string {\n    return base58btc.encode(this.toMultihash().bytes).substring(1)\n  }\n\n  equals (key: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  verify (data: Uint8Array | Uint8ArrayList, sig: Uint8Array): boolean {\n    return hashAndVerify(this._key, sig, data)\n  }\n}\n\nexport class Secp256k1PrivateKey implements Secp256k1PrivateKeyInterface {\n  public readonly type = 'secp256k1'\n  public readonly raw: Uint8Array\n  public readonly publicKey: Secp256k1PublicKey\n\n  constructor (key: Uint8Array, publicKey?: Uint8Array) {\n    this.raw = validateSecp256k1PrivateKey(key)\n    this.publicKey = new Secp256k1PublicKey(publicKey ?? computeSecp256k1PublicKey(key))\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  sign (message: Uint8Array | Uint8ArrayList): Uint8Array | Promise<Uint8Array> {\n    return hashAndSign(this.raw, message)\n  }\n}\n", "import { InvalidPrivateKeyError, InvalidPublicKeyError } from '@libp2p/interface'\nimport { secp256k1 as secp } from '@noble/curves/secp256k1'\nimport { Secp256k1PublicKey as Secp256k1PublicKeyClass, Secp256k1PrivateKey as Secp256k1PrivateKeyClass } from './secp256k1.js'\nimport type { Secp256k1PublicKey, Secp256k1PrivateKey } from '@libp2p/interface'\n\nconst PRIVATE_KEY_BYTE_LENGTH = 32\n\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength }\n\nexport function unmarshalSecp256k1PrivateKey (bytes: Uint8Array): Secp256k1PrivateKey {\n  return new Secp256k1PrivateKeyClass(bytes)\n}\n\nexport function unmarshalSecp256k1PublicKey (bytes: Uint8Array): Secp256k1PublicKey {\n  return new Secp256k1PublicKeyClass(bytes)\n}\n\nexport async function generateSecp256k1KeyPair (): Promise<Secp256k1PrivateKey> {\n  const privateKeyBytes = generateSecp256k1PrivateKey()\n  return new Secp256k1PrivateKeyClass(privateKeyBytes)\n}\n\nexport function compressSecp256k1PublicKey (key: Uint8Array): Uint8Array {\n  const point = secp.ProjectivePoint.fromHex(key).toRawBytes(true)\n  return point\n}\n\nexport function decompressSecp256k1PublicKey (key: Uint8Array): Uint8Array {\n  const point = secp.ProjectivePoint.fromHex(key).toRawBytes(false)\n  return point\n}\n\nexport function validateSecp256k1PrivateKey (key: Uint8Array): Uint8Array {\n  try {\n    secp.getPublicKey(key, true)\n\n    return key\n  } catch (err) {\n    throw new InvalidPrivateKeyError(String(err))\n  }\n}\n\nexport function validateSecp256k1PublicKey (key: Uint8Array): Uint8Array {\n  try {\n    secp.ProjectivePoint.fromHex(key)\n\n    return key\n  } catch (err) {\n    throw new InvalidPublicKeyError(String(err))\n  }\n}\n\nexport function computeSecp256k1PublicKey (privateKey: Uint8Array): Uint8Array {\n  try {\n    return secp.getPublicKey(privateKey, true)\n  } catch (err) {\n    throw new InvalidPrivateKeyError(String(err))\n  }\n}\n\nexport function generateSecp256k1PrivateKey (): Uint8Array {\n  return secp.utils.randomPrivateKey()\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { base64urlToBuffer } from '../../util.js'\nimport webcrypto from '../../webcrypto/index.js'\nimport type { Curve } from './index.js'\nimport type { ECDHKey, ECDHKeyPair, JWKEncodedPrivateKey, JWKEncodedPublicKey } from '../interface.js'\n\nconst curveLengths = {\n  'P-256': 32,\n  'P-384': 48,\n  'P-521': 66\n}\n\nconst curveTypes = Object.keys(curveLengths)\nconst names = curveTypes.join(' / ')\n\nexport async function generateEphemeralKeyPair (curve: Curve): Promise<ECDHKey> {\n  if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n    throw new InvalidParametersError(`Unknown curve: ${curve}. Must be ${names}`)\n  }\n\n  const pair = await webcrypto.get().subtle.generateKey(\n    {\n      name: 'ECDH',\n      namedCurve: curve\n    },\n    true,\n    ['deriveBits']\n  )\n\n  // forcePrivate is used for testing only\n  const genSharedKey = async (theirPub: Uint8Array, forcePrivate?: ECDHKeyPair): Promise<Uint8Array> => {\n    let privateKey\n\n    if (forcePrivate != null) {\n      privateKey = await webcrypto.get().subtle.importKey(\n        'jwk',\n        unmarshalPrivateKey(curve, forcePrivate),\n        {\n          name: 'ECDH',\n          namedCurve: curve\n        },\n        false,\n        ['deriveBits']\n      )\n    } else {\n      privateKey = pair.privateKey\n    }\n\n    const key = await webcrypto.get().subtle.importKey(\n      'jwk',\n      unmarshalPublicKey(curve, theirPub),\n      {\n        name: 'ECDH',\n        namedCurve: curve\n      },\n      false,\n      []\n    )\n\n    const buffer = await webcrypto.get().subtle.deriveBits(\n      {\n        name: 'ECDH',\n        public: key\n      },\n      privateKey,\n      curveLengths[curve] * 8\n    )\n\n    return new Uint8Array(buffer, 0, buffer.byteLength)\n  }\n\n  const publicKey = await webcrypto.get().subtle.exportKey('jwk', pair.publicKey)\n\n  const ecdhKey: ECDHKey = {\n    key: marshalPublicKey(publicKey),\n    genSharedKey\n  }\n\n  return ecdhKey\n}\n\n// Marshal converts a jwk encoded ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\nfunction marshalPublicKey (jwk: JsonWebKey): Uint8Array {\n  if (jwk.crv == null || jwk.x == null || jwk.y == null) {\n    throw new InvalidParametersError('JWK was missing components')\n  }\n\n  if (jwk.crv !== 'P-256' && jwk.crv !== 'P-384' && jwk.crv !== 'P-521') {\n    throw new InvalidParametersError(`Unknown curve: ${jwk.crv}. Must be ${names}`)\n  }\n\n  const byteLen = curveLengths[jwk.crv]\n\n  return uint8ArrayConcat([\n    Uint8Array.from([4]), // uncompressed point\n    base64urlToBuffer(jwk.x, byteLen),\n    base64urlToBuffer(jwk.y, byteLen)\n  ], 1 + byteLen * 2)\n}\n\n/**\n * Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\n */\nfunction unmarshalPublicKey (curve: Curve, key: Uint8Array): JWKEncodedPublicKey {\n  if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n    throw new InvalidParametersError(`Unknown curve: ${curve}. Must be ${names}`)\n  }\n\n  const byteLen = curveLengths[curve]\n\n  if (!uint8ArrayEquals(key.subarray(0, 1), Uint8Array.from([4]))) {\n    throw new InvalidParametersError('Cannot unmarshal public key - invalid key format')\n  }\n\n  return {\n    kty: 'EC',\n    crv: curve,\n    x: uint8ArrayToString(key.subarray(1, byteLen + 1), 'base64url'),\n    y: uint8ArrayToString(key.subarray(1 + byteLen), 'base64url'),\n    ext: true\n  }\n}\n\nconst unmarshalPrivateKey = (curve: Curve, key: ECDHKeyPair): JWKEncodedPrivateKey => ({\n  ...unmarshalPublicKey(curve, key.public),\n  d: uint8ArrayToString(key.private, 'base64url')\n})\n", "/**\n * @packageDocumentation\n *\n * ## Supported Key Types\n *\n * Currently the `'RSA'`, `'ed25519'`, and `secp256k1` types are supported, although ed25519 and secp256k1 keys support only signing and verification of messages.\n *\n * For encryption / decryption support, RSA keys should be used.\n */\n\nimport { InvalidParametersError, UnsupportedKeyTypeError } from '@libp2p/interface'\nimport { ECDSAPrivateKey as ECDSAPrivateKeyClass } from './ecdsa/ecdsa.js'\nimport { ECDSA_P_256_OID, ECDSA_P_384_OID, ECDSA_P_521_OID } from './ecdsa/index.js'\nimport { generateECDSAKeyPair, pkiMessageToECDSAPrivateKey, pkiMessageToECDSAPublicKey, unmarshalECDSAPrivateKey, unmarshalECDSAPublicKey } from './ecdsa/utils.js'\nimport { privateKeyLength as ed25519PrivateKeyLength, publicKeyLength as ed25519PublicKeyLength } from './ed25519/index.js'\nimport { generateEd25519KeyPair, generateEd25519KeyPairFromSeed, unmarshalEd25519PrivateKey, unmarshalEd25519PublicKey } from './ed25519/utils.js'\nimport * as pb from './keys.js'\nimport { decodeDer } from './rsa/der.js'\nimport { RSAES_PKCS1_V1_5_OID } from './rsa/index.js'\nimport { pkcs1ToRSAPrivateKey, pkixToRSAPublicKey, generateRSAKeyPair, pkcs1MessageToRSAPrivateKey, pkixMessageToRSAPublicKey, jwkToRSAPrivateKey } from './rsa/utils.js'\nimport { privateKeyLength as secp256k1PrivateKeyLength, publicKeyLength as secp256k1PublicKeyLength } from './secp256k1/index.js'\nimport { generateSecp256k1KeyPair, unmarshalSecp256k1PrivateKey, unmarshalSecp256k1PublicKey } from './secp256k1/utils.js'\nimport type { Curve } from './ecdsa/index.js'\nimport type { PrivateKey, PublicKey, KeyType, RSAPrivateKey, Secp256k1PrivateKey, Ed25519PrivateKey, Secp256k1PublicKey, Ed25519PublicKey, ECDSAPrivateKey, ECDSAPublicKey } from '@libp2p/interface'\nimport type { MultihashDigest } from 'multiformats'\nimport type { Digest } from 'multiformats/hashes/digest'\n\nexport { generateEphemeralKeyPair } from './ecdh/index.js'\nexport type { Curve } from './ecdh/index.js'\nexport type { ECDHKey, EnhancedKey, EnhancedKeyPair, ECDHKeyPair } from './interface.js'\nexport { keyStretcher } from './key-stretcher.js'\n\n/**\n * Generates a keypair of the given type and bitsize\n */\nexport async function generateKeyPair (type: 'Ed25519'): Promise<Ed25519PrivateKey>\nexport async function generateKeyPair (type: 'secp256k1'): Promise<Secp256k1PrivateKey>\nexport async function generateKeyPair (type: 'ECDSA', curve?: Curve): Promise<ECDSAPrivateKey>\nexport async function generateKeyPair (type: 'RSA', bits?: number): Promise<RSAPrivateKey>\nexport async function generateKeyPair (type: KeyType, bits?: number): Promise<PrivateKey>\nexport async function generateKeyPair (type: KeyType, bits?: number | string): Promise<unknown> {\n  if (type === 'Ed25519') {\n    return generateEd25519KeyPair()\n  }\n\n  if (type === 'secp256k1') {\n    return generateSecp256k1KeyPair()\n  }\n\n  if (type === 'RSA') {\n    return generateRSAKeyPair(toBits(bits))\n  }\n\n  if (type === 'ECDSA') {\n    return generateECDSAKeyPair(toCurve(bits))\n  }\n\n  throw new UnsupportedKeyTypeError()\n}\n\n/**\n * Generates a keypair of the given type from the passed seed.  Currently only\n * supports Ed25519 keys.\n *\n * Seed is a 32 byte uint8array\n */\nexport async function generateKeyPairFromSeed (type: 'Ed25519', seed: Uint8Array): Promise<Ed25519PrivateKey>\nexport async function generateKeyPairFromSeed <T extends KeyType> (type: T, seed: Uint8Array, bits?: number): Promise<never>\nexport async function generateKeyPairFromSeed (type: string, seed: Uint8Array): Promise<unknown> {\n  if (type !== 'Ed25519') {\n    throw new UnsupportedKeyTypeError('Seed key derivation only supported for Ed25519 keys')\n  }\n\n  return generateEd25519KeyPairFromSeed(seed)\n}\n\n/**\n * Converts a protobuf serialized public key into its representative object.\n *\n * For RSA public keys optionally pass the multihash digest of the public key if\n * it is known. If the digest is omitted it will be calculated which can be\n * expensive.\n *\n * For other key types the digest option is ignored.\n */\nexport function publicKeyFromProtobuf (buf: Uint8Array, digest?: Digest<18, number>): PublicKey {\n  const { Type, Data } = pb.PublicKey.decode(buf)\n  const data = Data ?? new Uint8Array()\n\n  switch (Type) {\n    case pb.KeyType.RSA:\n      return pkixToRSAPublicKey(data, digest)\n    case pb.KeyType.Ed25519:\n      return unmarshalEd25519PublicKey(data)\n    case pb.KeyType.secp256k1:\n      return unmarshalSecp256k1PublicKey(data)\n    case pb.KeyType.ECDSA:\n      return unmarshalECDSAPublicKey(data)\n    default:\n      throw new UnsupportedKeyTypeError()\n  }\n}\n\n/**\n * Creates a public key from the raw key bytes\n */\nexport function publicKeyFromRaw (buf: Uint8Array): PublicKey {\n  if (buf.byteLength === ed25519PublicKeyLength) {\n    return unmarshalEd25519PublicKey(buf)\n  } else if (buf.byteLength === secp256k1PublicKeyLength) {\n    return unmarshalSecp256k1PublicKey(buf)\n  }\n\n  const message = decodeDer(buf)\n  const ecdsaOid = message[1]?.[0]\n\n  if (ecdsaOid === ECDSA_P_256_OID || ecdsaOid === ECDSA_P_384_OID || ecdsaOid === ECDSA_P_521_OID) {\n    return pkiMessageToECDSAPublicKey(message)\n  }\n\n  if (message[0]?.[0] === RSAES_PKCS1_V1_5_OID) {\n    return pkixMessageToRSAPublicKey(message, buf)\n  }\n\n  throw new InvalidParametersError('Could not extract public key from raw bytes')\n}\n\n/**\n * Creates a public key from an identity multihash which contains a protobuf\n * encoded Ed25519 or secp256k1 public key.\n *\n * RSA keys are not supported as in practice we they are not stored in identity\n * multihash since the hash would be very large.\n */\nexport function publicKeyFromMultihash (digest: MultihashDigest<0x0>): Ed25519PublicKey | Secp256k1PublicKey | ECDSAPublicKey {\n  const { Type, Data } = pb.PublicKey.decode(digest.digest)\n  const data = Data ?? new Uint8Array()\n\n  switch (Type) {\n    case pb.KeyType.Ed25519:\n      return unmarshalEd25519PublicKey(data)\n    case pb.KeyType.secp256k1:\n      return unmarshalSecp256k1PublicKey(data)\n    case pb.KeyType.ECDSA:\n      return unmarshalECDSAPublicKey(data)\n    default:\n      throw new UnsupportedKeyTypeError()\n  }\n}\n\n/**\n * Converts a public key object into a protobuf serialized public key\n */\nexport function publicKeyToProtobuf (key: PublicKey): Uint8Array {\n  return pb.PublicKey.encode({\n    Type: pb.KeyType[key.type],\n    Data: key.raw\n  })\n}\n\n/**\n * Converts a protobuf serialized private key into its representative object\n */\nexport function privateKeyFromProtobuf (buf: Uint8Array): Ed25519PrivateKey | Secp256k1PrivateKey | RSAPrivateKey | ECDSAPrivateKey {\n  const decoded = pb.PrivateKey.decode(buf)\n  const data = decoded.Data ?? new Uint8Array()\n\n  switch (decoded.Type) {\n    case pb.KeyType.RSA:\n      return pkcs1ToRSAPrivateKey(data)\n    case pb.KeyType.Ed25519:\n      return unmarshalEd25519PrivateKey(data)\n    case pb.KeyType.secp256k1:\n      return unmarshalSecp256k1PrivateKey(data)\n    case pb.KeyType.ECDSA:\n      return unmarshalECDSAPrivateKey(data)\n    default:\n      throw new UnsupportedKeyTypeError()\n  }\n}\n\n/**\n * Creates a private key from the raw key bytes. For Ed25519 keys this requires\n * the public key to be appended to the private key otherwise we can't\n * differentiate between Ed25519 and secp256k1 keys as they are the same length.\n */\nexport function privateKeyFromRaw (buf: Uint8Array): PrivateKey {\n  if (buf.byteLength === ed25519PrivateKeyLength) {\n    return unmarshalEd25519PrivateKey(buf)\n  } else if (buf.byteLength === secp256k1PrivateKeyLength) {\n    return unmarshalSecp256k1PrivateKey(buf)\n  }\n\n  const message = decodeDer(buf)\n  const ecdsaOid = message[2]?.[0]\n\n  if (ecdsaOid === ECDSA_P_256_OID || ecdsaOid === ECDSA_P_384_OID || ecdsaOid === ECDSA_P_521_OID) {\n    return pkiMessageToECDSAPrivateKey(message)\n  }\n\n  if (message.length > 8) {\n    return pkcs1MessageToRSAPrivateKey(message)\n  }\n\n  throw new InvalidParametersError('Could not extract private key from raw bytes')\n}\n\n/**\n * Converts a private key object into a protobuf serialized private key\n */\nexport function privateKeyToProtobuf (key: PrivateKey): Uint8Array {\n  return pb.PrivateKey.encode({\n    Type: pb.KeyType[key.type],\n    Data: key.raw\n  })\n}\n\nfunction toBits (bits: any): number {\n  if (bits == null) {\n    return 2048\n  }\n\n  return parseInt(bits, 10)\n}\n\nfunction toCurve (curve: any): Curve {\n  if (curve === 'P-256' || curve == null) {\n    return 'P-256'\n  }\n\n  if (curve === 'P-384') {\n    return 'P-384'\n  }\n\n  if (curve === 'P-521') {\n    return 'P-521'\n  }\n\n  throw new InvalidParametersError('Unsupported curve, should be P-256, P-384 or P-521')\n}\n\n/**\n * Convert a libp2p RSA or ECDSA private key to a WebCrypto CryptoKeyPair\n */\nexport async function privateKeyToCryptoKeyPair (privateKey: PrivateKey): Promise<CryptoKeyPair> {\n  if (privateKey.type === 'RSA') {\n    return {\n      privateKey: await crypto.subtle.importKey('jwk', privateKey.jwk, {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: { name: 'SHA-256' }\n      }, true, ['sign']),\n      publicKey: await crypto.subtle.importKey('jwk', privateKey.publicKey.jwk, {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: { name: 'SHA-256' }\n      }, true, ['verify'])\n    }\n  }\n\n  if (privateKey.type === 'ECDSA') {\n    return {\n      privateKey: await crypto.subtle.importKey('jwk', privateKey.jwk, {\n        name: 'ECDSA',\n        namedCurve: privateKey.jwk.crv ?? 'P-256'\n      }, true, ['sign']),\n      publicKey: await crypto.subtle.importKey('jwk', privateKey.publicKey.jwk, {\n        name: 'ECDSA',\n        namedCurve: privateKey.publicKey.jwk.crv ?? 'P-256'\n      }, true, ['verify'])\n    }\n  }\n\n  throw new InvalidParametersError('Only RSA and ECDSA keys are supported')\n}\n\n/**\n * Convert a RSA or ECDSA WebCrypto CryptoKeyPair to a libp2p private key\n */\nexport async function privateKeyFromCryptoKeyPair (keyPair: CryptoKeyPair): Promise<PrivateKey> {\n  if (keyPair.privateKey.algorithm.name === 'RSASSA-PKCS1-v1_5') {\n    const jwk = await crypto.subtle.exportKey('jwk', keyPair.privateKey)\n\n    return jwkToRSAPrivateKey(jwk)\n  }\n\n  if (keyPair.privateKey.algorithm.name === 'ECDSA') {\n    const jwk = await crypto.subtle.exportKey('jwk', keyPair.privateKey)\n\n    return new ECDSAPrivateKeyClass(jwk)\n  }\n\n  throw new InvalidParametersError('Only RSA and ECDSA keys are supported')\n}\n", "/**\n * @packageDocumentation\n *\n * An implementation of a peer id\n *\n * @example\n *\n * ```TypeScript\n * import { peerIdFromString } from '@libp2p/peer-id'\n * const peer = peerIdFromString('k51qzi5uqu5dkwkqm42v9j9kqcam2jiuvloi16g72i4i4amoo2m8u3ol3mqu6s')\n *\n * console.log(peer.toCID()) // CID(bafzaa...)\n * console.log(peer.toString()) // \"12D3K...\"\n * ```\n */\n\nimport { peerIdSymbol } from '@libp2p/interface'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { identity } from 'multiformats/hashes/identity'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport type { Ed25519PeerId as Ed25519PeerIdInterface, PeerIdType, RSAPeerId as RSAPeerIdInterface, URLPeerId as URLPeerIdInterface, Secp256k1PeerId as Secp256k1PeerIdInterface, PeerId, PublicKey, Ed25519PublicKey, Secp256k1PublicKey, RSAPublicKey } from '@libp2p/interface'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\n\nconst inspect = Symbol.for('nodejs.util.inspect.custom')\n\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72\n\ninterface PeerIdInit <DigestCode extends number> {\n  type: PeerIdType\n  multihash: MultihashDigest<DigestCode>\n}\n\ninterface RSAPeerIdInit {\n  multihash: MultihashDigest<0x12>\n  publicKey?: RSAPublicKey\n}\n\ninterface Ed25519PeerIdInit {\n  multihash: MultihashDigest<0x0>\n  publicKey: Ed25519PublicKey\n}\n\ninterface Secp256k1PeerIdInit {\n  multihash: MultihashDigest<0x0>\n  publicKey: Secp256k1PublicKey\n}\n\nclass PeerIdImpl <DigestCode extends number> {\n  public type: PeerIdType\n  private readonly multihash: MultihashDigest<DigestCode>\n  public readonly publicKey?: PublicKey\n  private string?: string\n\n  constructor (init: PeerIdInit<DigestCode>) {\n    this.type = init.type\n    this.multihash = init.multihash\n\n    // mark string cache as non-enumerable\n    Object.defineProperty(this, 'string', {\n      enumerable: false,\n      writable: true\n    })\n  }\n\n  get [Symbol.toStringTag] (): string {\n    return `PeerId(${this.toString()})`\n  }\n\n  readonly [peerIdSymbol] = true\n\n  toString (): string {\n    if (this.string == null) {\n      this.string = base58btc.encode(this.multihash.bytes).slice(1)\n    }\n\n    return this.string\n  }\n\n  toMultihash (): MultihashDigest<DigestCode> {\n    return this.multihash\n  }\n\n  // return self-describing String representation\n  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n  toCID (): CID<Uint8Array, 0x72, DigestCode, 1> {\n    return CID.createV1(LIBP2P_KEY_CODE, this.multihash)\n  }\n\n  toJSON (): string {\n    return this.toString()\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given PeerId\n   */\n  equals (id?: PeerId | Uint8Array | string): boolean {\n    if (id == null) {\n      return false\n    }\n\n    if (id instanceof Uint8Array) {\n      return uint8ArrayEquals(this.multihash.bytes, id)\n    } else if (typeof id === 'string') {\n      return this.toString() === id\n    } else if (id?.toMultihash()?.bytes != null) {\n      return uint8ArrayEquals(this.multihash.bytes, id.toMultihash().bytes)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /**\n   * Returns PeerId as a human-readable string\n   * https://nodejs.org/api/util.html#utilinspectcustom\n   *\n   * @example\n   * ```TypeScript\n   * import { peerIdFromString } from '@libp2p/peer-id'\n   *\n   * console.info(peerIdFromString('QmFoo'))\n   * // 'PeerId(QmFoo)'\n   * ```\n   */\n  [inspect] (): string {\n    return `PeerId(${this.toString()})`\n  }\n}\n\nexport class RSAPeerId extends PeerIdImpl<0x12> implements RSAPeerIdInterface {\n  public readonly type = 'RSA'\n  public readonly publicKey?: RSAPublicKey\n\n  constructor (init: RSAPeerIdInit) {\n    super({ ...init, type: 'RSA' })\n\n    this.publicKey = init.publicKey\n  }\n}\n\nexport class Ed25519PeerId extends PeerIdImpl<0x0> implements Ed25519PeerIdInterface {\n  public readonly type = 'Ed25519'\n  public readonly publicKey: Ed25519PublicKey\n\n  constructor (init: Ed25519PeerIdInit) {\n    super({ ...init, type: 'Ed25519' })\n\n    this.publicKey = init.publicKey\n  }\n}\n\nexport class Secp256k1PeerId extends PeerIdImpl<0x0> implements Secp256k1PeerIdInterface {\n  public readonly type = 'secp256k1'\n  public readonly publicKey: Secp256k1PublicKey\n\n  constructor (init: Secp256k1PeerIdInit) {\n    super({ ...init, type: 'secp256k1' })\n\n    this.publicKey = init.publicKey\n  }\n}\n\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst TRANSPORT_IPFS_GATEWAY_HTTP_CODE = 0x0920\n\nexport class URLPeerId implements URLPeerIdInterface {\n  readonly type = 'url'\n  readonly multihash: MultihashDigest<0x0>\n  readonly publicKey: undefined\n  readonly url: string\n\n  constructor (url: URL) {\n    this.url = url.toString()\n    this.multihash = identity.digest(uint8ArrayFromString(this.url))\n  }\n\n  [inspect] (): string {\n    return `PeerId(${this.url})`\n  }\n\n  readonly [peerIdSymbol] = true\n\n  toString (): string {\n    return this.toCID().toString()\n  }\n\n  toMultihash (): MultihashDigest<0x0> {\n    return this.multihash\n  }\n\n  toCID (): CID<Uint8Array, 0x0920, 0x0, 1> {\n    return CID.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE, this.toMultihash())\n  }\n\n  toJSON (): string {\n    return this.toString()\n  }\n\n  equals (other?: PeerId | Uint8Array | string): boolean {\n    if (other == null) {\n      return false\n    }\n\n    if (other instanceof Uint8Array) {\n      other = uint8ArrayToString(other)\n    }\n\n    return other.toString() === this.toString()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * An implementation of a peer id\n *\n * @example\n *\n * ```TypeScript\n * import { peerIdFromString } from '@libp2p/peer-id'\n * const peer = peerIdFromString('12D3KooWKnDdG3iXw9eTFijk3EWSunZcFi54Zka4wmtqtt6rPxc8')\n *\n * console.log(peer.toCID()) // CID(bafzaa...)\n * console.log(peer.toString()) // \"12D3K...\"\n * ```\n */\n\nimport { publicKeyFromMultihash } from '@libp2p/crypto/keys'\nimport { InvalidCIDError, InvalidMultihashError, InvalidParametersError, UnsupportedKeyTypeError } from '@libp2p/interface'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { CID, type MultibaseDecoder } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { identity } from 'multiformats/hashes/identity'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { RSAPeerId as RSAPeerIdClass, Ed25519PeerId as Ed25519PeerIdClass, Secp256k1PeerId as Secp256k1PeerIdClass, URLPeerId as URLPeerIdClass } from './peer-id.js'\nimport type { Ed25519PeerId, RSAPeerId, URLPeerId, Secp256k1PeerId, PeerId, PublicKey, Ed25519PublicKey, Secp256k1PublicKey, RSAPublicKey, Ed25519PrivateKey, Secp256k1PrivateKey, RSAPrivateKey, PrivateKey } from '@libp2p/interface'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\n\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72\nconst TRANSPORT_IPFS_GATEWAY_HTTP_CODE = 0x0920\n\nexport function peerIdFromString (str: string, decoder?: MultibaseDecoder<any>): Ed25519PeerId | Secp256k1PeerId | RSAPeerId | URLPeerId {\n  let multihash: MultihashDigest\n\n  if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n    // identity hash ed25519/secp256k1 key or sha2-256 hash of\n    // rsa public key - base58btc encoded either way\n    multihash = Digest.decode(base58btc.decode(`z${str}`))\n  } else if (str.startsWith('k51qzi5uqu5') || str.startsWith('kzwfwjn5ji4') || str.startsWith('k2k4r8') || str.startsWith('bafz')) {\n    // base36 encoded CIDv1 with libp2p-key and identity hash (for ed25519/secp256k1/rsa) or base32 encoded CIDv1 with libp2p-key and identity hash (for ed25519/secp256k1/rsa)\n    return peerIdFromCID(CID.parse(str))\n  } else {\n    if (decoder == null) {\n      throw new InvalidParametersError('Please pass a multibase decoder for strings that do not start with \"1\" or \"Q\"')\n    }\n\n    multihash = Digest.decode(decoder.decode(str))\n  }\n\n  return peerIdFromMultihash(multihash)\n}\n\nexport function peerIdFromPublicKey (publicKey: Ed25519PublicKey): Ed25519PeerId\nexport function peerIdFromPublicKey (publicKey: Secp256k1PublicKey): Secp256k1PeerId\nexport function peerIdFromPublicKey (publicKey: RSAPublicKey): RSAPeerId\nexport function peerIdFromPublicKey (publicKey: PublicKey): PeerId\nexport function peerIdFromPublicKey (publicKey: PublicKey): PeerId {\n  if (publicKey.type === 'Ed25519') {\n    return new Ed25519PeerIdClass({\n      multihash: publicKey.toCID().multihash,\n      publicKey\n    })\n  } else if (publicKey.type === 'secp256k1') {\n    return new Secp256k1PeerIdClass({\n      multihash: publicKey.toCID().multihash,\n      publicKey\n    })\n  } else if (publicKey.type === 'RSA') {\n    return new RSAPeerIdClass({\n      multihash: publicKey.toCID().multihash,\n      publicKey\n    })\n  }\n\n  throw new UnsupportedKeyTypeError()\n}\n\nexport function peerIdFromPrivateKey (privateKey: Ed25519PrivateKey): Ed25519PeerId\nexport function peerIdFromPrivateKey (privateKey: Secp256k1PrivateKey): Secp256k1PeerId\nexport function peerIdFromPrivateKey (privateKey: RSAPrivateKey): RSAPeerId\nexport function peerIdFromPrivateKey (privateKey: PrivateKey): PeerId\nexport function peerIdFromPrivateKey (privateKey: PrivateKey): PeerId {\n  return peerIdFromPublicKey(privateKey.publicKey)\n}\n\nexport function peerIdFromMultihash (multihash: MultihashDigest): PeerId {\n  if (isSha256Multihash(multihash)) {\n    return new RSAPeerIdClass({ multihash })\n  } else if (isIdentityMultihash(multihash)) {\n    try {\n      const publicKey = publicKeyFromMultihash(multihash)\n\n      if (publicKey.type === 'Ed25519') {\n        return new Ed25519PeerIdClass({ multihash, publicKey })\n      } else if (publicKey.type === 'secp256k1') {\n        return new Secp256k1PeerIdClass({ multihash, publicKey })\n      }\n    } catch (err) {\n      // was not Ed or secp key, try URL\n      const url = uint8ArrayToString(multihash.digest)\n\n      return new URLPeerIdClass(new URL(url))\n    }\n  }\n\n  throw new InvalidMultihashError('Supplied PeerID Multihash is invalid')\n}\n\nexport function peerIdFromCID (cid: CID): Ed25519PeerId | Secp256k1PeerId | RSAPeerId | URLPeerId {\n  if (cid?.multihash == null || cid.version == null || (cid.version === 1 && (cid.code !== LIBP2P_KEY_CODE) && cid.code !== TRANSPORT_IPFS_GATEWAY_HTTP_CODE)) {\n    throw new InvalidCIDError('Supplied PeerID CID is invalid')\n  }\n\n  if (cid.code === TRANSPORT_IPFS_GATEWAY_HTTP_CODE) {\n    const url = uint8ArrayToString(cid.multihash.digest)\n\n    return new URLPeerIdClass(new URL(url))\n  }\n\n  return peerIdFromMultihash(cid.multihash)\n}\n\nfunction isIdentityMultihash (multihash: MultihashDigest): multihash is MultihashDigest<0x0> {\n  return multihash.code === identity.code\n}\n\nfunction isSha256Multihash (multihash: MultihashDigest): multihash is MultihashDigest<0x12> {\n  return multihash.code === sha256.code\n}\n"],
  "mappings": "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",
  "names": ["TopicValidatorResult", "FaultTolerance", "message", "message", "message", "byte", "message", "hashAndVerify", "hashAndVerify", "KeyType", "__KeyTypeValues", "PublicKey", "PrivateKey", "message", "hashAndVerify", "hashAndVerify", "_a", "LIBP2P_KEY_CODE", "TRANSPORT_IPFS_GATEWAY_HTTP_CODE"]
}
