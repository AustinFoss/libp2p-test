import {
  pDefer,
  raceSignal
} from "./chunk-2B23ONA5.js";
import {
  __publicField
} from "./chunk-WOOG5QLI.js";

// node_modules/.pnpm/it-queueless-pushable@2.0.0/node_modules/it-queueless-pushable/dist/src/index.js
var QueuelessPushable = class {
  constructor() {
    __publicField(this, "readNext");
    __publicField(this, "haveNext");
    __publicField(this, "ended");
    __publicField(this, "nextResult");
    __publicField(this, "error");
    this.ended = false;
    this.readNext = pDefer();
    this.haveNext = pDefer();
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async next() {
    if (this.nextResult == null) {
      await this.haveNext.promise;
    }
    if (this.nextResult == null) {
      throw new Error("HaveNext promise resolved but nextResult was undefined");
    }
    const nextResult = this.nextResult;
    this.nextResult = void 0;
    this.readNext.resolve();
    this.readNext = pDefer();
    return nextResult;
  }
  async throw(err) {
    this.ended = true;
    this.error = err;
    if (err != null) {
      this.haveNext.promise.catch(() => {
      });
      this.haveNext.reject(err);
    }
    const result = {
      done: true,
      value: void 0
    };
    return result;
  }
  async return() {
    const result = {
      done: true,
      value: void 0
    };
    this.ended = true;
    this.nextResult = result;
    this.haveNext.resolve();
    return result;
  }
  async push(value, options) {
    await this._push(value, options);
  }
  async end(err, options) {
    if (err != null) {
      await this.throw(err);
    } else {
      await this._push(void 0, options);
    }
  }
  async _push(value, options) {
    if (value != null && this.ended) {
      throw this.error ?? new Error("Cannot push value onto an ended pushable");
    }
    while (this.nextResult != null) {
      await this.readNext.promise;
    }
    if (value != null) {
      this.nextResult = { done: false, value };
    } else {
      this.ended = true;
      this.nextResult = { done: true, value: void 0 };
    }
    this.haveNext.resolve();
    this.haveNext = pDefer();
    await raceSignal(this.readNext.promise, options == null ? void 0 : options.signal, options);
  }
};
function queuelessPushable() {
  return new QueuelessPushable();
}

export {
  queuelessPushable
};
//# sourceMappingURL=chunk-VLAMNGZA.js.map
