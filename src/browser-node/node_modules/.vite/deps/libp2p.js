import {
  parallel,
  require_netmask,
  src_default as src_default2
} from "./chunk-HOEANHLM.js";
import "./chunk-E7S26PXL.js";
import {
  src_default as src_default3
} from "./chunk-Q27E4NOL.js";
import {
  Key,
  TimeoutError as TimeoutError2,
  anySignal,
  pTimeout,
  raceEvent
} from "./chunk-7YWPJXSN.js";
import {
  CustomProgressEvent
} from "./chunk-KFVCPFUY.js";
import {
  byteStream,
  encode as encode2,
  generateKeyPair,
  lpStream,
  peerIdFromCID,
  peerIdFromMultihash,
  peerIdFromPrivateKey,
  peerIdFromPublicKey,
  peerIdFromString,
  publicKeyFromProtobuf,
  publicKeyToProtobuf,
  randomBytes,
  src_default
} from "./chunk-7ASOWDSD.js";
import {
  Circuit,
  IP4,
  IP6,
  QUICV1,
  TCP,
  WebRTC,
  WebRTCDirect,
  WebSockets,
  WebSocketsSecure,
  WebTransport
} from "./chunk-I64M3XGK.js";
import {
  MaxLengthError,
  MaxSizeError,
  decodeMessage,
  encodeMessage,
  message
} from "./chunk-GN2SHL2J.js";
import {
  AbortError,
  ConnectionClosedError,
  ConnectionClosingError,
  DialError,
  FaultTolerance,
  InvalidMessageError,
  InvalidMultiaddrError,
  InvalidParametersError,
  InvalidPeerIdError,
  KEEP_ALIVE,
  LimitedConnectionError,
  NotFoundError,
  NotStartedError,
  TimeoutError,
  TooManyInboundProtocolStreamsError,
  TooManyOutboundProtocolStreamsError,
  TypedEventEmitter,
  UnsupportedProtocolError,
  connectionSymbol,
  contentRoutingSymbol,
  isPeerId,
  isStartable,
  peerDiscoverySymbol,
  peerRoutingSymbol,
  pushable,
  serviceCapabilities,
  serviceDependencies,
  setMaxListeners,
  start,
  stop
} from "./chunk-3DZGSS4M.js";
import {
  Uint8ArrayList,
  pDefer,
  raceSignal
} from "./chunk-FILK5HTN.js";
import {
  convertToIpNet,
  getProtocol,
  isIPv4,
  isIPv6,
  isMultiaddr,
  multiaddr,
  resolvers
} from "./chunk-TTE2WQMB.js";
import {
  CID,
  base32,
  base58btc,
  base64,
  decode,
  encode,
  fromString,
  toString
} from "./chunk-EZM3SP6L.js";
import {
  alloc,
  concat,
  equals
} from "./chunk-PM7HCL6E.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField,
  __toESM
} from "./chunk-WOOG5QLI.js";

// node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events2, name2;
      if (this._eventsCount === 0) return names;
      for (name2 in events2 = this._events) {
        if (has.call(events2, name2)) names.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events2));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events2 = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events2.push(listeners[i]);
          }
        }
        if (events2.length) this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/.pnpm/hashlru@2.3.0/node_modules/hashlru/index.js
var require_hashlru = __commonJS({
  "node_modules/.pnpm/hashlru@2.3.0/node_modules/hashlru/index.js"(exports, module) {
    module.exports = function(max) {
      if (!max) throw Error("hashlru must have a max value, of type number, greater than 0");
      var size = 0, cache2 = /* @__PURE__ */ Object.create(null), _cache = /* @__PURE__ */ Object.create(null);
      function update(key, value) {
        cache2[key] = value;
        size++;
        if (size >= max) {
          size = 0;
          _cache = cache2;
          cache2 = /* @__PURE__ */ Object.create(null);
        }
      }
      return {
        has: function(key) {
          return cache2[key] !== void 0 || _cache[key] !== void 0;
        },
        remove: function(key) {
          if (cache2[key] !== void 0)
            cache2[key] = void 0;
          if (_cache[key] !== void 0)
            _cache[key] = void 0;
        },
        get: function(key) {
          var v = cache2[key];
          if (v !== void 0) return v;
          if ((v = _cache[key]) !== void 0) {
            update(key, v);
            return v;
          }
        },
        set: function(key, value) {
          if (cache2[key] !== void 0) cache2[key] = value;
          else update(key, value);
        },
        clear: function() {
          cache2 = /* @__PURE__ */ Object.create(null);
          _cache = /* @__PURE__ */ Object.create(null);
        }
      };
    };
  }
});

// node_modules/.pnpm/is-plain-obj@2.1.0/node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "node_modules/.pnpm/is-plain-obj@2.1.0/node_modules/is-plain-obj/index.js"(exports, module) {
    "use strict";
    module.exports = (value) => {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.prototype;
    };
  }
});

// node_modules/.pnpm/merge-options@3.0.4/node_modules/merge-options/index.js
var require_merge_options = __commonJS({
  "node_modules/.pnpm/merge-options@3.0.4/node_modules/merge-options/index.js"(exports, module) {
    "use strict";
    var isOptionObject = require_is_plain_obj();
    var { hasOwnProperty } = Object.prototype;
    var { propertyIsEnumerable } = Object;
    var defineProperty = (object, name2, value) => Object.defineProperty(object, name2, {
      value,
      writable: true,
      enumerable: true,
      configurable: true
    });
    var globalThis2 = exports;
    var defaultMergeOptions = {
      concatArrays: false,
      ignoreUndefined: false
    };
    var getEnumerableOwnPropertyKeys = (value) => {
      const keys = [];
      for (const key in value) {
        if (hasOwnProperty.call(value, key)) {
          keys.push(key);
        }
      }
      if (Object.getOwnPropertySymbols) {
        const symbols = Object.getOwnPropertySymbols(value);
        for (const symbol of symbols) {
          if (propertyIsEnumerable.call(value, symbol)) {
            keys.push(symbol);
          }
        }
      }
      return keys;
    };
    function clone(value) {
      if (Array.isArray(value)) {
        return cloneArray(value);
      }
      if (isOptionObject(value)) {
        return cloneOptionObject(value);
      }
      return value;
    }
    function cloneArray(array) {
      const result = array.slice(0, 0);
      getEnumerableOwnPropertyKeys(array).forEach((key) => {
        defineProperty(result, key, clone(array[key]));
      });
      return result;
    }
    function cloneOptionObject(object) {
      const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
      getEnumerableOwnPropertyKeys(object).forEach((key) => {
        defineProperty(result, key, clone(object[key]));
      });
      return result;
    }
    var mergeKeys = (merged, source, keys, config) => {
      keys.forEach((key) => {
        if (typeof source[key] === "undefined" && config.ignoreUndefined) {
          return;
        }
        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
          defineProperty(merged, key, merge(merged[key], source[key], config));
        } else {
          defineProperty(merged, key, clone(source[key]));
        }
      });
      return merged;
    };
    var concatArrays = (merged, source, config) => {
      let result = merged.slice(0, 0);
      let resultIndex = 0;
      [merged, source].forEach((array) => {
        const indices = [];
        for (let k = 0; k < array.length; k++) {
          if (!hasOwnProperty.call(array, k)) {
            continue;
          }
          indices.push(String(k));
          if (array === merged) {
            defineProperty(result, resultIndex++, array[k]);
          } else {
            defineProperty(result, resultIndex++, clone(array[k]));
          }
        }
        result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config);
      });
      return result;
    };
    function merge(merged, source, config) {
      if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
        return concatArrays(merged, source, config);
      }
      if (!isOptionObject(source) || !isOptionObject(merged)) {
        return clone(source);
      }
      return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
    }
    module.exports = function(...options) {
      const config = merge(clone(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
      let merged = { _: {} };
      for (const option of options) {
        if (option === void 0) {
          continue;
        }
        if (!isOptionObject(option)) {
          throw new TypeError("`" + option + "` is not an Option Object");
        }
        merged = merge(merged, { _: option }, config);
      }
      return merged._;
    };
  }
});

// node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js"(exports, module) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self = this;
      this._timer = setTimeout(function() {
        self._attempts++;
        if (self._operationTimeoutCb) {
          self._timeout = setTimeout(function() {
            self._operationTimeoutCb(self._attempts);
          }, self._operationTimeout);
          if (self._options.unref) {
            self._timeout.unref();
          }
        }
        self._fn(self._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self._operationTimeoutCb();
        }, self._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message2 = error.message;
        var count = (counts[message2] || 0) + 1;
        counts[message2] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js"(exports) {
    var RetryOperation = require_retry_operation();
    exports.operation = function(options) {
      var timeouts = exports.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = (function retryWrapper(original2) {
          var op = exports.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }).bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js"(exports, module) {
    module.exports = require_retry();
  }
});

// node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);

// node_modules/.pnpm/p-queue@8.1.0/node_modules/p-queue/dist/lower-bound.js
function lowerBound(array, value, comparator) {
  let first = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first + step;
    if (comparator(array[it], value) <= 0) {
      first = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first;
}

// node_modules/.pnpm/p-queue@8.1.0/node_modules/p-queue/dist/priority-queue.js
var _queue;
var PriorityQueue = class {
  constructor() {
    __privateAdd(this, _queue, []);
  }
  enqueue(run, options) {
    options = {
      priority: 0,
      ...options
    };
    const element = {
      priority: options.priority,
      id: options.id,
      run
    };
    if (this.size === 0 || __privateGet(this, _queue)[this.size - 1].priority >= options.priority) {
      __privateGet(this, _queue).push(element);
      return;
    }
    const index = lowerBound(__privateGet(this, _queue), element, (a, b) => b.priority - a.priority);
    __privateGet(this, _queue).splice(index, 0, element);
  }
  setPriority(id, priority) {
    const index = __privateGet(this, _queue).findIndex((element) => element.id === id);
    if (index === -1) {
      throw new ReferenceError(`No promise function with the id "${id}" exists in the queue.`);
    }
    const [item] = __privateGet(this, _queue).splice(index, 1);
    this.enqueue(item.run, { priority, id });
  }
  dequeue() {
    const item = __privateGet(this, _queue).shift();
    return item == null ? void 0 : item.run;
  }
  filter(options) {
    return __privateGet(this, _queue).filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return __privateGet(this, _queue).length;
  }
};
_queue = new WeakMap();

// node_modules/.pnpm/p-queue@8.1.0/node_modules/p-queue/dist/index.js
var _carryoverConcurrencyCount, _isIntervalIgnored, _intervalCount, _intervalCap, _interval, _intervalEnd, _intervalId, _timeoutId, _queue2, _queueClass, _pending, _concurrency, _isPaused, _throwOnTimeout, _idAssigner, _PQueue_instances, doesIntervalAllowAnother_get, doesConcurrentAllowAnother_get, next_fn, onResumeInterval_fn, isIntervalPaused_get, tryToStartAnother_fn, initializeIntervalIfNeeded_fn, onInterval_fn, processQueue_fn, throwOnAbort_fn, onEvent_fn;
var PQueue = class extends import_index.default {
  // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
  constructor(options) {
    var _a12, _b4;
    super();
    __privateAdd(this, _PQueue_instances);
    __privateAdd(this, _carryoverConcurrencyCount);
    __privateAdd(this, _isIntervalIgnored);
    __privateAdd(this, _intervalCount, 0);
    __privateAdd(this, _intervalCap);
    __privateAdd(this, _interval);
    __privateAdd(this, _intervalEnd, 0);
    __privateAdd(this, _intervalId);
    __privateAdd(this, _timeoutId);
    __privateAdd(this, _queue2);
    __privateAdd(this, _queueClass);
    __privateAdd(this, _pending, 0);
    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
    __privateAdd(this, _concurrency);
    __privateAdd(this, _isPaused);
    __privateAdd(this, _throwOnTimeout);
    // Use to assign a unique identifier to a promise function, if not explicitly specified
    __privateAdd(this, _idAssigner, 1n);
    /**
        Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.
    
        Applies to each future operation.
        */
    __publicField(this, "timeout");
    options = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: PriorityQueue,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${((_a12 = options.intervalCap) == null ? void 0 : _a12.toString()) ?? ""}\` (${typeof options.intervalCap})`);
    }
    if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${((_b4 = options.interval) == null ? void 0 : _b4.toString()) ?? ""}\` (${typeof options.interval})`);
    }
    __privateSet(this, _carryoverConcurrencyCount, options.carryoverConcurrencyCount);
    __privateSet(this, _isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0);
    __privateSet(this, _intervalCap, options.intervalCap);
    __privateSet(this, _interval, options.interval);
    __privateSet(this, _queue2, new options.queueClass());
    __privateSet(this, _queueClass, options.queueClass);
    this.concurrency = options.concurrency;
    this.timeout = options.timeout;
    __privateSet(this, _throwOnTimeout, options.throwOnTimeout === true);
    __privateSet(this, _isPaused, options.autoStart === false);
  }
  get concurrency() {
    return __privateGet(this, _concurrency);
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    __privateSet(this, _concurrency, newConcurrency);
    __privateMethod(this, _PQueue_instances, processQueue_fn).call(this);
  }
  /**
      Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.
  
      For example, this can be used to prioritize a promise function to run earlier.
  
      ```js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 1});
  
      queue.add(async () => 'ðŸ¦„', {priority: 1});
      queue.add(async () => 'ðŸ¦€', {priority: 0, id: 'ðŸ¦€'});
      queue.add(async () => 'ðŸ¦„', {priority: 1});
      queue.add(async () => 'ðŸ¦„', {priority: 1});
  
      queue.setPriority('ðŸ¦€', 2);
      ```
  
      In this case, the promise function with `id: 'ðŸ¦€'` runs second.
  
      You can also deprioritize a promise function to delay its execution:
  
      ```js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 1});
  
      queue.add(async () => 'ðŸ¦„', {priority: 1});
      queue.add(async () => 'ðŸ¦€', {priority: 1, id: 'ðŸ¦€'});
      queue.add(async () => 'ðŸ¦„');
      queue.add(async () => 'ðŸ¦„', {priority: 0});
  
      queue.setPriority('ðŸ¦€', -1);
      ```
      Here, the promise function with `id: 'ðŸ¦€'` executes last.
      */
  setPriority(id, priority) {
    __privateGet(this, _queue2).setPriority(id, priority);
  }
  async add(function_, options = {}) {
    options.id ?? (options.id = (__privateWrapper(this, _idAssigner)._++).toString());
    options = {
      timeout: this.timeout,
      throwOnTimeout: __privateGet(this, _throwOnTimeout),
      ...options
    };
    return new Promise((resolve, reject) => {
      __privateGet(this, _queue2).enqueue(async () => {
        var _a12;
        __privateWrapper(this, _pending)._++;
        __privateWrapper(this, _intervalCount)._++;
        try {
          (_a12 = options.signal) == null ? void 0 : _a12.throwIfAborted();
          let operation = function_({ signal: options.signal });
          if (options.timeout) {
            operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });
          }
          if (options.signal) {
            operation = Promise.race([operation, __privateMethod(this, _PQueue_instances, throwOnAbort_fn).call(this, options.signal)]);
          }
          const result = await operation;
          resolve(result);
          this.emit("completed", result);
        } catch (error) {
          if (error instanceof TimeoutError2 && !options.throwOnTimeout) {
            resolve();
            return;
          }
          reject(error);
          this.emit("error", error);
        } finally {
          __privateMethod(this, _PQueue_instances, next_fn).call(this);
        }
      }, options);
      this.emit("add");
      __privateMethod(this, _PQueue_instances, tryToStartAnother_fn).call(this);
    });
  }
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    if (!__privateGet(this, _isPaused)) {
      return this;
    }
    __privateSet(this, _isPaused, false);
    __privateMethod(this, _PQueue_instances, processQueue_fn).call(this);
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    __privateSet(this, _isPaused, true);
  }
  /**
  Clear the queue.
  */
  clear() {
    __privateSet(this, _queue2, new (__privateGet(this, _queueClass))());
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (__privateGet(this, _queue2).size === 0) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(limit) {
    if (__privateGet(this, _queue2).size < limit) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "next", () => __privateGet(this, _queue2).size < limit);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (__privateGet(this, _pending) === 0 && __privateGet(this, _queue2).size === 0) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "idle");
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return __privateGet(this, _queue2).size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options) {
    return __privateGet(this, _queue2).filter(options).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return __privateGet(this, _pending);
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return __privateGet(this, _isPaused);
  }
};
_carryoverConcurrencyCount = new WeakMap();
_isIntervalIgnored = new WeakMap();
_intervalCount = new WeakMap();
_intervalCap = new WeakMap();
_interval = new WeakMap();
_intervalEnd = new WeakMap();
_intervalId = new WeakMap();
_timeoutId = new WeakMap();
_queue2 = new WeakMap();
_queueClass = new WeakMap();
_pending = new WeakMap();
_concurrency = new WeakMap();
_isPaused = new WeakMap();
_throwOnTimeout = new WeakMap();
_idAssigner = new WeakMap();
_PQueue_instances = new WeakSet();
doesIntervalAllowAnother_get = function() {
  return __privateGet(this, _isIntervalIgnored) || __privateGet(this, _intervalCount) < __privateGet(this, _intervalCap);
};
doesConcurrentAllowAnother_get = function() {
  return __privateGet(this, _pending) < __privateGet(this, _concurrency);
};
next_fn = function() {
  __privateWrapper(this, _pending)._--;
  __privateMethod(this, _PQueue_instances, tryToStartAnother_fn).call(this);
  this.emit("next");
};
onResumeInterval_fn = function() {
  __privateMethod(this, _PQueue_instances, onInterval_fn).call(this);
  __privateMethod(this, _PQueue_instances, initializeIntervalIfNeeded_fn).call(this);
  __privateSet(this, _timeoutId, void 0);
};
isIntervalPaused_get = function() {
  const now = Date.now();
  if (__privateGet(this, _intervalId) === void 0) {
    const delay2 = __privateGet(this, _intervalEnd) - now;
    if (delay2 < 0) {
      __privateSet(this, _intervalCount, __privateGet(this, _carryoverConcurrencyCount) ? __privateGet(this, _pending) : 0);
    } else {
      if (__privateGet(this, _timeoutId) === void 0) {
        __privateSet(this, _timeoutId, setTimeout(() => {
          __privateMethod(this, _PQueue_instances, onResumeInterval_fn).call(this);
        }, delay2));
      }
      return true;
    }
  }
  return false;
};
tryToStartAnother_fn = function() {
  if (__privateGet(this, _queue2).size === 0) {
    if (__privateGet(this, _intervalId)) {
      clearInterval(__privateGet(this, _intervalId));
    }
    __privateSet(this, _intervalId, void 0);
    this.emit("empty");
    if (__privateGet(this, _pending) === 0) {
      this.emit("idle");
    }
    return false;
  }
  if (!__privateGet(this, _isPaused)) {
    const canInitializeInterval = !__privateGet(this, _PQueue_instances, isIntervalPaused_get);
    if (__privateGet(this, _PQueue_instances, doesIntervalAllowAnother_get) && __privateGet(this, _PQueue_instances, doesConcurrentAllowAnother_get)) {
      const job = __privateGet(this, _queue2).dequeue();
      if (!job) {
        return false;
      }
      this.emit("active");
      job();
      if (canInitializeInterval) {
        __privateMethod(this, _PQueue_instances, initializeIntervalIfNeeded_fn).call(this);
      }
      return true;
    }
  }
  return false;
};
initializeIntervalIfNeeded_fn = function() {
  if (__privateGet(this, _isIntervalIgnored) || __privateGet(this, _intervalId) !== void 0) {
    return;
  }
  __privateSet(this, _intervalId, setInterval(() => {
    __privateMethod(this, _PQueue_instances, onInterval_fn).call(this);
  }, __privateGet(this, _interval)));
  __privateSet(this, _intervalEnd, Date.now() + __privateGet(this, _interval));
};
onInterval_fn = function() {
  if (__privateGet(this, _intervalCount) === 0 && __privateGet(this, _pending) === 0 && __privateGet(this, _intervalId)) {
    clearInterval(__privateGet(this, _intervalId));
    __privateSet(this, _intervalId, void 0);
  }
  __privateSet(this, _intervalCount, __privateGet(this, _carryoverConcurrencyCount) ? __privateGet(this, _pending) : 0);
  __privateMethod(this, _PQueue_instances, processQueue_fn).call(this);
};
/**
Executes all queued functions until it reaches the limit.
*/
processQueue_fn = function() {
  while (__privateMethod(this, _PQueue_instances, tryToStartAnother_fn).call(this)) {
  }
};
throwOnAbort_fn = async function(signal) {
  return new Promise((_resolve, reject) => {
    signal.addEventListener("abort", () => {
      reject(signal.reason);
    }, { once: true });
  });
};
onEvent_fn = async function(event, filter2) {
  return new Promise((resolve) => {
    const listener = () => {
      if (filter2 && !filter2()) {
        return;
      }
      this.off(event, listener);
      resolve();
    };
    this.on(event, listener);
  });
};

// node_modules/.pnpm/@multiformats+dns@1.0.6/node_modules/@multiformats/dns/dist/src/utils/get-types.js
function getTypes(types) {
  const DEFAULT_TYPES = [
    RecordType.A
  ];
  if (types == null) {
    return DEFAULT_TYPES;
  }
  if (Array.isArray(types)) {
    if (types.length === 0) {
      return DEFAULT_TYPES;
    }
    return types;
  }
  return [
    types
  ];
}

// node_modules/.pnpm/@multiformats+dns@1.0.6/node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js
var DEFAULT_TTL = 60;
function toDNSResponse(obj) {
  return {
    Status: obj.Status ?? 0,
    TC: obj.TC ?? obj.flag_tc ?? false,
    RD: obj.RD ?? obj.flag_rd ?? false,
    RA: obj.RA ?? obj.flag_ra ?? false,
    AD: obj.AD ?? obj.flag_ad ?? false,
    CD: obj.CD ?? obj.flag_cd ?? false,
    Question: (obj.Question ?? obj.questions ?? []).map((question) => {
      return {
        name: question.name,
        type: RecordType[question.type]
      };
    }),
    Answer: (obj.Answer ?? obj.answers ?? []).map((answer) => {
      return {
        name: answer.name,
        type: RecordType[answer.type],
        TTL: answer.TTL ?? answer.ttl ?? DEFAULT_TTL,
        data: answer.data instanceof Uint8Array ? toString(answer.data) : answer.data
      };
    })
  };
}

// node_modules/.pnpm/@multiformats+dns@1.0.6/node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js
var DEFAULT_QUERY_CONCURRENCY = 4;
function dnsJsonOverHttps(url, init = {}) {
  const httpQueue = new PQueue({
    concurrency: init.queryConcurrency ?? DEFAULT_QUERY_CONCURRENCY
  });
  return async (fqdn, options = {}) => {
    var _a12;
    const searchParams = new URLSearchParams();
    searchParams.set("name", fqdn);
    getTypes(options.types).forEach((type) => {
      searchParams.append("type", RecordType[type]);
    });
    (_a12 = options.onProgress) == null ? void 0 : _a12.call(options, new CustomProgressEvent("dns:query", { detail: fqdn }));
    const response = await httpQueue.add(async () => {
      var _a13;
      const res = await fetch(`${url}?${searchParams}`, {
        headers: {
          accept: "application/dns-json"
        },
        signal: options == null ? void 0 : options.signal
      });
      if (res.status !== 200) {
        throw new Error(`Unexpected HTTP status: ${res.status} - ${res.statusText}`);
      }
      const response2 = toDNSResponse(await res.json());
      (_a13 = options.onProgress) == null ? void 0 : _a13.call(options, new CustomProgressEvent("dns:response", { detail: response2 }));
      return response2;
    }, {
      signal: options.signal
    });
    if (response == null) {
      throw new Error("No DNS response received");
    }
    return response;
  };
}

// node_modules/.pnpm/@multiformats+dns@1.0.6/node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js
function defaultResolver() {
  return [
    dnsJsonOverHttps("https://cloudflare-dns.com/dns-query"),
    dnsJsonOverHttps("https://dns.google/resolve")
  ];
}

// node_modules/.pnpm/@multiformats+dns@1.0.6/node_modules/@multiformats/dns/dist/src/utils/cache.js
var import_hashlru = __toESM(require_hashlru(), 1);
var CachedAnswers = class {
  constructor(maxSize) {
    __publicField(this, "lru");
    this.lru = (0, import_hashlru.default)(maxSize);
  }
  get(fqdn, types) {
    let foundAllAnswers = true;
    const answers = [];
    for (const type of types) {
      const cached = this.getAnswers(fqdn, type);
      if (cached.length === 0) {
        foundAllAnswers = false;
        break;
      }
      answers.push(...cached);
    }
    if (foundAllAnswers) {
      return toDNSResponse({ answers });
    }
  }
  getAnswers(domain, type) {
    const key = `${domain.toLowerCase()}-${type}`;
    const answers = this.lru.get(key);
    if (answers != null) {
      const cachedAnswers = answers.filter((entry) => {
        return entry.expires > Date.now();
      }).map(({ expires, value }) => ({
        ...value,
        TTL: Math.round((expires - Date.now()) / 1e3),
        type: RecordType[value.type]
      }));
      if (cachedAnswers.length === 0) {
        this.lru.remove(key);
      }
      return cachedAnswers;
    }
    return [];
  }
  add(domain, answer) {
    const key = `${domain.toLowerCase()}-${answer.type}`;
    const answers = this.lru.get(key) ?? [];
    answers.push({
      expires: Date.now() + (answer.TTL ?? DEFAULT_TTL) * 1e3,
      value: answer
    });
    this.lru.set(key, answers);
  }
  remove(domain, type) {
    const key = `${domain.toLowerCase()}-${type}`;
    this.lru.remove(key);
  }
  clear() {
    this.lru.clear();
  }
};
function cache(size) {
  return new CachedAnswers(size);
}

// node_modules/.pnpm/@multiformats+dns@1.0.6/node_modules/@multiformats/dns/dist/src/dns.js
var DEFAULT_ANSWER_CACHE_SIZE = 1e3;
var DNS = class {
  constructor(init) {
    __publicField(this, "resolvers");
    __publicField(this, "cache");
    this.resolvers = {};
    this.cache = cache(init.cacheSize ?? DEFAULT_ANSWER_CACHE_SIZE);
    Object.entries(init.resolvers ?? {}).forEach(([tld, resolver]) => {
      if (!Array.isArray(resolver)) {
        resolver = [resolver];
      }
      if (!tld.endsWith(".")) {
        tld = `${tld}.`;
      }
      this.resolvers[tld] = resolver;
    });
    if (this.resolvers["."] == null) {
      this.resolvers["."] = defaultResolver();
    }
  }
  /**
   * Queries DNS resolvers for the passed record types for the passed domain.
   *
   * If cached records exist for all desired types they will be returned
   * instead.
   *
   * Any new responses will be added to the cache for subsequent requests.
   */
  async query(domain, options = {}) {
    var _a12, _b4, _c;
    const types = getTypes(options.types);
    const cached = options.cached !== false ? this.cache.get(domain, types) : void 0;
    if (cached != null) {
      (_a12 = options.onProgress) == null ? void 0 : _a12.call(options, new CustomProgressEvent("dns:cache", { detail: cached }));
      return cached;
    }
    const tld = `${domain.split(".").pop()}.`;
    const resolvers2 = (this.resolvers[tld] ?? this.resolvers["."]).sort(() => {
      return Math.random() > 0.5 ? -1 : 1;
    });
    const errors = [];
    for (const resolver of resolvers2) {
      if (((_b4 = options.signal) == null ? void 0 : _b4.aborted) === true) {
        break;
      }
      try {
        const result = await resolver(domain, {
          ...options,
          types
        });
        for (const answer of result.Answer) {
          this.cache.add(domain, answer);
        }
        return result;
      } catch (err) {
        errors.push(err);
        (_c = options.onProgress) == null ? void 0 : _c.call(options, new CustomProgressEvent("dns:error", { detail: err }));
      }
    }
    if (errors.length === 1) {
      throw errors[0];
    }
    throw new AggregateError(errors, `DNS lookup of ${domain} ${types} failed`);
  }
};

// node_modules/.pnpm/@multiformats+dns@1.0.6/node_modules/@multiformats/dns/dist/src/index.js
var RecordType;
(function(RecordType2) {
  RecordType2[RecordType2["A"] = 1] = "A";
  RecordType2[RecordType2["CNAME"] = 5] = "CNAME";
  RecordType2[RecordType2["TXT"] = 16] = "TXT";
  RecordType2[RecordType2["AAAA"] = 28] = "AAAA";
})(RecordType || (RecordType = {}));
function dns(init = {}) {
  return new DNS(init);
}

// node_modules/.pnpm/@multiformats+multiaddr@12.4.0/node_modules/@multiformats/multiaddr/dist/src/resolvers/dnsaddr.js
var MAX_RECURSIVE_DEPTH = 32;
var { code: dnsaddrCode } = getProtocol("dnsaddr");
var RecursionLimitError = class extends Error {
  constructor(message2 = "Max recursive depth reached") {
    super(message2);
    this.name = "RecursionLimitError";
  }
};
var dnsaddrResolver = async function dnsaddrResolver2(ma, options = {}) {
  const recursionLimit = options.maxRecursiveDepth ?? MAX_RECURSIVE_DEPTH;
  if (recursionLimit === 0) {
    throw new RecursionLimitError("Max recursive depth reached");
  }
  const [, hostname] = ma.stringTuples().find(([proto]) => proto === dnsaddrCode) ?? [];
  const resolver = (options == null ? void 0 : options.dns) ?? dns();
  const result = await resolver.query(`_dnsaddr.${hostname}`, {
    signal: options == null ? void 0 : options.signal,
    types: [
      RecordType.TXT
    ]
  });
  const peerId = ma.getPeerId();
  const output = [];
  for (const answer of result.Answer) {
    const addr = answer.data.replace(/["']/g, "").trim().split("=")[1];
    if (addr == null) {
      continue;
    }
    if (peerId != null && !addr.includes(peerId)) {
      continue;
    }
    const ma2 = multiaddr(addr);
    if (addr.startsWith("/dnsaddr")) {
      const resolved = await ma2.resolve({
        ...options,
        maxRecursiveDepth: recursionLimit - 1
      });
      output.push(...resolved.map((ma3) => ma3.toString()));
    } else {
      output.push(ma2.toString());
    }
  }
  return output;
};

// node_modules/.pnpm/merge-options@3.0.4/node_modules/merge-options/index.mjs
var import_index2 = __toESM(require_merge_options(), 1);
var merge_options_default = import_index2.default;

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/config.js
var DefaultConfig = {
  addresses: {
    listen: [],
    announce: [],
    noAnnounce: [],
    announceFilter: (multiaddrs) => multiaddrs
  },
  connectionManager: {
    resolvers: {
      dnsaddr: dnsaddrResolver
    }
  },
  transportManager: {
    faultTolerance: FaultTolerance.FATAL_ALL
  }
};
async function validateConfig(opts) {
  var _a12, _b4;
  const resultingOptions = merge_options_default(DefaultConfig, opts);
  if (resultingOptions.connectionProtector === null && ((_b4 = (_a12 = globalThis.process) == null ? void 0 : _a12.env) == null ? void 0 : _b4.LIBP2P_FORCE_PNET) != null) {
    throw new InvalidParametersError("Private network is enforced, but no protector was provided");
  }
  return resultingOptions;
}

// node_modules/.pnpm/ms@3.0.0-canary.1/node_modules/ms/dist/index.mjs
var s = 1e3;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
function ms(value, options) {
  try {
    if (typeof value === "string" && value.length > 0) {
      return parse(value);
    } else if (typeof value === "number" && isFinite(value)) {
      return (options == null ? void 0 : options.long) ? fmtLong(value) : fmtShort(value);
    }
    throw new Error("Value is not a string or number.");
  } catch (error) {
    const message2 = isError(error) ? `${error.message}. value=${JSON.stringify(value)}` : "An unknown error has occured.";
    throw new Error(message2);
  }
}
function parse(str) {
  str = String(str);
  if (str.length > 100) {
    throw new Error("Value exceeds the maximum length of 100 characters.");
  }
  const match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
  if (!match) {
    return NaN;
  }
  const n = parseFloat(match[1]);
  const type = (match[2] || "ms").toLowerCase();
  switch (type) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y;
    case "weeks":
    case "week":
    case "w":
      return n * w;
    case "days":
    case "day":
    case "d":
      return n * d;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      throw new Error(`The unit ${type} was matched, but no matching case exists.`);
  }
}
var dist_default = ms;
function fmtShort(ms2) {
  const msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return `${Math.round(ms2 / d)}d`;
  }
  if (msAbs >= h) {
    return `${Math.round(ms2 / h)}h`;
  }
  if (msAbs >= m) {
    return `${Math.round(ms2 / m)}m`;
  }
  if (msAbs >= s) {
    return `${Math.round(ms2 / s)}s`;
  }
  return `${ms2}ms`;
}
function fmtLong(ms2) {
  const msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return plural(ms2, msAbs, d, "day");
  }
  if (msAbs >= h) {
    return plural(ms2, msAbs, h, "hour");
  }
  if (msAbs >= m) {
    return plural(ms2, msAbs, m, "minute");
  }
  if (msAbs >= s) {
    return plural(ms2, msAbs, s, "second");
  }
  return `${ms2} ms`;
}
function plural(ms2, msAbs, n, name2) {
  const isPlural = msAbs >= n * 1.5;
  return `${Math.round(ms2 / n)} ${name2}${isPlural ? "s" : ""}`;
}
function isError(error) {
  return typeof error === "object" && error !== null && "message" in error;
}

// node_modules/.pnpm/weald@1.0.4/node_modules/weald/dist/src/common.js
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = dist_default;
  createDebug.destroy = destroy;
  Object.keys(env).forEach((key) => {
    createDebug[key] = env[key];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace) {
    let hash = 0;
    for (let i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0;
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;
  function createDebug(namespace) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug(...args) {
      if (!debug.enabled) {
        return;
      }
      const self = debug;
      const curr = Number(/* @__PURE__ */ new Date());
      const ms2 = curr - (prevTime || curr);
      self.diff = ms2;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
        if (match === "%%") {
          return "%";
        }
        index++;
        const formatter = createDebug.formatters[format];
        if (typeof formatter === "function") {
          const val = args[index];
          match = formatter.call(self, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      createDebug.formatArgs.call(self, args);
      const logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }
    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy;
    Object.defineProperty(debug, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug);
    }
    return debug;
  }
  function extend(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i;
    const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len = split.length;
    for (i = 0; i < len; i++) {
      if (!split[i]) {
        continue;
      }
      namespaces = split[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
    ].join(",");
    createDebug.enable("");
    return namespaces;
  }
  function enabled(name2) {
    if (name2[name2.length - 1] === "*") {
      return true;
    }
    let i;
    let len;
    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name2)) {
        return false;
      }
    }
    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name2)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce(val) {
    if (val instanceof Error) {
      return val.stack ?? val.message;
    }
    return val;
  }
  function destroy() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug.setupFormatters(createDebug.formatters);
  createDebug.enable(createDebug.load());
  return createDebug;
}

// node_modules/.pnpm/weald@1.0.4/node_modules/weald/dist/src/browser.js
var storage = localstorage();
var colors = [
  "#0000CC",
  "#0000FF",
  "#0033CC",
  "#0033FF",
  "#0066CC",
  "#0066FF",
  "#0099CC",
  "#0099FF",
  "#00CC00",
  "#00CC33",
  "#00CC66",
  "#00CC99",
  "#00CCCC",
  "#00CCFF",
  "#3300CC",
  "#3300FF",
  "#3333CC",
  "#3333FF",
  "#3366CC",
  "#3366FF",
  "#3399CC",
  "#3399FF",
  "#33CC00",
  "#33CC33",
  "#33CC66",
  "#33CC99",
  "#33CCCC",
  "#33CCFF",
  "#6600CC",
  "#6600FF",
  "#6633CC",
  "#6633FF",
  "#66CC00",
  "#66CC33",
  "#9900CC",
  "#9900FF",
  "#9933CC",
  "#9933FF",
  "#99CC00",
  "#99CC33",
  "#CC0000",
  "#CC0033",
  "#CC0066",
  "#CC0099",
  "#CC00CC",
  "#CC00FF",
  "#CC3300",
  "#CC3333",
  "#CC3366",
  "#CC3399",
  "#CC33CC",
  "#CC33FF",
  "#CC6600",
  "#CC6633",
  "#CC9900",
  "#CC9933",
  "#CCCC00",
  "#CCCC33",
  "#FF0000",
  "#FF0033",
  "#FF0066",
  "#FF0099",
  "#FF00CC",
  "#FF00FF",
  "#FF3300",
  "#FF3333",
  "#FF3366",
  "#FF3399",
  "#FF33CC",
  "#FF33FF",
  "#FF6600",
  "#FF6633",
  "#FF9900",
  "#FF9933",
  "#FFCC00",
  "#FFCC33"
];
function useColors() {
  var _a12, _b4, _c, _d, _e;
  if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
    return true;
  }
  if (typeof navigator !== "undefined" && ((_a12 = navigator.userAgent) == null ? void 0 : _a12.toLowerCase().match(/(edge|trident)\/(\d+)/)) != null) {
    return false;
  }
  return typeof document !== "undefined" && ((_c = (_b4 = document.documentElement) == null ? void 0 : _b4.style) == null ? void 0 : _c.WebkitAppearance) || // Is firebug? http://stackoverflow.com/a/398120/376773
  // @ts-expect-error window.console.firebug and window.console.exception are not in the types
  typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== "undefined" && ((_d = navigator.userAgent) == null ? void 0 : _d.toLowerCase().match(/firefox\/(\d+)/)) != null && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== "undefined" && ((_e = navigator.userAgent) == null ? void 0 : _e.toLowerCase().match(/applewebkit\/(\d+)/));
}
function formatArgs(args) {
  args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + dist_default(this.diff);
  if (!this.useColors) {
    return;
  }
  const c = "color: " + this.color;
  args.splice(1, 0, c, "color: inherit");
  let index = 0;
  let lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, (match) => {
    if (match === "%%") {
      return;
    }
    index++;
    if (match === "%c") {
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
var log = console.debug ?? console.log ?? (() => {
});
function save(namespaces) {
  try {
    if (namespaces) {
      storage == null ? void 0 : storage.setItem("debug", namespaces);
    } else {
      storage == null ? void 0 : storage.removeItem("debug");
    }
  } catch (error) {
  }
}
function load() {
  let r;
  try {
    r = storage == null ? void 0 : storage.getItem("debug");
  } catch (error) {
  }
  if (!r && typeof globalThis.process !== "undefined" && "env" in globalThis.process) {
    r = globalThis.process.env.DEBUG;
  }
  return r;
}
function localstorage() {
  try {
    return localStorage;
  } catch (error) {
  }
}
function setupFormatters(formatters) {
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
}
var browser_default = setup({ formatArgs, save, load, useColors, setupFormatters, colors, storage, log });

// node_modules/.pnpm/weald@1.0.4/node_modules/weald/dist/src/index.js
var src_default4 = browser_default;

// node_modules/.pnpm/@libp2p+logger@5.1.13/node_modules/@libp2p/logger/dist/src/index.js
src_default4.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc.baseEncode(v);
};
src_default4.formatters.t = (v) => {
  return v == null ? "undefined" : base32.baseEncode(v);
};
src_default4.formatters.m = (v) => {
  return v == null ? "undefined" : base64.baseEncode(v);
};
src_default4.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default4.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default4.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default4.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default4.formatters.e = (v) => {
  return v == null ? "undefined" : notEmpty(v.stack) ?? notEmpty(v.message) ?? v.toString();
};
function createDisabledLogger(namespace) {
  const logger2 = () => {
  };
  logger2.enabled = false;
  logger2.color = "";
  logger2.diff = 0;
  logger2.log = () => {
  };
  logger2.namespace = namespace;
  logger2.destroy = () => true;
  logger2.extend = () => logger2;
  return logger2;
}
function defaultLogger() {
  return {
    forComponent(name2) {
      return logger(name2);
    }
  };
}
function logger(name2) {
  let trace = createDisabledLogger(`${name2}:trace`);
  if (src_default4.enabled(`${name2}:trace`) && src_default4.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = src_default4(`${name2}:trace`);
  }
  return Object.assign(src_default4(name2), {
    error: src_default4(`${name2}:error`),
    trace
  });
}
function notEmpty(str) {
  if (str == null) {
    return;
  }
  str = str.trim();
  if (str.length === 0) {
    return;
  }
  return str;
}

// node_modules/.pnpm/@libp2p+peer-collections@6.0.25/node_modules/@libp2p/peer-collections/dist/src/util.js
function mapIterable(iter, map) {
  const iterator = {
    [Symbol.iterator]: () => {
      return iterator;
    },
    next: () => {
      const next = iter.next();
      const val = next.value;
      if (next.done === true || val == null) {
        const result = {
          done: true,
          value: void 0
        };
        return result;
      }
      return {
        done: false,
        value: map(val)
      };
    }
  };
  return iterator;
}
function peerIdFromString2(str) {
  const multihash = decode(base58btc.decode(`z${str}`));
  return peerIdFromMultihash(multihash);
}

// node_modules/.pnpm/@libp2p+peer-collections@6.0.25/node_modules/@libp2p/peer-collections/dist/src/map.js
var PeerMap = class {
  constructor(map) {
    __publicField(this, "map");
    this.map = /* @__PURE__ */ new Map();
    if (map != null) {
      for (const [key, value] of map.entries()) {
        this.map.set(key.toString(), { key, value });
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  clear() {
    this.map.clear();
  }
  delete(peer) {
    return this.map.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.map.entries(), (val) => {
      return [val[1].key, val[1].value];
    });
  }
  forEach(fn) {
    this.map.forEach((value, key) => {
      fn(value.value, value.key, this);
    });
  }
  get(peer) {
    var _a12;
    return (_a12 = this.map.get(peer.toString())) == null ? void 0 : _a12.value;
  }
  has(peer) {
    return this.map.has(peer.toString());
  }
  set(peer, value) {
    this.map.set(peer.toString(), { key: peer, value });
  }
  keys() {
    return mapIterable(this.map.values(), (val) => {
      return val.key;
    });
  }
  values() {
    return mapIterable(this.map.values(), (val) => val.value);
  }
  get size() {
    return this.map.size;
  }
};

// node_modules/.pnpm/@libp2p+peer-collections@6.0.25/node_modules/@libp2p/peer-collections/dist/src/set.js
var PeerSet = class _PeerSet {
  constructor(set) {
    __publicField(this, "set");
    this.set = /* @__PURE__ */ new Set();
    if (set != null) {
      for (const key of set) {
        this.set.add(key.toString());
      }
    }
  }
  get size() {
    return this.set.size;
  }
  [Symbol.iterator]() {
    return this.values();
  }
  add(peer) {
    this.set.add(peer.toString());
  }
  clear() {
    this.set.clear();
  }
  delete(peer) {
    this.set.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.set.entries(), (val) => {
      const peerId = peerIdFromString2(val[0]);
      return [peerId, peerId];
    });
  }
  forEach(predicate) {
    this.set.forEach((str) => {
      const peerId = peerIdFromString2(str);
      predicate(peerId, peerId, this);
    });
  }
  has(peer) {
    return this.set.has(peer.toString());
  }
  values() {
    return mapIterable(this.set.values(), (val) => {
      return peerIdFromString2(val);
    });
  }
  intersection(other) {
    const output = new _PeerSet();
    for (const peerId of other) {
      if (this.has(peerId)) {
        output.add(peerId);
      }
    }
    return output;
  }
  difference(other) {
    const output = new _PeerSet();
    for (const peerId of this) {
      if (!other.has(peerId)) {
        output.add(peerId);
      }
    }
    return output;
  }
  union(other) {
    const output = new _PeerSet();
    for (const peerId of other) {
      output.add(peerId);
    }
    for (const peerId of this) {
      output.add(peerId);
    }
    return output;
  }
};

// node_modules/.pnpm/@sindresorhus+fnv1a@3.1.0/node_modules/@sindresorhus/fnv1a/index.js
var FNV_PRIMES = {
  32: 16777619n,
  64: 1099511628211n,
  128: 309485009821345068724781371n,
  256: 374144419156711147060143317175368453031918731002211n,
  512: 35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,
  1024: 5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n
};
var FNV_OFFSETS = {
  32: 2166136261n,
  64: 14695981039346656037n,
  128: 144066263297769815596495629667062367629n,
  256: 100029257958052580907070968620625704837092796014241193945225284501741471925557n,
  512: 9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,
  1024: 14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n
};
var cachedEncoder = new globalThis.TextEncoder();
function fnv1aUint8Array(uint8Array, size) {
  const fnvPrime = FNV_PRIMES[size];
  let hash = FNV_OFFSETS[size];
  for (let index = 0; index < uint8Array.length; index++) {
    hash ^= BigInt(uint8Array[index]);
    hash = BigInt.asUintN(size, hash * fnvPrime);
  }
  return hash;
}
function fnv1aEncodeInto(string, size, utf8Buffer) {
  if (utf8Buffer.length === 0) {
    throw new Error("The `utf8Buffer` option must have a length greater than zero");
  }
  const fnvPrime = FNV_PRIMES[size];
  let hash = FNV_OFFSETS[size];
  let remaining = string;
  while (remaining.length > 0) {
    const result = cachedEncoder.encodeInto(remaining, utf8Buffer);
    remaining = remaining.slice(result.read);
    for (let index = 0; index < result.written; index++) {
      hash ^= BigInt(utf8Buffer[index]);
      hash = BigInt.asUintN(size, hash * fnvPrime);
    }
  }
  return hash;
}
function fnv1a(value, { size = 32, utf8Buffer } = {}) {
  if (!FNV_PRIMES[size]) {
    throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");
  }
  if (typeof value === "string") {
    if (utf8Buffer) {
      return fnv1aEncodeInto(value, size, utf8Buffer);
    }
    value = cachedEncoder.encode(value);
  }
  return fnv1aUint8Array(value, size);
}

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/filters/hashes.js
var fnv1a2 = {
  hash: (input) => {
    return Number(fnv1a(input, {
      size: 32
    }));
  },
  hashV: (input, seed) => {
    return numberToBuffer(fnv1a2.hash(input, seed));
  }
};
function numberToBuffer(num) {
  let hex = num.toString(16);
  if (hex.length % 2 === 1) {
    hex = `0${hex}`;
  }
  return fromString(hex, "base16");
}

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/filters/bloom-filter.js
var LN2_SQUARED = Math.LN2 * Math.LN2;

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/filters/fingerprint.js
var MAX_FINGERPRINT_SIZE = 64;
var Fingerprint = class {
  constructor(buf, hash, seed, fingerprintSize = 2) {
    __publicField(this, "fp");
    __publicField(this, "h");
    __publicField(this, "seed");
    if (fingerprintSize > MAX_FINGERPRINT_SIZE) {
      throw new TypeError("Invalid Fingerprint Size");
    }
    const fnv = hash.hashV(buf, seed);
    const fp = alloc(fingerprintSize);
    for (let i = 0; i < fp.length; i++) {
      fp[i] = fnv[i];
    }
    if (fp.length === 0) {
      fp[0] = 7;
    }
    this.fp = fp;
    this.h = hash;
    this.seed = seed;
  }
  hash() {
    return this.h.hash(this.fp, this.seed);
  }
  equals(other) {
    if (!((other == null ? void 0 : other.fp) instanceof Uint8Array)) {
      return false;
    }
    return equals(this.fp, other.fp);
  }
};

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/filters/utils.js
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/filters/bucket.js
var Bucket = class {
  constructor(size) {
    __publicField(this, "contents");
    this.contents = new Array(size).fill(null);
  }
  has(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    return this.contents.some((fp) => {
      return fingerprint.equals(fp);
    });
  }
  add(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    for (let i = 0; i < this.contents.length; i++) {
      if (this.contents[i] == null) {
        this.contents[i] = fingerprint;
        return true;
      }
    }
    return true;
  }
  swap(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    const i = getRandomInt(0, this.contents.length - 1);
    const current = this.contents[i];
    this.contents[i] = fingerprint;
    return current;
  }
  remove(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    const found = this.contents.findIndex((fp) => {
      return fingerprint.equals(fp);
    });
    if (found > -1) {
      this.contents[found] = null;
      return true;
    } else {
      return false;
    }
  }
};

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/filters/cuckoo-filter.js
var maxCuckooCount = 500;
var CuckooFilter = class {
  constructor(init) {
    __publicField(this, "bucketSize");
    __publicField(this, "filterSize");
    __publicField(this, "fingerprintSize");
    __publicField(this, "buckets");
    __publicField(this, "count");
    __publicField(this, "hash");
    __publicField(this, "seed");
    this.filterSize = init.filterSize;
    this.bucketSize = init.bucketSize ?? 4;
    this.fingerprintSize = init.fingerprintSize ?? 2;
    this.count = 0;
    this.buckets = [];
    this.hash = init.hash ?? fnv1a2;
    this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10));
  }
  add(item) {
    if (typeof item === "string") {
      item = fromString(item);
    }
    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
    const j = this.hash.hash(item, this.seed) % this.filterSize;
    const k = (j ^ fingerprint.hash()) % this.filterSize;
    if (this.buckets[j] == null) {
      this.buckets[j] = new Bucket(this.bucketSize);
    }
    if (this.buckets[k] == null) {
      this.buckets[k] = new Bucket(this.bucketSize);
    }
    if (this.buckets[j].add(fingerprint) || this.buckets[k].add(fingerprint)) {
      this.count++;
      return true;
    }
    const rand = [j, k];
    let i = rand[getRandomInt(0, rand.length - 1)];
    if (this.buckets[i] == null) {
      this.buckets[i] = new Bucket(this.bucketSize);
    }
    for (let n = 0; n < maxCuckooCount; n++) {
      const swapped = this.buckets[i].swap(fingerprint);
      if (swapped == null) {
        continue;
      }
      i = (i ^ swapped.hash()) % this.filterSize;
      if (this.buckets[i] == null) {
        this.buckets[i] = new Bucket(this.bucketSize);
      }
      if (this.buckets[i].add(swapped)) {
        this.count++;
        return true;
      } else {
        continue;
      }
    }
    return false;
  }
  has(item) {
    var _a12, _b4;
    if (typeof item === "string") {
      item = fromString(item);
    }
    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
    const j = this.hash.hash(item, this.seed) % this.filterSize;
    const inJ = ((_a12 = this.buckets[j]) == null ? void 0 : _a12.has(fingerprint)) ?? false;
    if (inJ) {
      return inJ;
    }
    const k = (j ^ fingerprint.hash()) % this.filterSize;
    return ((_b4 = this.buckets[k]) == null ? void 0 : _b4.has(fingerprint)) ?? false;
  }
  remove(item) {
    var _a12, _b4;
    if (typeof item === "string") {
      item = fromString(item);
    }
    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
    const j = this.hash.hash(item, this.seed) % this.filterSize;
    const inJ = ((_a12 = this.buckets[j]) == null ? void 0 : _a12.remove(fingerprint)) ?? false;
    if (inJ) {
      this.count--;
      return inJ;
    }
    const k = (j ^ fingerprint.hash()) % this.filterSize;
    const inK = ((_b4 = this.buckets[k]) == null ? void 0 : _b4.remove(fingerprint)) ?? false;
    if (inK) {
      this.count--;
    }
    return inK;
  }
  get reliable() {
    return Math.floor(100 * (this.count / this.filterSize)) <= 90;
  }
};
var MAX_LOAD = {
  1: 0.5,
  2: 0.84,
  4: 0.95,
  8: 0.98
};
function calculateBucketSize(errorRate = 1e-3) {
  if (errorRate > 2e-3) {
    return 2;
  }
  if (errorRate > 1e-5) {
    return 4;
  }
  return 8;
}
function optimize(maxItems, errorRate = 1e-3) {
  const bucketSize = calculateBucketSize(errorRate);
  const load2 = MAX_LOAD[bucketSize];
  const filterSize = Math.round(maxItems / load2);
  const fingerprintSize = Math.min(Math.ceil(Math.log2(1 / errorRate) + Math.log2(2 * bucketSize)), MAX_FINGERPRINT_SIZE);
  return {
    filterSize,
    bucketSize,
    fingerprintSize
  };
}

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/filters/scalable-cuckoo-filter.js
var ScalableCuckooFilter = class {
  constructor(init) {
    __publicField(this, "filterSize");
    __publicField(this, "bucketSize");
    __publicField(this, "fingerprintSize");
    __publicField(this, "scale");
    __publicField(this, "filterSeries");
    __publicField(this, "hash");
    __publicField(this, "seed");
    this.bucketSize = init.bucketSize ?? 4;
    this.filterSize = init.filterSize ?? (1 << 18) / this.bucketSize;
    this.fingerprintSize = init.fingerprintSize ?? 2;
    this.scale = init.scale ?? 2;
    this.hash = init.hash ?? fnv1a2;
    this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10));
    this.filterSeries = [
      new CuckooFilter({
        filterSize: this.filterSize,
        bucketSize: this.bucketSize,
        fingerprintSize: this.fingerprintSize,
        hash: this.hash,
        seed: this.seed
      })
    ];
  }
  add(item) {
    if (typeof item === "string") {
      item = fromString(item);
    }
    if (this.has(item)) {
      return true;
    }
    let current = this.filterSeries.find((cuckoo) => {
      return cuckoo.reliable;
    });
    if (current == null) {
      const curSize = this.filterSize * Math.pow(this.scale, this.filterSeries.length);
      current = new CuckooFilter({
        filterSize: curSize,
        bucketSize: this.bucketSize,
        fingerprintSize: this.fingerprintSize,
        hash: this.hash,
        seed: this.seed
      });
      this.filterSeries.push(current);
    }
    return current.add(item);
  }
  has(item) {
    if (typeof item === "string") {
      item = fromString(item);
    }
    for (let i = 0; i < this.filterSeries.length; i++) {
      if (this.filterSeries[i].has(item)) {
        return true;
      }
    }
    return false;
  }
  remove(item) {
    if (typeof item === "string") {
      item = fromString(item);
    }
    for (let i = 0; i < this.filterSeries.length; i++) {
      if (this.filterSeries[i].remove(item)) {
        return true;
      }
    }
    return false;
  }
  get count() {
    return this.filterSeries.reduce((acc, curr) => {
      return acc + curr.count;
    }, 0);
  }
};
function createScalableCuckooFilter(maxItems, errorRate = 1e-3, options) {
  return new ScalableCuckooFilter({
    ...optimize(maxItems, errorRate),
    ...options ?? {}
  });
}

// node_modules/.pnpm/@libp2p+peer-record@8.0.25/node_modules/@libp2p/peer-record/dist/src/envelope/envelope.js
var Envelope;
(function(Envelope2) {
  let _codec;
  Envelope2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.publicKey);
        }
        if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
          w2.uint32(18);
          w2.bytes(obj.payloadType);
        }
        if (obj.payload != null && obj.payload.byteLength > 0) {
          w2.uint32(26);
          w2.bytes(obj.payload);
        }
        if (obj.signature != null && obj.signature.byteLength > 0) {
          w2.uint32(42);
          w2.bytes(obj.signature);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {
          publicKey: alloc(0),
          payloadType: alloc(0),
          payload: alloc(0),
          signature: alloc(0)
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              obj.payloadType = reader.bytes();
              break;
            }
            case 3: {
              obj.payload = reader.bytes();
              break;
            }
            case 5: {
              obj.signature = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Envelope2.encode = (obj) => {
    return encodeMessage(obj, Envelope2.codec());
  };
  Envelope2.decode = (buf, opts) => {
    return decodeMessage(buf, Envelope2.codec(), opts);
  };
})(Envelope || (Envelope = {}));

// node_modules/.pnpm/@libp2p+peer-record@8.0.25/node_modules/@libp2p/peer-record/dist/src/envelope/errors.js
var InvalidSignatureError = class extends Error {
  constructor(message2 = "Invalid signature") {
    super(message2);
    this.name = "InvalidSignatureError";
  }
};

// node_modules/.pnpm/@libp2p+peer-record@8.0.25/node_modules/@libp2p/peer-record/dist/src/envelope/index.js
var _RecordEnvelope = class _RecordEnvelope {
  /**
   * The Envelope is responsible for keeping an arbitrary signed record
   * by a libp2p peer.
   */
  constructor(init) {
    __publicField(this, "publicKey");
    __publicField(this, "payloadType");
    __publicField(this, "payload");
    __publicField(this, "signature");
    __publicField(this, "marshaled");
    const { publicKey, payloadType, payload, signature } = init;
    this.publicKey = publicKey;
    this.payloadType = payloadType;
    this.payload = payload;
    this.signature = signature;
  }
  /**
   * Marshal the envelope content
   */
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = Envelope.encode({
        publicKey: publicKeyToProtobuf(this.publicKey),
        payloadType: this.payloadType,
        payload: this.payload.subarray(),
        signature: this.signature
      });
    }
    return this.marshaled;
  }
  /**
   * Verifies if the other Envelope is identical to this one
   */
  equals(other) {
    return equals(this.marshal(), other.marshal());
  }
  /**
   * Validate envelope data signature for the given domain
   */
  async validate(domain) {
    const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
    return this.publicKey.verify(signData.subarray(), this.signature);
  }
};
/**
 * Unmarshal a serialized Envelope protobuf message
 */
__publicField(_RecordEnvelope, "createFromProtobuf", async (data) => {
  const envelopeData = Envelope.decode(data);
  const publicKey = publicKeyFromProtobuf(envelopeData.publicKey);
  return new _RecordEnvelope({
    publicKey,
    payloadType: envelopeData.payloadType,
    payload: envelopeData.payload,
    signature: envelopeData.signature
  });
});
/**
 * Seal marshals the given Record, places the marshaled bytes inside an Envelope
 * and signs it with the given peerId's private key
 */
__publicField(_RecordEnvelope, "seal", async (record, privateKey) => {
  if (privateKey == null) {
    throw new Error("Missing private key");
  }
  const domain = record.domain;
  const payloadType = record.codec;
  const payload = record.marshal();
  const signData = formatSignaturePayload(domain, payloadType, payload);
  const signature = await privateKey.sign(signData.subarray());
  return new _RecordEnvelope({
    publicKey: privateKey.publicKey,
    payloadType,
    payload,
    signature
  });
});
/**
 * Open and certify a given marshaled envelope.
 * Data is unmarshaled and the signature validated for the given domain.
 */
__publicField(_RecordEnvelope, "openAndCertify", async (data, domain) => {
  const envelope = await _RecordEnvelope.createFromProtobuf(data);
  const valid = await envelope.validate(domain);
  if (!valid) {
    throw new InvalidSignatureError("Envelope signature is not valid for the given domain");
  }
  return envelope;
});
var RecordEnvelope = _RecordEnvelope;
var formatSignaturePayload = (domain, payloadType, payload) => {
  const domainUint8Array = fromString(domain);
  const domainLength = encode(domainUint8Array.byteLength);
  const payloadTypeLength = encode(payloadType.length);
  const payloadLength = encode(payload.length);
  return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);
};

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/array-equals.js
function arrayEquals(a, b) {
  const sort2 = (a2, b2) => a2.toString().localeCompare(b2.toString());
  if (a.length !== b.length) {
    return false;
  }
  b.sort(sort2);
  return a.sort(sort2).every((item, index) => b[index].equals(item));
}

// node_modules/.pnpm/@libp2p+peer-record@8.0.25/node_modules/@libp2p/peer-record/dist/src/peer-record/consts.js
var ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record";
var ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);

// node_modules/.pnpm/@libp2p+peer-record@8.0.25/node_modules/@libp2p/peer-record/dist/src/peer-record/peer-record.js
var PeerRecord;
(function(PeerRecord3) {
  let AddressInfo;
  (function(AddressInfo2) {
    let _codec2;
    AddressInfo2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.multiaddr);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length, opts = {}) => {
          const obj = {
            multiaddr: alloc(0)
          };
          const end = length == null ? reader.len : reader.pos + length;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.multiaddr = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    AddressInfo2.encode = (obj) => {
      return encodeMessage(obj, AddressInfo2.codec());
    };
    AddressInfo2.decode = (buf, opts) => {
      return decodeMessage(buf, AddressInfo2.codec(), opts);
    };
  })(AddressInfo = PeerRecord3.AddressInfo || (PeerRecord3.AddressInfo = {}));
  let _codec;
  PeerRecord3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.peerId != null && obj.peerId.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.peerId);
        }
        if (obj.seq != null && obj.seq !== 0n) {
          w2.uint32(16);
          w2.uint64(obj.seq);
        }
        if (obj.addresses != null) {
          for (const value of obj.addresses) {
            w2.uint32(26);
            PeerRecord3.AddressInfo.codec().encode(value, w2);
          }
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length, opts = {}) => {
        var _a12, _b4;
        const obj = {
          peerId: alloc(0),
          seq: 0n,
          addresses: []
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.peerId = reader.bytes();
              break;
            }
            case 2: {
              obj.seq = reader.uint64();
              break;
            }
            case 3: {
              if (((_a12 = opts.limits) == null ? void 0 : _a12.addresses) != null && obj.addresses.length === opts.limits.addresses) {
                throw new MaxLengthError('Decode error - map field "addresses" had too many elements');
              }
              obj.addresses.push(PeerRecord3.AddressInfo.codec().decode(reader, reader.uint32(), {
                limits: (_b4 = opts.limits) == null ? void 0 : _b4.addresses$
              }));
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerRecord3.encode = (obj) => {
    return encodeMessage(obj, PeerRecord3.codec());
  };
  PeerRecord3.decode = (buf, opts) => {
    return decodeMessage(buf, PeerRecord3.codec(), opts);
  };
})(PeerRecord || (PeerRecord = {}));

// node_modules/.pnpm/@libp2p+peer-record@8.0.25/node_modules/@libp2p/peer-record/dist/src/peer-record/index.js
var _PeerRecord = class _PeerRecord {
  constructor(init) {
    __publicField(this, "peerId");
    __publicField(this, "multiaddrs");
    __publicField(this, "seqNumber");
    __publicField(this, "domain", _PeerRecord.DOMAIN);
    __publicField(this, "codec", _PeerRecord.CODEC);
    __publicField(this, "marshaled");
    const { peerId, multiaddrs, seqNumber } = init;
    this.peerId = peerId;
    this.multiaddrs = multiaddrs ?? [];
    this.seqNumber = seqNumber ?? BigInt(Date.now());
  }
  /**
   * Marshal a record to be used in an envelope
   */
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = PeerRecord.encode({
        peerId: this.peerId.toMultihash().bytes,
        seq: BigInt(this.seqNumber),
        addresses: this.multiaddrs.map((m2) => ({
          multiaddr: m2.bytes
        }))
      });
    }
    return this.marshaled;
  }
  /**
   * Returns true if `this` record equals the `other`
   */
  equals(other) {
    if (!(other instanceof _PeerRecord)) {
      return false;
    }
    if (!this.peerId.equals(other.peerId)) {
      return false;
    }
    if (this.seqNumber !== other.seqNumber) {
      return false;
    }
    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
      return false;
    }
    return true;
  }
};
/**
 * Unmarshal Peer Record Protobuf
 */
__publicField(_PeerRecord, "createFromProtobuf", (buf) => {
  const peerRecord = PeerRecord.decode(buf);
  const peerId = peerIdFromMultihash(decode(peerRecord.peerId));
  const multiaddrs = (peerRecord.addresses ?? []).map((a) => multiaddr(a.multiaddr));
  const seqNumber = peerRecord.seq;
  return new _PeerRecord({ peerId, multiaddrs, seqNumber });
});
__publicField(_PeerRecord, "DOMAIN", ENVELOPE_DOMAIN_PEER_RECORD);
__publicField(_PeerRecord, "CODEC", ENVELOPE_PAYLOAD_TYPE_PEER_RECORD);
var PeerRecord2 = _PeerRecord;

// node_modules/.pnpm/it-all@3.0.7/node_modules/it-all/dist/src/index.js
function isAsyncIterable(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function all(source) {
  if (isAsyncIterable(source)) {
    return (async () => {
      const arr2 = [];
      for await (const entry of source) {
        arr2.push(entry);
      }
      return arr2;
    })();
  }
  const arr = [];
  for (const entry of source) {
    arr.push(entry);
  }
  return arr;
}
var src_default5 = all;

// node_modules/.pnpm/observable-webworkers@2.0.1/node_modules/observable-webworkers/dist/src/index.js
var events = {};
var observable = (worker) => {
  worker.addEventListener("message", (event) => {
    observable.dispatchEvent("message", worker, event);
  });
  if (worker.port != null) {
    worker.port.addEventListener("message", (event) => {
      observable.dispatchEvent("message", worker, event);
    });
  }
};
observable.addEventListener = (type, fn) => {
  if (events[type] == null) {
    events[type] = [];
  }
  events[type].push(fn);
};
observable.removeEventListener = (type, fn) => {
  if (events[type] == null) {
    return;
  }
  events[type] = events[type].filter((listener) => listener === fn);
};
observable.dispatchEvent = function(type, worker, event) {
  if (events[type] == null) {
    return;
  }
  events[type].forEach((fn) => fn(worker, event));
};
var src_default6 = observable;

// node_modules/.pnpm/mortice@3.0.6/node_modules/mortice/dist/src/constants.js
var WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
var WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
var MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
var WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
var WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
var MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";

// node_modules/.pnpm/mortice@3.0.6/node_modules/mortice/dist/src/utils.js
var nanoid = (size = 21) => {
  return Math.random().toString().substring(2);
};

// node_modules/.pnpm/mortice@3.0.6/node_modules/mortice/dist/src/browser.js
var handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
  return (worker, event) => {
    if (event.data.type !== requestType) {
      return;
    }
    const requestEvent = {
      type: event.data.type,
      name: event.data.name,
      identifier: event.data.identifier
    };
    emitter.dispatchEvent(new MessageEvent(masterEvent, {
      data: {
        name: requestEvent.name,
        handler: async () => {
          worker.postMessage({
            type: grantType,
            name: requestEvent.name,
            identifier: requestEvent.identifier
          });
          await new Promise((resolve) => {
            const releaseEventListener = (event2) => {
              if ((event2 == null ? void 0 : event2.data) == null) {
                return;
              }
              const releaseEvent = {
                type: event2.data.type,
                name: event2.data.name,
                identifier: event2.data.identifier
              };
              if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                worker.removeEventListener("message", releaseEventListener);
                resolve();
              }
            };
            worker.addEventListener("message", releaseEventListener);
          });
        }
      }
    }));
  };
};
var makeWorkerLockRequest = (name2, requestType, grantType, releaseType) => {
  return async () => {
    const id = nanoid();
    globalThis.postMessage({
      type: requestType,
      identifier: id,
      name: name2
    });
    return new Promise((resolve) => {
      const listener = (event) => {
        if ((event == null ? void 0 : event.data) == null) {
          return;
        }
        const responseEvent = {
          type: event.data.type,
          identifier: event.data.identifier
        };
        if (responseEvent.type === grantType && responseEvent.identifier === id) {
          globalThis.removeEventListener("message", listener);
          resolve(() => {
            globalThis.postMessage({
              type: releaseType,
              identifier: id,
              name: name2
            });
          });
        }
      };
      globalThis.addEventListener("message", listener);
    });
  };
};
var defaultOptions = {
  singleProcess: false
};
var browser_default2 = (options) => {
  options = Object.assign({}, defaultOptions, options);
  const isPrimary = Boolean(globalThis.document) || options.singleProcess;
  if (isPrimary) {
    const emitter = new EventTarget();
    src_default6.addEventListener("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
    src_default6.addEventListener("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
    return emitter;
  }
  return {
    isWorker: true,
    readLock: (name2) => makeWorkerLockRequest(name2, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
    writeLock: (name2) => makeWorkerLockRequest(name2, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
  };
};

// node_modules/.pnpm/mortice@3.0.6/node_modules/mortice/dist/src/index.js
var mutexes = {};
var implementation;
async function createReleaseable(queue, options) {
  let res;
  const p = new Promise((resolve) => {
    res = resolve;
  });
  void queue.add(async () => pTimeout((async () => {
    await new Promise((resolve) => {
      res(() => {
        resolve();
      });
    });
  })(), {
    milliseconds: options.timeout
  }));
  return p;
}
var createMutex = (name2, options) => {
  if (implementation.isWorker === true) {
    return {
      readLock: implementation.readLock(name2, options),
      writeLock: implementation.writeLock(name2, options)
    };
  }
  const masterQueue = new PQueue({ concurrency: 1 });
  let readQueue;
  return {
    async readLock() {
      if (readQueue != null) {
        return createReleaseable(readQueue, options);
      }
      readQueue = new PQueue({
        concurrency: options.concurrency,
        autoStart: false
      });
      const localReadQueue = readQueue;
      const readPromise = createReleaseable(readQueue, options);
      void masterQueue.add(async () => {
        localReadQueue.start();
        await localReadQueue.onIdle().then(() => {
          if (readQueue === localReadQueue) {
            readQueue = null;
          }
        });
      });
      return readPromise;
    },
    async writeLock() {
      readQueue = null;
      return createReleaseable(masterQueue, options);
    }
  };
};
var defaultOptions2 = {
  name: "lock",
  concurrency: Infinity,
  timeout: 846e5,
  singleProcess: false
};
function createMortice(options) {
  const opts = Object.assign({}, defaultOptions2, options);
  if (implementation == null) {
    implementation = browser_default2(opts);
    if (implementation.isWorker !== true) {
      implementation.addEventListener("requestReadLock", (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].readLock().then(async (release) => event.data.handler().finally(() => {
          release();
        }));
      });
      implementation.addEventListener("requestWriteLock", async (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].writeLock().then(async (release) => event.data.handler().finally(() => {
          release();
        }));
      });
    }
  }
  if (mutexes[opts.name] == null) {
    mutexes[opts.name] = createMutex(opts.name, opts);
  }
  return mutexes[opts.name];
}

// node_modules/.pnpm/@libp2p+peer-store@11.1.2/node_modules/@libp2p/peer-store/dist/src/constants.js
var MAX_ADDRESS_AGE = 36e5;
var MAX_PEER_AGE = 216e5;

// node_modules/.pnpm/@libp2p+peer-store@11.1.2/node_modules/@libp2p/peer-store/dist/src/pb/peer.js
var Peer;
(function(Peer2) {
  let Peer$metadataEntry;
  (function(Peer$metadataEntry2) {
    let _codec2;
    Peer$metadataEntry2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.key != null && obj.key !== "") {
            w2.uint32(10);
            w2.string(obj.key);
          }
          if (obj.value != null && obj.value.byteLength > 0) {
            w2.uint32(18);
            w2.bytes(obj.value);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length, opts = {}) => {
          const obj = {
            key: "",
            value: alloc(0)
          };
          const end = length == null ? reader.len : reader.pos + length;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.key = reader.string();
                break;
              }
              case 2: {
                obj.value = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer$metadataEntry2.encode = (obj) => {
      return encodeMessage(obj, Peer$metadataEntry2.codec());
    };
    Peer$metadataEntry2.decode = (buf, opts) => {
      return decodeMessage(buf, Peer$metadataEntry2.codec(), opts);
    };
  })(Peer$metadataEntry = Peer2.Peer$metadataEntry || (Peer2.Peer$metadataEntry = {}));
  let Peer$tagsEntry;
  (function(Peer$tagsEntry2) {
    let _codec2;
    Peer$tagsEntry2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.key != null && obj.key !== "") {
            w2.uint32(10);
            w2.string(obj.key);
          }
          if (obj.value != null) {
            w2.uint32(18);
            Tag.codec().encode(obj.value, w2);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length, opts = {}) => {
          var _a12;
          const obj = {
            key: ""
          };
          const end = length == null ? reader.len : reader.pos + length;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.key = reader.string();
                break;
              }
              case 2: {
                obj.value = Tag.codec().decode(reader, reader.uint32(), {
                  limits: (_a12 = opts.limits) == null ? void 0 : _a12.value
                });
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer$tagsEntry2.encode = (obj) => {
      return encodeMessage(obj, Peer$tagsEntry2.codec());
    };
    Peer$tagsEntry2.decode = (buf, opts) => {
      return decodeMessage(buf, Peer$tagsEntry2.codec(), opts);
    };
  })(Peer$tagsEntry = Peer2.Peer$tagsEntry || (Peer2.Peer$tagsEntry = {}));
  let _codec;
  Peer2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.addresses != null) {
          for (const value of obj.addresses) {
            w2.uint32(10);
            Address.codec().encode(value, w2);
          }
        }
        if (obj.protocols != null) {
          for (const value of obj.protocols) {
            w2.uint32(18);
            w2.string(value);
          }
        }
        if (obj.publicKey != null) {
          w2.uint32(34);
          w2.bytes(obj.publicKey);
        }
        if (obj.peerRecordEnvelope != null) {
          w2.uint32(42);
          w2.bytes(obj.peerRecordEnvelope);
        }
        if (obj.metadata != null && obj.metadata.size !== 0) {
          for (const [key, value] of obj.metadata.entries()) {
            w2.uint32(50);
            Peer2.Peer$metadataEntry.codec().encode({ key, value }, w2);
          }
        }
        if (obj.tags != null && obj.tags.size !== 0) {
          for (const [key, value] of obj.tags.entries()) {
            w2.uint32(58);
            Peer2.Peer$tagsEntry.codec().encode({ key, value }, w2);
          }
        }
        if (obj.updated != null) {
          w2.uint32(64);
          w2.uint64Number(obj.updated);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length, opts = {}) => {
        var _a12, _b4, _c, _d, _e, _f;
        const obj = {
          addresses: [],
          protocols: [],
          metadata: /* @__PURE__ */ new Map(),
          tags: /* @__PURE__ */ new Map()
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (((_a12 = opts.limits) == null ? void 0 : _a12.addresses) != null && obj.addresses.length === opts.limits.addresses) {
                throw new MaxLengthError('Decode error - map field "addresses" had too many elements');
              }
              obj.addresses.push(Address.codec().decode(reader, reader.uint32(), {
                limits: (_b4 = opts.limits) == null ? void 0 : _b4.addresses$
              }));
              break;
            }
            case 2: {
              if (((_c = opts.limits) == null ? void 0 : _c.protocols) != null && obj.protocols.length === opts.limits.protocols) {
                throw new MaxLengthError('Decode error - map field "protocols" had too many elements');
              }
              obj.protocols.push(reader.string());
              break;
            }
            case 4: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 5: {
              obj.peerRecordEnvelope = reader.bytes();
              break;
            }
            case 6: {
              if (((_d = opts.limits) == null ? void 0 : _d.metadata) != null && obj.metadata.size === opts.limits.metadata) {
                throw new MaxSizeError('Decode error - map field "metadata" had too many elements');
              }
              const entry = Peer2.Peer$metadataEntry.codec().decode(reader, reader.uint32());
              obj.metadata.set(entry.key, entry.value);
              break;
            }
            case 7: {
              if (((_e = opts.limits) == null ? void 0 : _e.tags) != null && obj.tags.size === opts.limits.tags) {
                throw new MaxSizeError('Decode error - map field "tags" had too many elements');
              }
              const entry = Peer2.Peer$tagsEntry.codec().decode(reader, reader.uint32(), {
                limits: {
                  value: (_f = opts.limits) == null ? void 0 : _f.tags$value
                }
              });
              obj.tags.set(entry.key, entry.value);
              break;
            }
            case 8: {
              obj.updated = reader.uint64Number();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer2.encode = (obj) => {
    return encodeMessage(obj, Peer2.codec());
  };
  Peer2.decode = (buf, opts) => {
    return decodeMessage(buf, Peer2.codec(), opts);
  };
})(Peer || (Peer = {}));
var Address;
(function(Address2) {
  let _codec;
  Address2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.multiaddr);
        }
        if (obj.isCertified != null) {
          w2.uint32(16);
          w2.bool(obj.isCertified);
        }
        if (obj.observed != null) {
          w2.uint32(24);
          w2.uint64Number(obj.observed);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {
          multiaddr: alloc(0)
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.multiaddr = reader.bytes();
              break;
            }
            case 2: {
              obj.isCertified = reader.bool();
              break;
            }
            case 3: {
              obj.observed = reader.uint64Number();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Address2.encode = (obj) => {
    return encodeMessage(obj, Address2.codec());
  };
  Address2.decode = (buf, opts) => {
    return decodeMessage(buf, Address2.codec(), opts);
  };
})(Address || (Address = {}));
var Tag;
(function(Tag2) {
  let _codec;
  Tag2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.value != null && obj.value !== 0) {
          w2.uint32(8);
          w2.uint32(obj.value);
        }
        if (obj.expiry != null) {
          w2.uint32(16);
          w2.uint64(obj.expiry);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {
          value: 0
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.value = reader.uint32();
              break;
            }
            case 2: {
              obj.expiry = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Tag2.encode = (obj) => {
    return encodeMessage(obj, Tag2.codec());
  };
  Tag2.decode = (buf, opts) => {
    return decodeMessage(buf, Tag2.codec(), opts);
  };
})(Tag || (Tag = {}));

// node_modules/.pnpm/@libp2p+peer-store@11.1.2/node_modules/@libp2p/peer-store/dist/src/utils/bytes-to-peer.js
function populatePublicKey(peerId, protobuf) {
  if (peerId.publicKey != null || protobuf.publicKey == null) {
    return peerId;
  }
  let digest;
  if (peerId.type === "RSA") {
    const multihash = base58btc.decode(`z${peerId}`);
    digest = decode(multihash);
  }
  const publicKey = publicKeyFromProtobuf(protobuf.publicKey, digest);
  return peerIdFromPublicKey(publicKey);
}
function bytesToPeer(peerId, buf, maxAddressAge) {
  const peer = Peer.decode(buf);
  return pbToPeer(peerId, peer, maxAddressAge);
}
function pbToPeer(peerId, peer, maxAddressAge) {
  const tags = /* @__PURE__ */ new Map();
  const now = BigInt(Date.now());
  for (const [key, tag] of peer.tags.entries()) {
    if (tag.expiry != null && tag.expiry < now) {
      continue;
    }
    tags.set(key, tag);
  }
  return {
    ...peer,
    id: populatePublicKey(peerId, peer),
    addresses: peer.addresses.filter(({ observed }) => observed != null && observed > Date.now() - maxAddressAge).map(({ multiaddr: ma, isCertified }) => {
      return {
        multiaddr: multiaddr(ma),
        isCertified: isCertified ?? false
      };
    }),
    metadata: peer.metadata,
    peerRecordEnvelope: peer.peerRecordEnvelope ?? void 0,
    tags
  };
}

// node_modules/.pnpm/@libp2p+peer-store@11.1.2/node_modules/@libp2p/peer-store/dist/src/utils/peer-equals.js
function peerEquals(peerA, peerB) {
  return addressesEqual(peerA.addresses, peerB.addresses) && protocolsEqual(peerA.protocols, peerB.protocols) && publicKeyEqual(peerA.publicKey, peerB.publicKey) && peerRecordEnvelope(peerA.peerRecordEnvelope, peerB.peerRecordEnvelope) && metadataEqual(peerA.metadata, peerB.metadata) && tagsEqual(peerA.tags, peerB.tags);
}
function addressesEqual(addressesA, addressesB) {
  return compareArrays(addressesA, addressesB, (a, b) => {
    if (a.isCertified !== b.isCertified) {
      return false;
    }
    if (!equals(a.multiaddr, b.multiaddr)) {
      return false;
    }
    return true;
  });
}
function protocolsEqual(protocolsA, protocolsB) {
  return compareArrays(protocolsA, protocolsB, (a, b) => a === b);
}
function publicKeyEqual(publicKeyA, publicKeyB) {
  return compareOptionalUint8Arrays(publicKeyA, publicKeyB);
}
function peerRecordEnvelope(envelopeA, envelopeB) {
  return compareOptionalUint8Arrays(envelopeA, envelopeB);
}
function metadataEqual(metadataA, metadataB) {
  return compareMaps(metadataA, metadataB, (a, b) => equals(a, b));
}
function tagsEqual(metadataA, metadataB) {
  return compareMaps(metadataA, metadataB, (a, b) => a.value === b.value && a.expiry === b.expiry);
}
function compareOptionalUint8Arrays(arrA, arrB) {
  if (arrA == null && arrB == null) {
    return true;
  }
  if (arrA != null && arrB != null) {
    return equals(arrA, arrB);
  }
  return false;
}
function compareArrays(arrA, arrB, compare) {
  if (arrA.length !== arrB.length) {
    return false;
  }
  for (let i = 0; i < arrA.length; i++) {
    if (!compare(arrA[i], arrB[i])) {
      return false;
    }
  }
  return true;
}
function compareMaps(mapA, mapB, compare) {
  if (mapA.size !== mapB.size) {
    return false;
  }
  for (const [key, value] of mapA.entries()) {
    const valueB = mapB.get(key);
    if (valueB == null) {
      return false;
    }
    if (!compare(value, valueB)) {
      return false;
    }
  }
  return true;
}

// node_modules/.pnpm/@libp2p+peer-store@11.1.2/node_modules/@libp2p/peer-store/dist/src/utils/peer-id-to-datastore-key.js
var NAMESPACE_COMMON = "/peers/";
function peerIdToDatastoreKey(peerId) {
  if (!isPeerId(peerId) || peerId.type == null) {
    throw new InvalidParametersError("Invalid PeerId");
  }
  const b32key = peerId.toCID().toString();
  return new Key(`${NAMESPACE_COMMON}${b32key}`);
}

// node_modules/.pnpm/@libp2p+peer-store@11.1.2/node_modules/@libp2p/peer-store/dist/src/utils/dedupe-addresses.js
async function dedupeFilterAndSortAddresses(peerId, filter2, addresses, existingAddresses) {
  const addressMap = /* @__PURE__ */ new Map();
  for (const addr of addresses) {
    if (addr == null) {
      continue;
    }
    if (addr.multiaddr instanceof Uint8Array) {
      addr.multiaddr = multiaddr(addr.multiaddr);
    }
    if (!isMultiaddr(addr.multiaddr)) {
      throw new InvalidParametersError("Multiaddr was invalid");
    }
    if (!await filter2(peerId, addr.multiaddr)) {
      continue;
    }
    const isCertified = addr.isCertified ?? false;
    const maStr = addr.multiaddr.toString();
    const existingAddr = addressMap.get(maStr);
    if (existingAddr != null) {
      addr.isCertified = existingAddr.isCertified || isCertified;
    } else {
      addressMap.set(maStr, {
        multiaddr: addr.multiaddr,
        isCertified
      });
    }
  }
  return [...addressMap.values()].sort((a, b) => {
    return a.multiaddr.toString().localeCompare(b.multiaddr.toString());
  }).map(({ isCertified, multiaddr: multiaddr2 }) => ({
    isCertified,
    multiaddr: multiaddr2.bytes
  }));
}

// node_modules/.pnpm/@libp2p+peer-store@11.1.2/node_modules/@libp2p/peer-store/dist/src/utils/to-peer-pb.js
async function toPeerPB(peerId, data, strategy, options) {
  var _a12, _b4;
  if (data == null) {
    throw new InvalidParametersError("Invalid PeerData");
  }
  if (data.publicKey != null && peerId.publicKey != null && !data.publicKey.equals(peerId.publicKey)) {
    throw new InvalidParametersError("publicKey bytes do not match peer id publicKey bytes");
  }
  const existingPeer = (_a12 = options.existingPeer) == null ? void 0 : _a12.peer;
  if (existingPeer != null && !peerId.equals(existingPeer.id)) {
    throw new InvalidParametersError("peer id did not match existing peer id");
  }
  let addresses = (existingPeer == null ? void 0 : existingPeer.addresses) ?? [];
  let protocols = new Set((existingPeer == null ? void 0 : existingPeer.protocols) ?? []);
  let metadata = (existingPeer == null ? void 0 : existingPeer.metadata) ?? /* @__PURE__ */ new Map();
  let tags = (existingPeer == null ? void 0 : existingPeer.tags) ?? /* @__PURE__ */ new Map();
  let peerRecordEnvelope2 = existingPeer == null ? void 0 : existingPeer.peerRecordEnvelope;
  if (strategy === "patch") {
    if (data.multiaddrs != null || data.addresses != null) {
      addresses = [];
      if (data.multiaddrs != null) {
        addresses.push(...data.multiaddrs.map((multiaddr2) => ({
          isCertified: false,
          multiaddr: multiaddr2
        })));
      }
      if (data.addresses != null) {
        addresses.push(...data.addresses);
      }
    }
    if (data.protocols != null) {
      protocols = new Set(data.protocols);
    }
    if (data.metadata != null) {
      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
      metadata = createSortedMap(metadataEntries, {
        validate: validateMetadata
      });
    }
    if (data.tags != null) {
      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
      tags = createSortedMap(tagsEntries, {
        validate: validateTag,
        map: mapTag
      });
    }
    if (data.peerRecordEnvelope != null) {
      peerRecordEnvelope2 = data.peerRecordEnvelope;
    }
  }
  if (strategy === "merge") {
    if (data.multiaddrs != null) {
      addresses.push(...data.multiaddrs.map((multiaddr2) => ({
        isCertified: false,
        multiaddr: multiaddr2
      })));
    }
    if (data.addresses != null) {
      addresses.push(...data.addresses);
    }
    if (data.protocols != null) {
      protocols = /* @__PURE__ */ new Set([...protocols, ...data.protocols]);
    }
    if (data.metadata != null) {
      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
      for (const [key, value] of metadataEntries) {
        if (value == null) {
          metadata.delete(key);
        } else {
          metadata.set(key, value);
        }
      }
      metadata = createSortedMap([...metadata.entries()], {
        validate: validateMetadata
      });
    }
    if (data.tags != null) {
      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
      const mergedTags = new Map(tags);
      for (const [key, value] of tagsEntries) {
        if (value == null) {
          mergedTags.delete(key);
        } else {
          mergedTags.set(key, value);
        }
      }
      tags = createSortedMap([...mergedTags.entries()], {
        validate: validateTag,
        map: mapTag
      });
    }
    if (data.peerRecordEnvelope != null) {
      peerRecordEnvelope2 = data.peerRecordEnvelope;
    }
  }
  let publicKey;
  if ((existingPeer == null ? void 0 : existingPeer.id.publicKey) != null) {
    publicKey = publicKeyToProtobuf(existingPeer.id.publicKey);
  } else if (data.publicKey != null) {
    publicKey = publicKeyToProtobuf(data.publicKey);
  } else if (peerId.publicKey != null) {
    publicKey = publicKeyToProtobuf(peerId.publicKey);
  }
  const output = {
    addresses: await dedupeFilterAndSortAddresses(peerId, options.addressFilter ?? (async () => true), addresses, (_b4 = options.existingPeer) == null ? void 0 : _b4.peerPB.addresses),
    protocols: [...protocols.values()].sort((a, b) => {
      return a.localeCompare(b);
    }),
    metadata,
    tags,
    publicKey,
    peerRecordEnvelope: peerRecordEnvelope2
  };
  output.addresses.forEach((addr) => {
    var _a13, _b5, _c;
    addr.observed = ((_c = (_b5 = (_a13 = options.existingPeer) == null ? void 0 : _a13.peerPB.addresses) == null ? void 0 : _b5.find((addr2) => equals(addr2.multiaddr, addr2.multiaddr))) == null ? void 0 : _c.observed) ?? Date.now();
  });
  if (peerId.type !== "RSA") {
    delete output.publicKey;
  }
  return output;
}
function createSortedMap(entries, options) {
  var _a12;
  const output = /* @__PURE__ */ new Map();
  for (const [key, value] of entries) {
    if (value == null) {
      continue;
    }
    options.validate(key, value);
  }
  for (const [key, value] of entries.sort(([a], [b]) => {
    return a.localeCompare(b);
  })) {
    if (value != null) {
      output.set(key, ((_a12 = options.map) == null ? void 0 : _a12.call(options, key, value)) ?? value);
    }
  }
  return output;
}
function validateMetadata(key, value) {
  if (typeof key !== "string") {
    throw new InvalidParametersError("Metadata key must be a string");
  }
  if (!(value instanceof Uint8Array)) {
    throw new InvalidParametersError("Metadata value must be a Uint8Array");
  }
}
function validateTag(key, tag) {
  if (typeof key !== "string") {
    throw new InvalidParametersError("Tag name must be a string");
  }
  if (tag.value != null) {
    if (parseInt(`${tag.value}`, 10) !== tag.value) {
      throw new InvalidParametersError("Tag value must be an integer");
    }
    if (tag.value < 0 || tag.value > 100) {
      throw new InvalidParametersError("Tag value must be between 0-100");
    }
  }
  if (tag.ttl != null) {
    if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) {
      throw new InvalidParametersError("Tag ttl must be an integer");
    }
    if (tag.ttl < 0) {
      throw new InvalidParametersError("Tag ttl must be between greater than 0");
    }
  }
}
function mapTag(key, tag) {
  let expiry;
  if (tag.expiry != null) {
    expiry = tag.expiry;
  }
  if (tag.ttl != null) {
    expiry = BigInt(Date.now() + Number(tag.ttl));
  }
  return {
    value: tag.value ?? 0,
    expiry
  };
}

// node_modules/.pnpm/@libp2p+peer-store@11.1.2/node_modules/@libp2p/peer-store/dist/src/store.js
function keyToPeerId(key) {
  const base32Str = key.toString().split("/")[2];
  const buf = CID.parse(base32Str, base32);
  return peerIdFromCID(buf);
}
function decodePeer(key, value, maxAddressAge) {
  const peerId = keyToPeerId(key);
  return bytesToPeer(peerId, value, maxAddressAge);
}
function mapQuery(query, maxAddressAge) {
  return {
    prefix: NAMESPACE_COMMON,
    filters: (query.filters ?? []).map((fn) => ({ key, value }) => {
      return fn(decodePeer(key, value, maxAddressAge));
    }),
    orders: (query.orders ?? []).map((fn) => (a, b) => {
      return fn(decodePeer(a.key, a.value, maxAddressAge), decodePeer(b.key, b.value, maxAddressAge));
    })
  };
}
var _PersistentStore_instances, findExistingPeer_fn, saveIfDifferent_fn, peerIsExpired_fn;
var PersistentStore = class {
  constructor(components, init = {}) {
    __privateAdd(this, _PersistentStore_instances);
    __publicField(this, "peerId");
    __publicField(this, "datastore");
    __publicField(this, "lock");
    __publicField(this, "addressFilter");
    __publicField(this, "log");
    __publicField(this, "maxAddressAge");
    __publicField(this, "maxPeerAge");
    this.log = components.logger.forComponent("libp2p:peer-store");
    this.peerId = components.peerId;
    this.datastore = components.datastore;
    this.addressFilter = init.addressFilter;
    this.lock = createMortice({
      name: "peer-store",
      singleProcess: true
    });
    this.maxAddressAge = init.maxAddressAge ?? MAX_ADDRESS_AGE;
    this.maxPeerAge = init.maxPeerAge ?? MAX_PEER_AGE;
  }
  async has(peerId) {
    try {
      await this.load(peerId);
      return true;
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    return false;
  }
  async delete(peerId) {
    if (this.peerId.equals(peerId)) {
      return;
    }
    await this.datastore.delete(peerIdToDatastoreKey(peerId));
  }
  async load(peerId) {
    const key = peerIdToDatastoreKey(peerId);
    const buf = await this.datastore.get(key);
    const peer = Peer.decode(buf);
    if (__privateMethod(this, _PersistentStore_instances, peerIsExpired_fn).call(this, peerId, peer)) {
      await this.datastore.delete(key);
      throw new NotFoundError();
    }
    return pbToPeer(peerId, peer, this.peerId.equals(peerId) ? Infinity : this.maxAddressAge);
  }
  async save(peerId, data) {
    const existingPeer = await __privateMethod(this, _PersistentStore_instances, findExistingPeer_fn).call(this, peerId);
    const peerPb = await toPeerPB(peerId, data, "patch", {
      addressFilter: this.addressFilter
    });
    return __privateMethod(this, _PersistentStore_instances, saveIfDifferent_fn).call(this, peerId, peerPb, existingPeer);
  }
  async patch(peerId, data) {
    const existingPeer = await __privateMethod(this, _PersistentStore_instances, findExistingPeer_fn).call(this, peerId);
    const peerPb = await toPeerPB(peerId, data, "patch", {
      addressFilter: this.addressFilter,
      existingPeer
    });
    return __privateMethod(this, _PersistentStore_instances, saveIfDifferent_fn).call(this, peerId, peerPb, existingPeer);
  }
  async merge(peerId, data) {
    const existingPeer = await __privateMethod(this, _PersistentStore_instances, findExistingPeer_fn).call(this, peerId);
    const peerPb = await toPeerPB(peerId, data, "merge", {
      addressFilter: this.addressFilter,
      existingPeer
    });
    return __privateMethod(this, _PersistentStore_instances, saveIfDifferent_fn).call(this, peerId, peerPb, existingPeer);
  }
  async *all(query) {
    for await (const { key, value } of this.datastore.query(mapQuery(query ?? {}, this.maxAddressAge))) {
      const peerId = keyToPeerId(key);
      if (peerId.equals(this.peerId)) {
        continue;
      }
      const peer = Peer.decode(value);
      if (__privateMethod(this, _PersistentStore_instances, peerIsExpired_fn).call(this, peerId, peer)) {
        await this.datastore.delete(key);
        continue;
      }
      yield pbToPeer(peerId, peer, this.peerId.equals(peerId) ? Infinity : this.maxAddressAge);
    }
  }
};
_PersistentStore_instances = new WeakSet();
findExistingPeer_fn = async function(peerId) {
  try {
    const key = peerIdToDatastoreKey(peerId);
    const buf = await this.datastore.get(key);
    const peerPB = Peer.decode(buf);
    if (__privateMethod(this, _PersistentStore_instances, peerIsExpired_fn).call(this, peerId, peerPB)) {
      await this.datastore.delete(key);
      throw new NotFoundError();
    }
    return {
      peerPB,
      peer: bytesToPeer(peerId, buf, this.maxAddressAge)
    };
  } catch (err) {
    if (err.name !== "NotFoundError") {
      this.log.error("invalid peer data found in peer store - %e", err);
    }
  }
};
saveIfDifferent_fn = async function(peerId, peer, existingPeer) {
  peer.updated = Date.now();
  const buf = Peer.encode(peer);
  await this.datastore.put(peerIdToDatastoreKey(peerId), buf);
  return {
    peer: bytesToPeer(peerId, buf, this.maxAddressAge),
    previous: existingPeer == null ? void 0 : existingPeer.peer,
    updated: existingPeer == null || !peerEquals(peer, existingPeer.peerPB)
  };
};
peerIsExpired_fn = function(peerId, peer) {
  if (peer.updated == null) {
    return true;
  }
  if (this.peerId.equals(peerId)) {
    return false;
  }
  const expired = peer.updated < Date.now() - this.maxPeerAge;
  const minAddressObserved = Date.now() - this.maxAddressAge;
  const addrs = peer.addresses.filter((addr) => {
    return addr.observed != null && addr.observed > minAddressObserved;
  });
  return expired && addrs.length === 0;
};

// node_modules/.pnpm/@libp2p+peer-store@11.1.2/node_modules/@libp2p/peer-store/dist/src/index.js
var _a, _PersistentPeerStore_instances, emitIfUpdated_fn;
_a = Symbol.toStringTag;
var PersistentPeerStore = class {
  constructor(components, init = {}) {
    __privateAdd(this, _PersistentPeerStore_instances);
    __publicField(this, "store");
    __publicField(this, "events");
    __publicField(this, "peerId");
    __publicField(this, "log");
    __publicField(this, _a, "@libp2p/peer-store");
    this.log = components.logger.forComponent("libp2p:peer-store");
    this.events = components.events;
    this.peerId = components.peerId;
    this.store = new PersistentStore(components, init);
  }
  async forEach(fn, query) {
    this.log.trace("forEach await read lock");
    const release = await this.store.lock.readLock();
    this.log.trace("forEach got read lock");
    try {
      for await (const peer of this.store.all(query)) {
        fn(peer);
      }
    } finally {
      this.log.trace("forEach release read lock");
      release();
    }
  }
  async all(query) {
    this.log.trace("all await read lock");
    const release = await this.store.lock.readLock();
    this.log.trace("all got read lock");
    try {
      return await src_default5(this.store.all(query));
    } finally {
      this.log.trace("all release read lock");
      release();
    }
  }
  async delete(peerId) {
    this.log.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    this.log.trace("delete got write lock");
    try {
      await this.store.delete(peerId);
    } finally {
      this.log.trace("delete release write lock");
      release();
    }
  }
  async has(peerId) {
    this.log.trace("has await read lock");
    const release = await this.store.lock.readLock();
    this.log.trace("has got read lock");
    try {
      return await this.store.has(peerId);
    } finally {
      this.log.trace("has release read lock");
      release();
    }
  }
  async get(peerId) {
    this.log.trace("get await read lock");
    const release = await this.store.lock.readLock();
    this.log.trace("get got read lock");
    try {
      return await this.store.load(peerId);
    } finally {
      this.log.trace("get release read lock");
      release();
    }
  }
  async save(id, data) {
    this.log.trace("save await write lock");
    const release = await this.store.lock.writeLock();
    this.log.trace("save got write lock");
    try {
      const result = await this.store.save(id, data);
      __privateMethod(this, _PersistentPeerStore_instances, emitIfUpdated_fn).call(this, id, result);
      return result.peer;
    } finally {
      this.log.trace("save release write lock");
      release();
    }
  }
  async patch(id, data) {
    this.log.trace("patch await write lock");
    const release = await this.store.lock.writeLock();
    this.log.trace("patch got write lock");
    try {
      const result = await this.store.patch(id, data);
      __privateMethod(this, _PersistentPeerStore_instances, emitIfUpdated_fn).call(this, id, result);
      return result.peer;
    } finally {
      this.log.trace("patch release write lock");
      release();
    }
  }
  async merge(id, data) {
    this.log.trace("merge await write lock");
    const release = await this.store.lock.writeLock();
    this.log.trace("merge got write lock");
    try {
      const result = await this.store.merge(id, data);
      __privateMethod(this, _PersistentPeerStore_instances, emitIfUpdated_fn).call(this, id, result);
      return result.peer;
    } finally {
      this.log.trace("merge release write lock");
      release();
    }
  }
  async consumePeerRecord(buf, expectedPeer) {
    const envelope = await RecordEnvelope.openAndCertify(buf, PeerRecord2.DOMAIN);
    const peerId = peerIdFromCID(envelope.publicKey.toCID());
    if ((expectedPeer == null ? void 0 : expectedPeer.equals(peerId)) === false) {
      this.log("envelope peer id was not the expected peer id - expected: %p received: %p", expectedPeer, peerId);
      return false;
    }
    const peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
    let peer;
    try {
      peer = await this.get(peerId);
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    if ((peer == null ? void 0 : peer.peerRecordEnvelope) != null) {
      const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);
      const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
      if (storedRecord.seqNumber >= peerRecord.seqNumber) {
        this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
        return false;
      }
    }
    await this.patch(peerRecord.peerId, {
      peerRecordEnvelope: buf,
      addresses: peerRecord.multiaddrs.map((multiaddr2) => ({
        isCertified: true,
        multiaddr: multiaddr2
      }))
    });
    return true;
  }
};
_PersistentPeerStore_instances = new WeakSet();
emitIfUpdated_fn = function(id, result) {
  if (!result.updated) {
    return;
  }
  if (this.peerId.equals(id)) {
    this.events.safeDispatchEvent("self:peer:update", { detail: result });
  } else {
    this.events.safeDispatchEvent("peer:update", { detail: result });
  }
};
function persistentPeerStore(components, init = {}) {
  return new PersistentPeerStore(components, init);
}

// node_modules/.pnpm/interface-store@6.0.2/node_modules/interface-store/dist/src/errors.js
var _NotFoundError = class _NotFoundError extends Error {
  constructor(message2 = "Not Found") {
    super(message2);
    __publicField(this, "name", _NotFoundError.name);
    __publicField(this, "code", _NotFoundError.code);
  }
};
__publicField(_NotFoundError, "name", "NotFoundError");
__publicField(_NotFoundError, "code", "ERR_NOT_FOUND");
var NotFoundError2 = _NotFoundError;

// node_modules/.pnpm/it-filter@3.1.2/node_modules/it-filter/dist/src/index.js
function isAsyncIterable2(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function filter(source, fn) {
  let index = 0;
  if (isAsyncIterable2(source)) {
    return async function* () {
      for await (const entry of source) {
        if (await fn(entry, index++)) {
          yield entry;
        }
      }
    }();
  }
  const peekable = src_default3(source);
  const { value, done } = peekable.next();
  if (done === true) {
    return function* () {
    }();
  }
  const res = fn(value, index++);
  if (typeof res.then === "function") {
    return async function* () {
      if (await res) {
        yield value;
      }
      for await (const entry of peekable) {
        if (await fn(entry, index++)) {
          yield entry;
        }
      }
    }();
  }
  const func = fn;
  return function* () {
    if (res === true) {
      yield value;
    }
    for (const entry of peekable) {
      if (func(entry, index++)) {
        yield entry;
      }
    }
  }();
}
var src_default7 = filter;

// node_modules/.pnpm/it-sort@3.0.7/node_modules/it-sort/dist/src/index.js
function isAsyncIterable3(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function sort(source, sorter) {
  if (isAsyncIterable3(source)) {
    return async function* () {
      const arr = await src_default5(source);
      yield* arr.sort(sorter);
    }();
  }
  return function* () {
    const arr = src_default5(source);
    yield* arr.sort(sorter);
  }();
}
var src_default8 = sort;

// node_modules/.pnpm/it-take@3.0.7/node_modules/it-take/dist/src/index.js
function isAsyncIterable4(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function take(source, limit) {
  if (isAsyncIterable4(source)) {
    return async function* () {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for await (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    }();
  }
  return function* () {
    let items = 0;
    if (limit < 1) {
      return;
    }
    for (const entry of source) {
      yield entry;
      items++;
      if (items === limit) {
        return;
      }
    }
  }();
}
var src_default9 = take;

// node_modules/.pnpm/datastore-core@10.0.2/node_modules/datastore-core/dist/src/base.js
var BaseDatastore = class {
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options);
      yield key;
    }
  }
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield {
        key,
        value: await this.get(key, options)
      };
    }
  }
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({ key, value });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await src_default2(this.putMany(puts, options));
        puts = [];
        await src_default2(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  /**
   * Extending classes should override `query` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  /**
   * Extending classes should override `queryKeys` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = src_default7(it, (e) => e.key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => src_default7(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => src_default8(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      const offset = q.offset;
      it = src_default7(it, () => i++ >= offset);
    }
    if (q.limit != null) {
      it = src_default9(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = src_default7(it, (key) => key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => src_default7(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => src_default8(it2, f), it);
    }
    if (q.offset != null) {
      const offset = q.offset;
      let i = 0;
      it = src_default7(it, () => i++ >= offset);
    }
    if (q.limit != null) {
      it = src_default9(it, q.limit);
    }
    return it;
  }
};

// node_modules/.pnpm/datastore-core@10.0.2/node_modules/datastore-core/dist/src/memory.js
var MemoryDatastore = class extends BaseDatastore {
  constructor() {
    super();
    __publicField(this, "data");
    this.data = /* @__PURE__ */ new Map();
  }
  put(key, val) {
    this.data.set(key.toString(), val);
    return key;
  }
  get(key) {
    const result = this.data.get(key.toString());
    if (result == null) {
      throw new NotFoundError2();
    }
    return result;
  }
  has(key) {
    return this.data.has(key.toString());
  }
  delete(key) {
    this.data.delete(key.toString());
  }
  *_all() {
    for (const [key, value] of this.data.entries()) {
      yield { key: new Key(key), value };
    }
  }
  *_allKeys() {
    for (const key of this.data.keys()) {
      yield new Key(key);
    }
  }
};

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/debounce.js
function debounce(func, wait) {
  let timeout;
  const output = function() {
    const later = function() {
      timeout = void 0;
      void func();
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
  output.start = () => {
  };
  output.stop = () => {
    clearTimeout(timeout);
  };
  return output;
}

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/private-ip.js
var import_netmask = __toESM(require_netmask());
var PRIVATE_IP_RANGES = [
  "0.0.0.0/8",
  "10.0.0.0/8",
  "100.64.0.0/10",
  "127.0.0.0/8",
  "169.254.0.0/16",
  "172.16.0.0/12",
  "192.0.0.0/24",
  "192.0.0.0/29",
  "192.0.0.8/32",
  "192.0.0.9/32",
  "192.0.0.10/32",
  "192.0.0.170/32",
  "192.0.0.171/32",
  "192.0.2.0/24",
  "192.31.196.0/24",
  "192.52.193.0/24",
  "192.88.99.0/24",
  "192.168.0.0/16",
  "192.175.48.0/24",
  "198.18.0.0/15",
  "198.51.100.0/24",
  "203.0.113.0/24",
  "240.0.0.0/4",
  "255.255.255.255/32"
];
var NETMASK_RANGES = PRIVATE_IP_RANGES.map((ipRange) => new import_netmask.Netmask(ipRange));
function ipv4Check(ipAddr) {
  for (const r of NETMASK_RANGES) {
    if (r.contains(ipAddr))
      return true;
  }
  return false;
}
function isIpv4MappedIpv6(ipAddr) {
  return /^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(ipAddr);
}
function ipv4MappedIpv6Check(ipAddr) {
  const parts = ipAddr.split(":");
  if (parts.length < 2) {
    return false;
  }
  const octet34 = parts[parts.length - 1].padStart(4, "0");
  const octet12 = parts[parts.length - 2].padStart(4, "0");
  const ip4 = `${parseInt(octet12.substring(0, 2), 16)}.${parseInt(octet12.substring(2), 16)}.${parseInt(octet34.substring(0, 2), 16)}.${parseInt(octet34.substring(2), 16)}`;
  return ipv4Check(ip4);
}
function isIpv4EmbeddedIpv6(ipAddr) {
  return /^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr);
}
function ipv4EmbeddedIpv6Check(ipAddr) {
  const parts = ipAddr.split(":");
  const ip4 = parts[parts.length - 1];
  return ipv4Check(ip4);
}
function ipv6Check(ipAddr) {
  return /^::$/.test(ipAddr) || /^::1$/.test(ipAddr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ipAddr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ipAddr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ipAddr);
}
function isPrivateIp(ip) {
  if (isIPv4(ip))
    return ipv4Check(ip);
  else if (isIpv4MappedIpv6(ip))
    return ipv4MappedIpv6Check(ip);
  else if (isIpv4EmbeddedIpv6(ip))
    return ipv4EmbeddedIpv6Check(ip);
  else if (isIPv6(ip))
    return ipv6Check(ip);
  else
    return void 0;
}

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/address-manager/dns-mappings.js
var MAX_DATE = 864e13;
var CODEC_TLS = 448;
var CODEC_SNI = 449;
var CODEC_DNS = 53;
var CODEC_DNS4 = 54;
var CODEC_DNS6 = 55;
var CODEC_DNSADDR = 56;
var DNSMappings = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "mappings");
    this.log = components.logger.forComponent("libp2p:address-manager:dns-mappings");
    this.mappings = /* @__PURE__ */ new Map();
  }
  has(ma) {
    const host = this.findHost(ma);
    for (const mapping of this.mappings.values()) {
      if (mapping.domain === host) {
        return true;
      }
    }
    return false;
  }
  add(domain, addresses) {
    addresses.forEach((ip) => {
      this.log("add DNS mapping %s to %s", ip, domain);
      const verified = isPrivateIp(ip) === true;
      this.mappings.set(ip, {
        domain,
        verified,
        expires: verified ? MAX_DATE - Date.now() : 0,
        lastVerified: verified ? MAX_DATE - Date.now() : void 0
      });
    });
  }
  remove(ma) {
    const host = this.findHost(ma);
    let wasConfident = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === host) {
        this.log("removing %s to %s DNS mapping %e", ip, mapping.domain, new Error("where"));
        this.mappings.delete(ip);
        wasConfident = wasConfident || mapping.verified;
      }
    }
    return wasConfident;
  }
  getAll(addresses) {
    const dnsMappedAddresses = [];
    for (let i = 0; i < addresses.length; i++) {
      const address = addresses[i];
      const tuples = address.multiaddr.stringTuples();
      const host = tuples[0][1];
      if (host == null) {
        continue;
      }
      for (const [ip, mapping] of this.mappings.entries()) {
        if (host !== ip) {
          continue;
        }
        const mappedIp = this.maybeAddSNITuple(tuples, mapping.domain);
        if (mappedIp) {
          addresses.splice(i, 1);
          i--;
          dnsMappedAddresses.push({
            multiaddr: multiaddr(`/${tuples.map((tuple) => {
              return [
                getProtocol(tuple[0]).name,
                tuple[1]
              ].join("/");
            }).join("/")}`),
            verified: mapping.verified,
            type: "dns-mapping",
            expires: mapping.expires,
            lastVerified: mapping.lastVerified
          });
        }
      }
    }
    return dnsMappedAddresses;
  }
  maybeAddSNITuple(tuples, domain) {
    var _a12;
    for (let j = 0; j < tuples.length; j++) {
      if (tuples[j][0] === CODEC_TLS && ((_a12 = tuples[j + 1]) == null ? void 0 : _a12[0]) !== CODEC_SNI) {
        tuples.splice(j + 1, 0, [CODEC_SNI, domain]);
        return true;
      }
    }
    return false;
  }
  confirm(ma, ttl) {
    const host = this.findHost(ma);
    let startingConfidence = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === host) {
        this.log("marking %s to %s DNS mapping as verified", ip, mapping.domain);
        startingConfidence = mapping.verified;
        mapping.verified = true;
        mapping.expires = Date.now() + ttl;
        mapping.lastVerified = Date.now();
      }
    }
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    const host = this.findHost(ma);
    let wasConfident = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === host) {
        this.log("removing verification of %s to %s DNS mapping", ip, mapping.domain);
        wasConfident = wasConfident || mapping.verified;
        mapping.verified = false;
        mapping.expires = Date.now() + ttl;
      }
    }
    return wasConfident;
  }
  findHost(ma) {
    for (const tuple of ma.stringTuples()) {
      if (tuple[0] === CODEC_SNI) {
        return tuple[1];
      }
      if (tuple[0] === CODEC_DNS || tuple[0] === CODEC_DNS4 || tuple[0] === CODEC_DNS6 || tuple[0] === CODEC_DNSADDR) {
        return tuple[1];
      }
    }
  }
};

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/address-manager/ip-mappings.js
var CODEC_IP4 = 4;
var CODEC_IP6 = 41;
var CODEC_TCP = 6;
var CODEC_UDP = 273;
var IPMappings = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "mappings");
    this.log = components.logger.forComponent("libp2p:address-manager:ip-mappings");
    this.mappings = /* @__PURE__ */ new Map();
  }
  has(ma) {
    const tuples = ma.stringTuples();
    for (const mappings of this.mappings.values()) {
      for (const mapping of mappings) {
        if (mapping.externalIp === tuples[0][1]) {
          return true;
        }
      }
    }
    return false;
  }
  add(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
    const key = `${internalIp}-${internalPort}-${protocol}`;
    const mappings = this.mappings.get(key) ?? [];
    const mapping = {
      internalIp,
      internalPort,
      externalIp,
      externalPort,
      externalFamily: isIPv4(externalIp) ? 4 : 6,
      protocol,
      verified: false,
      expires: 0
    };
    mappings.push(mapping);
    this.mappings.set(key, mappings);
  }
  remove(ma) {
    const tuples = ma.stringTuples();
    const host = tuples[0][1] ?? "";
    const protocol = tuples[1][0] === CODEC_TCP ? "tcp" : "udp";
    const port = parseInt(tuples[1][1] ?? "0");
    let wasConfident = false;
    for (const [key, mappings] of this.mappings.entries()) {
      for (let i = 0; i < mappings.length; i++) {
        const mapping = mappings[i];
        if (mapping.externalIp === host && mapping.externalPort === port && mapping.protocol === protocol) {
          this.log("removing %s:%s to %s:%s %s IP mapping", mapping.externalIp, mapping.externalPort, host, port, protocol);
          wasConfident = wasConfident || mapping.verified;
          mappings.splice(i, 1);
          i--;
        }
      }
      if (mappings.length === 0) {
        this.mappings.delete(key);
      }
    }
    return wasConfident;
  }
  getAll(addresses) {
    const ipMappedAddresses = [];
    for (const { multiaddr: ma } of addresses) {
      const tuples = ma.stringTuples();
      let tuple;
      if ((tuples[0][0] === CODEC_IP4 || tuples[0][0] === CODEC_IP6) && tuples[1][0] === CODEC_TCP) {
        tuple = `${tuples[0][1]}-${tuples[1][1]}-tcp`;
      } else if ((tuples[0][0] === CODEC_IP4 || tuples[0][0] === CODEC_IP6) && tuples[1][0] === CODEC_UDP) {
        tuple = `${tuples[0][1]}-${tuples[1][1]}-udp`;
      }
      if (tuple == null) {
        continue;
      }
      const mappings = this.mappings.get(tuple);
      if (mappings == null) {
        continue;
      }
      for (const mapping of mappings) {
        tuples[0][0] = mapping.externalFamily === 4 ? CODEC_IP4 : CODEC_IP6;
        tuples[0][1] = mapping.externalIp;
        tuples[1][1] = `${mapping.externalPort}`;
        ipMappedAddresses.push({
          multiaddr: multiaddr(`/${tuples.map((tuple2) => {
            return [
              getProtocol(tuple2[0]).name,
              tuple2[1]
            ].join("/");
          }).join("/")}`),
          verified: mapping.verified,
          type: "ip-mapping",
          expires: mapping.expires,
          lastVerified: mapping.lastVerified
        });
      }
    }
    return ipMappedAddresses;
  }
  confirm(ma, ttl) {
    const tuples = ma.stringTuples();
    const host = tuples[0][1];
    let startingConfidence = false;
    for (const mappings of this.mappings.values()) {
      for (const mapping of mappings) {
        if (mapping.externalIp === host) {
          this.log("marking %s to %s IP mapping as verified", mapping.internalIp, mapping.externalIp);
          startingConfidence = mapping.verified;
          mapping.verified = true;
          mapping.expires = Date.now() + ttl;
          mapping.lastVerified = Date.now();
        }
      }
    }
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    const tuples = ma.stringTuples();
    const host = tuples[0][1] ?? "";
    const protocol = tuples[1][0] === CODEC_TCP ? "tcp" : "udp";
    const port = parseInt(tuples[1][1] ?? "0");
    let wasConfident = false;
    for (const mappings of this.mappings.values()) {
      for (let i = 0; i < mappings.length; i++) {
        const mapping = mappings[i];
        if (mapping.externalIp === host && mapping.externalPort === port && mapping.protocol === protocol) {
          this.log("removing verification of %s:%s to %s:%s %s IP mapping", mapping.externalIp, mapping.externalPort, host, port, protocol);
          wasConfident = wasConfident || mapping.verified;
          mapping.verified = false;
          mapping.expires = Date.now() + ttl;
        }
      }
    }
    return wasConfident;
  }
};

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/multiaddr/is-link-local.js
var CODEC_IP42 = 4;
var CODEC_IP62 = 41;
function isLinkLocal(ma) {
  try {
    const [[codec, value]] = ma.stringTuples();
    if (value == null) {
      return false;
    }
    if (codec === CODEC_IP42) {
      return value.startsWith("169.254.");
    }
    if (codec === CODEC_IP62) {
      return value.toLowerCase().startsWith("fe80");
    }
  } catch {
  }
  return false;
}

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/multiaddr/is-ip-based.js
var CODEC_IP43 = 4;
var CODEC_IP63 = 41;
function isIpBased(ma) {
  try {
    const [[codec]] = ma.stringTuples();
    return codec === CODEC_IP43 || codec === CODEC_IP63;
  } catch {
  }
  return false;
}

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/multiaddr/is-private.js
function isPrivate(ma) {
  try {
    if (!isIpBased(ma)) {
      return false;
    }
    const [[, value]] = ma.stringTuples();
    if (value == null) {
      return false;
    }
    return isPrivateIp(value) ?? false;
  } catch {
  }
  return true;
}

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/address-manager/observed-addresses.js
var defaultValues = {
  maxObservedAddresses: 10
};
var ObservedAddresses = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "addresses");
    __publicField(this, "maxObservedAddresses");
    this.log = components.logger.forComponent("libp2p:address-manager:observed-addresses");
    this.addresses = /* @__PURE__ */ new Map();
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses;
  }
  has(ma) {
    return this.addresses.has(ma.toString());
  }
  removePrefixed(prefix) {
    for (const key of this.addresses.keys()) {
      if (key.toString().startsWith(prefix)) {
        this.addresses.delete(key);
      }
    }
  }
  add(ma) {
    if (this.addresses.size === this.maxObservedAddresses) {
      return;
    }
    if (isPrivate(ma) || isLinkLocal(ma)) {
      return;
    }
    this.log("adding observed address %a", ma);
    this.addresses.set(ma.toString(), {
      verified: false,
      expires: 0
    });
  }
  getAll() {
    return Array.from(this.addresses).map(([ma, metadata]) => ({
      multiaddr: multiaddr(ma),
      verified: metadata.verified,
      type: "observed",
      expires: metadata.expires,
      lastVerified: metadata.lastVerified
    }));
  }
  remove(ma) {
    var _a12;
    const startingConfidence = ((_a12 = this.addresses.get(ma.toString())) == null ? void 0 : _a12.verified) ?? false;
    this.log("removing observed address %a", ma);
    this.addresses.delete(ma.toString());
    return startingConfidence;
  }
  confirm(ma, ttl) {
    const addrString = ma.toString();
    const metadata = this.addresses.get(addrString) ?? {
      verified: false,
      expires: Date.now() + ttl,
      lastVerified: Date.now()
    };
    const startingConfidence = metadata.verified;
    metadata.verified = true;
    metadata.expires = Date.now() + ttl;
    metadata.lastVerified = Date.now();
    this.log("marking observed address %a as verified", addrString);
    this.addresses.set(addrString, metadata);
    return startingConfidence;
  }
};

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/multiaddr/is-network-address.js
var CODEC_IP44 = 4;
var CODEC_IP64 = 41;
var CODEC_DNS2 = 53;
var CODEC_DNS42 = 54;
var CODEC_DNS62 = 55;
var CODEC_DNSADDR2 = 56;
var NETWORK_CODECS = [
  CODEC_IP44,
  CODEC_IP64,
  CODEC_DNS2,
  CODEC_DNS42,
  CODEC_DNS62,
  CODEC_DNSADDR2
];
function isNetworkAddress(ma) {
  try {
    const [[codec]] = ma.stringTuples();
    return NETWORK_CODECS.includes(codec);
  } catch {
  }
  return false;
}

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/address-manager/transport-addresses.js
var defaultValues2 = {
  maxObservedAddresses: 10
};
var TransportAddresses = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "addresses");
    __publicField(this, "maxObservedAddresses");
    this.log = components.logger.forComponent("libp2p:address-manager:observed-addresses");
    this.addresses = /* @__PURE__ */ new Map();
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues2.maxObservedAddresses;
  }
  get(multiaddr2, ttl) {
    if (isPrivate(multiaddr2)) {
      return {
        multiaddr: multiaddr2,
        verified: true,
        type: "transport",
        expires: Date.now() + ttl,
        lastVerified: Date.now()
      };
    }
    const key = this.toKey(multiaddr2);
    let metadata = this.addresses.get(key);
    if (metadata == null) {
      metadata = {
        verified: !isNetworkAddress(multiaddr2),
        expires: 0
      };
      this.addresses.set(key, metadata);
    }
    return {
      multiaddr: multiaddr2,
      verified: metadata.verified,
      type: "transport",
      expires: metadata.expires,
      lastVerified: metadata.lastVerified
    };
  }
  has(ma) {
    const key = this.toKey(ma);
    return this.addresses.has(key);
  }
  remove(ma) {
    var _a12;
    const key = this.toKey(ma);
    const startingConfidence = ((_a12 = this.addresses.get(key)) == null ? void 0 : _a12.verified) ?? false;
    this.log("removing observed address %a", ma);
    this.addresses.delete(key);
    return startingConfidence;
  }
  confirm(ma, ttl) {
    const key = this.toKey(ma);
    const metadata = this.addresses.get(key) ?? {
      verified: false,
      expires: 0,
      lastVerified: 0
    };
    const startingConfidence = metadata.verified;
    metadata.verified = true;
    metadata.expires = Date.now() + ttl;
    metadata.lastVerified = Date.now();
    this.addresses.set(key, metadata);
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    const key = this.toKey(ma);
    const metadata = this.addresses.get(key) ?? {
      verified: false,
      expires: 0
    };
    const startingConfidence = metadata.verified;
    metadata.verified = false;
    metadata.expires = Date.now() + ttl;
    this.addresses.set(key, metadata);
    return startingConfidence;
  }
  toKey(ma) {
    if (isNetworkAddress(ma)) {
      const options = ma.toOptions();
      return `${options.host}-${options.port}-${options.transport}`;
    }
    return ma.toString();
  }
};

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/address-manager/index.js
var ONE_MINUTE = 6e4;
var defaultValues3 = {
  maxObservedAddresses: 10,
  addressVerificationTTL: ONE_MINUTE * 10,
  addressVerificationRetry: ONE_MINUTE * 5
};
var defaultAddressFilter = (addrs) => addrs;
function stripPeerId(ma, peerId) {
  const observedPeerIdStr = ma.getPeerId();
  if (observedPeerIdStr != null) {
    const observedPeerId = peerIdFromString(observedPeerIdStr);
    if (observedPeerId.equals(peerId)) {
      ma = ma.decapsulate(multiaddr(`/p2p/${peerId.toString()}`));
    }
  }
  return ma;
}
var _a2;
_a2 = Symbol.toStringTag;
var AddressManager = class {
  /**
   * Responsible for managing the peer addresses.
   * Peers can specify their listen and announce addresses.
   * The listen addresses will be used by the libp2p transports to listen for new connections,
   * while the announce addresses will be used for the peer addresses' to other peers in the network.
   */
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "components");
    // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`
    __publicField(this, "listen");
    __publicField(this, "announce");
    __publicField(this, "appendAnnounce");
    __publicField(this, "announceFilter");
    __publicField(this, "observed");
    __publicField(this, "dnsMappings");
    __publicField(this, "ipMappings");
    __publicField(this, "transportAddresses");
    __publicField(this, "observedAddressFilter");
    __publicField(this, "addressVerificationTTL");
    __publicField(this, "addressVerificationRetry");
    __publicField(this, _a2, "@libp2p/address-manager");
    const { listen = [], announce = [], appendAnnounce = [] } = init;
    this.components = components;
    this.log = components.logger.forComponent("libp2p:address-manager");
    this.listen = listen.map((ma) => ma.toString());
    this.announce = new Set(announce.map((ma) => ma.toString()));
    this.appendAnnounce = new Set(appendAnnounce.map((ma) => ma.toString()));
    this.observed = new ObservedAddresses(components, init);
    this.dnsMappings = new DNSMappings(components, init);
    this.ipMappings = new IPMappings(components, init);
    this.transportAddresses = new TransportAddresses(components, init);
    this.announceFilter = init.announceFilter ?? defaultAddressFilter;
    this.observedAddressFilter = createScalableCuckooFilter(1024);
    this.addressVerificationTTL = init.addressVerificationTTL ?? defaultValues3.addressVerificationTTL;
    this.addressVerificationRetry = init.addressVerificationRetry ?? defaultValues3.addressVerificationRetry;
    this._updatePeerStoreAddresses = debounce(this._updatePeerStoreAddresses.bind(this), 1e3);
    components.events.addEventListener("transport:listening", () => {
      this._updatePeerStoreAddresses();
    });
    components.events.addEventListener("transport:close", () => {
      this._updatePeerStoreAddresses();
    });
  }
  _updatePeerStoreAddresses() {
    const addrs = this.getAddresses().map((ma) => {
      if (ma.getPeerId() === this.components.peerId.toString()) {
        return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`);
      }
      return ma;
    });
    this.components.peerStore.patch(this.components.peerId, {
      multiaddrs: addrs
    }).catch((err) => {
      this.log.error("error updating addresses", err);
    });
  }
  /**
   * Get peer listen multiaddrs
   */
  getListenAddrs() {
    return Array.from(this.listen).map((a) => multiaddr(a));
  }
  /**
   * Get peer announcing multiaddrs
   */
  getAnnounceAddrs() {
    return Array.from(this.announce).map((a) => multiaddr(a));
  }
  /**
   * Get peer announcing multiaddrs
   */
  getAppendAnnounceAddrs() {
    return Array.from(this.appendAnnounce).map((a) => multiaddr(a));
  }
  /**
   * Get observed multiaddrs
   */
  getObservedAddrs() {
    return this.observed.getAll().map((addr) => addr.multiaddr);
  }
  /**
   * Add peer observed addresses
   */
  addObservedAddr(addr) {
    const tuples = addr.stringTuples();
    const socketAddress = `${tuples[0][1]}:${tuples[1][1]}`;
    if (this.observedAddressFilter.has(socketAddress)) {
      return;
    }
    this.observedAddressFilter.add(socketAddress);
    addr = stripPeerId(addr, this.components.peerId);
    if (this.ipMappings.has(addr)) {
      return;
    }
    if (this.dnsMappings.has(addr)) {
      return;
    }
    this.observed.add(addr);
  }
  confirmObservedAddr(addr, options) {
    addr = stripPeerId(addr, this.components.peerId);
    let startingConfidence = true;
    if ((options == null ? void 0 : options.type) === "transport" || this.transportAddresses.has(addr)) {
      const transportStartingConfidence = this.transportAddresses.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
      if (!transportStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if ((options == null ? void 0 : options.type) === "dns-mapping" || this.dnsMappings.has(addr)) {
      const dnsMappingStartingConfidence = this.dnsMappings.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
      if (!dnsMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if ((options == null ? void 0 : options.type) === "ip-mapping" || this.ipMappings.has(addr)) {
      const ipMappingStartingConfidence = this.ipMappings.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
      if (!ipMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if ((options == null ? void 0 : options.type) === "observed" || this.observed.has(addr)) {
      if (this.maybeUpgradeToIPMapping(addr)) {
        this.ipMappings.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
        startingConfidence = false;
      } else {
        const observedStartingConfidence = this.observed.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
        if (!observedStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
    }
    if (!startingConfidence) {
      this._updatePeerStoreAddresses();
    }
  }
  removeObservedAddr(addr, options) {
    addr = stripPeerId(addr, this.components.peerId);
    let startingConfidence = false;
    if (this.observed.has(addr)) {
      const observedStartingConfidence = this.observed.remove(addr);
      if (!observedStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (this.transportAddresses.has(addr)) {
      const transportStartingConfidence = this.transportAddresses.unconfirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationRetry);
      if (!transportStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (this.dnsMappings.has(addr)) {
      const dnsMappingStartingConfidence = this.dnsMappings.unconfirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationRetry);
      if (!dnsMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (this.ipMappings.has(addr)) {
      const ipMappingStartingConfidence = this.ipMappings.unconfirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationRetry);
      if (!ipMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (startingConfidence) {
      this._updatePeerStoreAddresses();
    }
  }
  getAddresses() {
    const addresses = /* @__PURE__ */ new Set();
    const multiaddrs = this.getAddressesWithMetadata().filter((addr) => {
      if (!addr.verified) {
        return false;
      }
      const maStr = addr.multiaddr.toString();
      if (addresses.has(maStr)) {
        return false;
      }
      addresses.add(maStr);
      return true;
    }).map((address) => address.multiaddr);
    return this.announceFilter(multiaddrs.map((str) => {
      var _a12;
      const ma = multiaddr(str);
      if (((_a12 = ma.protos().pop()) == null ? void 0 : _a12.path) === true) {
        return ma;
      }
      if (ma.getPeerId() === this.components.peerId.toString()) {
        return ma;
      }
      return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);
    }));
  }
  getAddressesWithMetadata() {
    const announceMultiaddrs = this.getAnnounceAddrs();
    if (announceMultiaddrs.length > 0) {
      this.components.transportManager.getListeners().forEach((listener) => {
        listener.updateAnnounceAddrs(announceMultiaddrs);
      });
      return announceMultiaddrs.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        verified: true,
        type: "announce",
        expires: Date.now() + this.addressVerificationTTL,
        lastVerified: Date.now()
      }));
    }
    let addresses = [];
    addresses = addresses.concat(this.components.transportManager.getAddrs().map((multiaddr2) => this.transportAddresses.get(multiaddr2, this.addressVerificationTTL)));
    addresses = addresses.concat(this.getAppendAnnounceAddrs().map((multiaddr2) => ({
      multiaddr: multiaddr2,
      verified: true,
      type: "announce",
      expires: Date.now() + this.addressVerificationTTL,
      lastVerified: Date.now()
    })));
    addresses = addresses.concat(this.observed.getAll());
    addresses = addresses.concat(this.ipMappings.getAll(addresses));
    addresses = addresses.concat(this.dnsMappings.getAll(addresses));
    return addresses;
  }
  addDNSMapping(domain, addresses) {
    this.dnsMappings.add(domain, addresses);
  }
  removeDNSMapping(domain) {
    if (this.dnsMappings.remove(multiaddr(`/dns/${domain}`))) {
      this._updatePeerStoreAddresses();
    }
  }
  addPublicAddressMapping(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
    this.ipMappings.add(internalIp, internalPort, externalIp, externalPort, protocol);
    this.observed.removePrefixed(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`);
  }
  removePublicAddressMapping(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
    if (this.ipMappings.remove(multiaddr(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`))) {
      this._updatePeerStoreAddresses();
    }
  }
  /**
   * Where an external service (router, gateway, etc) is forwarding traffic to
   * us, attempt to add an IP mapping for the external address - this will
   * include the observed mapping in the address list where we also have a DNS
   * mapping for the external IP.
   *
   * Returns true if we added a new mapping
   */
  maybeUpgradeToIPMapping(ma) {
    if (this.ipMappings.has(ma)) {
      return false;
    }
    const maOptions = ma.toOptions();
    if (maOptions.family === 6 || maOptions.host === "127.0.0.1" || isPrivateIp(maOptions.host) === true) {
      return false;
    }
    const listeners = this.components.transportManager.getListeners();
    const transportMatchers = [
      (ma2) => WebSockets.exactMatch(ma2) || WebSocketsSecure.exactMatch(ma2),
      (ma2) => TCP.exactMatch(ma2),
      (ma2) => QUICV1.exactMatch(ma2)
    ];
    for (const matcher of transportMatchers) {
      if (!matcher(ma)) {
        continue;
      }
      const transportListeners = listeners.filter((listener) => {
        return listener.getAddrs().filter((ma2) => {
          return ma2.toOptions().family === 4 && matcher(ma2);
        }).length > 0;
      });
      if (transportListeners.length !== 1) {
        continue;
      }
      const linkLocalAddr = transportListeners[0].getAddrs().filter((ma2) => {
        return ma2.toOptions().host !== "127.0.0.1";
      }).pop();
      if (linkLocalAddr == null) {
        continue;
      }
      const linkLocalOptions = linkLocalAddr.toOptions();
      this.observed.remove(ma);
      this.ipMappings.add(linkLocalOptions.host, linkLocalOptions.port, maOptions.host, maOptions.port, maOptions.transport);
      return true;
    }
    return false;
  }
};

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/errors.js
var messages;
(function(messages2) {
  messages2["NOT_STARTED_YET"] = "The libp2p node is not started yet";
  messages2["NOT_FOUND"] = "Not found";
})(messages || (messages = {}));
var MissingServiceError = class extends Error {
  constructor(message2 = "Missing service") {
    super(message2);
    this.name = "MissingServiceError";
  }
};
var UnmetServiceDependenciesError = class extends Error {
  constructor(message2 = "Unmet service dependencies") {
    super(message2);
    this.name = "UnmetServiceDependenciesError";
  }
};
var NoContentRoutersError = class extends Error {
  constructor(message2 = "No content routers available") {
    super(message2);
    this.name = "NoContentRoutersError";
  }
};
var NoPeerRoutersError = class extends Error {
  constructor(message2 = "No peer routers available") {
    super(message2);
    this.name = "NoPeerRoutersError";
  }
};
var QueriedForSelfError = class extends Error {
  constructor(message2 = "Should not try to find self") {
    super(message2);
    this.name = "QueriedForSelfError";
  }
};
var UnhandledProtocolError = class extends Error {
  constructor(message2 = "Unhandled protocol error") {
    super(message2);
    this.name = "UnhandledProtocolError";
  }
};
var DuplicateProtocolHandlerError = class extends Error {
  constructor(message2 = "Duplicate protocol handler error") {
    super(message2);
    this.name = "DuplicateProtocolHandlerError";
  }
};
var DialDeniedError = class extends Error {
  constructor(message2 = "Dial denied error") {
    super(message2);
    this.name = "DialDeniedError";
  }
};
var UnsupportedListenAddressError = class extends Error {
  constructor(message2 = "No transport was configured to listen on this address") {
    super(message2);
    this.name = "UnsupportedListenAddressError";
  }
};
var UnsupportedListenAddressesError = class extends Error {
  constructor(message2 = "Configured listen addresses could not be listened on") {
    super(message2);
    this.name = "UnsupportedListenAddressesError";
  }
};
var NoValidAddressesError = class extends Error {
  constructor(message2 = "No valid addresses") {
    super(message2);
    this.name = "NoValidAddressesError";
  }
};
var ConnectionInterceptedError = class extends Error {
  constructor(message2 = "Connection intercepted") {
    super(message2);
    this.name = "ConnectionInterceptedError";
  }
};
var ConnectionDeniedError = class extends Error {
  constructor(message2 = "Connection denied") {
    super(message2);
    this.name = "ConnectionDeniedError";
  }
};
var MuxerUnavailableError = class extends Error {
  constructor(message2 = "Stream is not multiplexed") {
    super(message2);
    this.name = "MuxerUnavailableError";
  }
};
var EncryptionFailedError = class extends Error {
  constructor(message2 = "Encryption failed") {
    super(message2);
    this.name = "EncryptionFailedError";
  }
};
var TransportUnavailableError = class extends Error {
  constructor(message2 = "Transport unavailable") {
    super(message2);
    this.name = "TransportUnavailableError";
  }
};

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/components.js
var DefaultComponents = class {
  constructor(init = {}) {
    __publicField(this, "components", {});
    __publicField(this, "_started", false);
    this.components = {};
    for (const [key, value] of Object.entries(init)) {
      this.components[key] = value;
    }
    if (this.components.logger == null) {
      this.components.logger = defaultLogger();
    }
  }
  isStarted() {
    return this._started;
  }
  async _invokeStartableMethod(methodName) {
    await Promise.all(Object.values(this.components).filter((obj) => isStartable(obj)).map(async (startable) => {
      var _a12;
      await ((_a12 = startable[methodName]) == null ? void 0 : _a12.call(startable));
    }));
  }
  async beforeStart() {
    await this._invokeStartableMethod("beforeStart");
  }
  async start() {
    await this._invokeStartableMethod("start");
    this._started = true;
  }
  async afterStart() {
    await this._invokeStartableMethod("afterStart");
  }
  async beforeStop() {
    await this._invokeStartableMethod("beforeStop");
  }
  async stop() {
    await this._invokeStartableMethod("stop");
    this._started = false;
  }
  async afterStop() {
    await this._invokeStartableMethod("afterStop");
  }
};
var OPTIONAL_SERVICES = [
  "metrics",
  "connectionProtector",
  "dns"
];
var NON_SERVICE_PROPERTIES = [
  "components",
  "isStarted",
  "beforeStart",
  "start",
  "afterStart",
  "beforeStop",
  "stop",
  "afterStop",
  "then",
  "_invokeStartableMethod"
];
function defaultComponents(init = {}) {
  const components = new DefaultComponents(init);
  const proxy = new Proxy(components, {
    get(target, prop, receiver) {
      if (typeof prop === "string" && !NON_SERVICE_PROPERTIES.includes(prop)) {
        const service = components.components[prop];
        if (service == null && !OPTIONAL_SERVICES.includes(prop)) {
          throw new MissingServiceError(`${prop} not set`);
        }
        return service;
      }
      return Reflect.get(target, prop, receiver);
    },
    set(target, prop, value) {
      if (typeof prop === "string") {
        components.components[prop] = value;
      } else {
        Reflect.set(target, prop, value);
      }
      return true;
    }
  });
  return proxy;
}
function checkServiceDependencies(components) {
  const serviceCapabilities2 = {};
  for (const service of Object.values(components.components)) {
    for (const capability of getServiceCapabilities(service)) {
      serviceCapabilities2[capability] = true;
    }
  }
  for (const service of Object.values(components.components)) {
    for (const capability of getServiceDependencies(service)) {
      if (serviceCapabilities2[capability] !== true) {
        throw new UnmetServiceDependenciesError(`Service "${getServiceName(service)}" required capability "${capability}" but it was not provided by any component, you may need to add additional configuration when creating your node.`);
      }
    }
  }
}
function getServiceCapabilities(service) {
  if (Array.isArray(service == null ? void 0 : service[serviceCapabilities])) {
    return service[serviceCapabilities];
  }
  return [];
}
function getServiceDependencies(service) {
  if (Array.isArray(service == null ? void 0 : service[serviceDependencies])) {
    return service[serviceDependencies];
  }
  return [];
}
function getServiceName(service) {
  return (service == null ? void 0 : service[Symbol.toStringTag]) ?? (service == null ? void 0 : service.toString()) ?? "unknown";
}

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/config/connection-gater.browser.js
var CODEC_IP45 = 4;
var CODEC_IP65 = 41;
function connectionGater(gater = {}) {
  return {
    denyDialPeer: async () => false,
    denyDialMultiaddr: async (multiaddr2) => {
      if (WebSockets.matches(multiaddr2)) {
        return false;
      }
      const tuples = multiaddr2.stringTuples();
      if (tuples[0][0] === CODEC_IP45 || tuples[0][0] === CODEC_IP65) {
        return Boolean(isPrivateIp(`${tuples[0][1]}`));
      }
      return false;
    },
    denyInboundConnection: async () => false,
    denyOutboundConnection: async () => false,
    denyInboundEncryptedConnection: async () => false,
    denyOutboundEncryptedConnection: async () => false,
    denyInboundUpgradedConnection: async () => false,
    denyOutboundUpgradedConnection: async () => false,
    filterMultiaddrForPeer: async () => true,
    ...gater
  };
}

// node_modules/.pnpm/delay@6.0.0/node_modules/delay/index.js
var createAbortError = () => {
  const error = new Error("Delay aborted");
  error.name = "AbortError";
  return error;
};
var clearMethods = /* @__PURE__ */ new WeakMap();
function createDelay({ clearTimeout: defaultClear, setTimeout: defaultSet } = {}) {
  return (milliseconds, { value, signal } = {}) => {
    if (signal == null ? void 0 : signal.aborted) {
      return Promise.reject(createAbortError());
    }
    let timeoutId;
    let settle;
    let rejectFunction;
    const clear = defaultClear ?? clearTimeout;
    const signalListener = () => {
      clear(timeoutId);
      rejectFunction(createAbortError());
    };
    const cleanup = () => {
      if (signal) {
        signal.removeEventListener("abort", signalListener);
      }
    };
    const delayPromise = new Promise((resolve, reject) => {
      settle = () => {
        cleanup();
        resolve(value);
      };
      rejectFunction = reject;
      timeoutId = (defaultSet ?? setTimeout)(settle, milliseconds);
    });
    if (signal) {
      signal.addEventListener("abort", signalListener, { once: true });
    }
    clearMethods.set(delayPromise, () => {
      clear(timeoutId);
      timeoutId = null;
      settle();
    });
    return delayPromise;
  };
}
var delay = createDelay();
var delay_default = delay;

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/errors.js
var RateLimitError = class extends Error {
  constructor(message2 = "Rate limit exceeded", props) {
    super(message2);
    __publicField(this, "remainingPoints");
    __publicField(this, "msBeforeNext");
    __publicField(this, "consumedPoints");
    __publicField(this, "isFirstInDuration");
    this.name = "RateLimitError";
    this.remainingPoints = props.remainingPoints;
    this.msBeforeNext = props.msBeforeNext;
    this.consumedPoints = props.consumedPoints;
    this.isFirstInDuration = props.isFirstInDuration;
  }
};
var QueueFullError = class extends Error {
  constructor(message2 = "The queue was full") {
    super(message2);
    this.name = "QueueFullError";
  }
};
__publicField(QueueFullError, "name", "QueueFullError");

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/rate-limiter.js
var RateLimiter = class {
  constructor(opts = {}) {
    __publicField(this, "memoryStorage");
    __publicField(this, "points");
    __publicField(this, "duration");
    __publicField(this, "blockDuration");
    __publicField(this, "execEvenly");
    __publicField(this, "execEvenlyMinDelayMs");
    __publicField(this, "keyPrefix");
    this.points = opts.points ?? 4;
    this.duration = opts.duration ?? 1;
    this.blockDuration = opts.blockDuration ?? 0;
    this.execEvenly = opts.execEvenly ?? false;
    this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs ?? this.duration * 1e3 / this.points;
    this.keyPrefix = opts.keyPrefix ?? "rlflx";
    this.memoryStorage = new MemoryStorage();
  }
  async consume(key, pointsToConsume = 1, options = {}) {
    const rlKey = this.getKey(key);
    const secDuration = this._getKeySecDuration(options);
    let res = this.memoryStorage.incrby(rlKey, pointsToConsume, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    if (res.consumedPoints > this.points) {
      if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) {
        res = this.memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);
      }
      throw new RateLimitError("Rate limit exceeded", res);
    } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
      let delayMs = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
      if (delayMs < this.execEvenlyMinDelayMs) {
        delayMs = res.consumedPoints * this.execEvenlyMinDelayMs;
      }
      await delay_default(delayMs);
    }
    return res;
  }
  penalty(key, points = 1, options = {}) {
    const rlKey = this.getKey(key);
    const secDuration = this._getKeySecDuration(options);
    const res = this.memoryStorage.incrby(rlKey, points, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    return res;
  }
  reward(key, points = 1, options = {}) {
    const rlKey = this.getKey(key);
    const secDuration = this._getKeySecDuration(options);
    const res = this.memoryStorage.incrby(rlKey, -points, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    return res;
  }
  /**
   * Block any key for secDuration seconds
   *
   * @param key
   * @param secDuration
   */
  block(key, secDuration) {
    const msDuration = secDuration * 1e3;
    const initPoints = this.points + 1;
    this.memoryStorage.set(this.getKey(key), initPoints, secDuration);
    return {
      remainingPoints: 0,
      msBeforeNext: msDuration === 0 ? -1 : msDuration,
      consumedPoints: initPoints,
      isFirstInDuration: false
    };
  }
  set(key, points, secDuration = 0) {
    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
    this.memoryStorage.set(this.getKey(key), points, secDuration);
    return {
      remainingPoints: 0,
      msBeforeNext: msDuration === 0 ? -1 : msDuration,
      consumedPoints: points,
      isFirstInDuration: false
    };
  }
  get(key) {
    const res = this.memoryStorage.get(this.getKey(key));
    if (res != null) {
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    }
    return res;
  }
  delete(key) {
    this.memoryStorage.delete(this.getKey(key));
  }
  _getKeySecDuration(options) {
    if ((options == null ? void 0 : options.customDuration) != null && options.customDuration >= 0) {
      return options.customDuration;
    }
    return this.duration;
  }
  getKey(key) {
    return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;
  }
  parseKey(rlKey) {
    return rlKey.substring(this.keyPrefix.length);
  }
};
var MemoryStorage = class {
  constructor() {
    __publicField(this, "storage");
    this.storage = /* @__PURE__ */ new Map();
  }
  incrby(key, value, durationSec) {
    const existing = this.storage.get(key);
    if (existing != null) {
      const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
      if (existing.expiresAt == null || msBeforeExpires > 0) {
        existing.value += value;
        return {
          remainingPoints: 0,
          msBeforeNext: msBeforeExpires,
          consumedPoints: existing.value,
          isFirstInDuration: false
        };
      }
      return this.set(key, value, durationSec);
    }
    return this.set(key, value, durationSec);
  }
  set(key, value, durationSec) {
    const durationMs = durationSec * 1e3;
    const existing = this.storage.get(key);
    if (existing != null) {
      clearTimeout(existing.timeoutId);
    }
    const record = {
      value,
      expiresAt: durationMs > 0 ? new Date(Date.now() + durationMs) : void 0
    };
    this.storage.set(key, record);
    if (durationMs > 0) {
      record.timeoutId = setTimeout(() => {
        this.storage.delete(key);
      }, durationMs);
      if (record.timeoutId.unref != null) {
        record.timeoutId.unref();
      }
    }
    return {
      remainingPoints: 0,
      msBeforeNext: durationMs === 0 ? -1 : durationMs,
      consumedPoints: record.value,
      isFirstInDuration: true
    };
  }
  get(key) {
    const existing = this.storage.get(key);
    if (existing != null) {
      const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
      return {
        remainingPoints: 0,
        msBeforeNext: msBeforeExpires,
        consumedPoints: existing.value,
        isFirstInDuration: false
      };
    }
  }
  delete(key) {
    const record = this.storage.get(key);
    if (record != null) {
      if (record.timeoutId != null) {
        clearTimeout(record.timeoutId);
      }
      this.storage.delete(key);
      return true;
    }
    return false;
  }
};

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/get-peer.js
function getPeerAddress(peer) {
  if (isPeerId(peer)) {
    return { peerId: peer, multiaddrs: [] };
  }
  if (!Array.isArray(peer)) {
    peer = [peer];
  }
  let peerId;
  if (peer.length > 0) {
    const peerIdStr = peer[0].getPeerId();
    peerId = peerIdStr == null ? void 0 : peerIdFromString(peerIdStr);
    peer.forEach((ma) => {
      if (!isMultiaddr(ma)) {
        throw new InvalidMultiaddrError("Invalid multiaddr");
      }
      const maPeerIdStr = ma.getPeerId();
      if (maPeerIdStr == null) {
        if (peerId != null) {
          throw new InvalidParametersError("Multiaddrs must all have the same peer id or have no peer id");
        }
      } else {
        const maPeerId = peerIdFromString(maPeerIdStr);
        if ((peerId == null ? void 0 : peerId.equals(maPeerId)) !== true) {
          throw new InvalidParametersError("Multiaddrs must all have the same peer id or have no peer id");
        }
      }
    });
  }
  return {
    peerId,
    multiaddrs: peer
  };
}

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/close.js
var DEFAULT_CLOSABLE_PROTOCOLS = [
  // identify
  "/ipfs/id/1.0.0",
  // identify-push
  "/ipfs/id/push/1.0.0",
  // autonat
  "/libp2p/autonat/1.0.0",
  // dcutr
  "/libp2p/dcutr"
];
async function safelyCloseConnectionIfUnused(connection, options) {
  var _a12;
  const streamProtocols = ((_a12 = connection == null ? void 0 : connection.streams) == null ? void 0 : _a12.map((stream) => stream.protocol)) ?? [];
  const closableProtocols = (options == null ? void 0 : options.closableProtocols) ?? DEFAULT_CLOSABLE_PROTOCOLS;
  if (streamProtocols.filter((proto) => proto != null && !closableProtocols.includes(proto)).length > 0) {
    return;
  }
  try {
    await (connection == null ? void 0 : connection.close(options));
  } catch (err) {
    connection == null ? void 0 : connection.abort(err);
  }
}

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/connection-manager/constants.defaults.js
var DIAL_TIMEOUT = 1e4;
var INBOUND_UPGRADE_TIMEOUT = 1e4;
var PROTOCOL_NEGOTIATION_TIMEOUT = 1e4;
var MAX_PEER_ADDRS_TO_DIAL = 25;
var INBOUND_CONNECTION_THRESHOLD = 5;
var MAX_INCOMING_PENDING_CONNECTIONS = 10;
var MAX_PARALLEL_RECONNECTS = 5;
var LAST_DIAL_FAILURE_KEY = "last-dial-failure";
var LAST_DIAL_SUCCESS_KEY = "last-dial-success";
var MAX_DIAL_QUEUE_LENGTH = 500;

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/connection-manager/constants.browser.js
var MAX_CONNECTIONS = 100;
var MAX_PARALLEL_DIALS = 50;

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/connection-manager/utils.js
async function resolveMultiaddrs(ma, options) {
  let resolvable = false;
  for (const key of resolvers.keys()) {
    resolvable = ma.protoNames().includes(key);
    if (resolvable) {
      break;
    }
  }
  if (!resolvable) {
    return [ma];
  }
  const output = await ma.resolve(options);
  options.log("resolved %s to", ma, output.map((ma2) => ma2.toString()));
  return output;
}
function multiaddrToIpNet(ma) {
  try {
    let parsedMa;
    if (typeof ma === "string") {
      parsedMa = multiaddr(ma);
    } else {
      parsedMa = ma;
    }
    if (!parsedMa.protoNames().includes("ipcidr")) {
      const isIPv62 = parsedMa.protoNames().includes("ip6");
      const cidr = isIPv62 ? "/ipcidr/128" : "/ipcidr/32";
      parsedMa = parsedMa.encapsulate(cidr);
    }
    return convertToIpNet(parsedMa);
  } catch (error) {
    throw new Error(`Can't convert to IpNet, Invalid multiaddr format: ${ma}`);
  }
}

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/connection-manager/connection-pruner.js
var defaultOptions3 = {
  maxConnections: MAX_CONNECTIONS,
  allow: []
};
var ConnectionPruner = class {
  constructor(components, init = {}) {
    __publicField(this, "maxConnections");
    __publicField(this, "connectionManager");
    __publicField(this, "peerStore");
    __publicField(this, "allow");
    __publicField(this, "events");
    __publicField(this, "log");
    this.maxConnections = init.maxConnections ?? defaultOptions3.maxConnections;
    this.allow = (init.allow ?? []).map((ma) => multiaddrToIpNet(ma));
    this.connectionManager = components.connectionManager;
    this.peerStore = components.peerStore;
    this.events = components.events;
    this.log = components.logger.forComponent("libp2p:connection-manager:connection-pruner");
    this.maybePruneConnections = this.maybePruneConnections.bind(this);
  }
  start() {
    this.events.addEventListener("connection:open", this.maybePruneConnections);
  }
  stop() {
    this.events.removeEventListener("connection:open", this.maybePruneConnections);
  }
  maybePruneConnections() {
    this._maybePruneConnections().catch((err) => {
      this.log.error("error while pruning connections %e", err);
    });
  }
  /**
   * If we have more connections than our maximum, select some excess connections
   * to prune based on peer value
   */
  async _maybePruneConnections() {
    const connections = this.connectionManager.getConnections();
    const numConnections = connections.length;
    this.log("checking max connections limit %d/%d", numConnections, this.maxConnections);
    if (numConnections <= this.maxConnections) {
      return;
    }
    const peerValues = new PeerMap();
    for (const connection of connections) {
      const remotePeer = connection.remotePeer;
      if (peerValues.has(remotePeer)) {
        continue;
      }
      peerValues.set(remotePeer, 0);
      try {
        const peer = await this.peerStore.get(remotePeer);
        peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {
          return acc + curr.value;
        }, 0));
      } catch (err) {
        if (err.name !== "NotFoundError") {
          this.log.error("error loading peer tags", err);
        }
      }
    }
    const sortedConnections = this.sortConnections(connections, peerValues);
    const toPrune = Math.max(numConnections - this.maxConnections, 0);
    const toClose = [];
    for (const connection of sortedConnections) {
      this.log("too many connections open - closing a connection to %p", connection.remotePeer);
      const connectionInAllowList = this.allow.some((ipNet) => {
        return ipNet.contains(connection.remoteAddr.nodeAddress().address);
      });
      if (!connectionInAllowList) {
        toClose.push(connection);
      }
      if (toClose.length === toPrune) {
        break;
      }
    }
    await Promise.all(toClose.map(async (connection) => {
      await safelyCloseConnectionIfUnused(connection, {
        signal: AbortSignal.timeout(1e3)
      });
    }));
    this.events.safeDispatchEvent("connection:prune", { detail: toClose });
  }
  sortConnections(connections, peerValues) {
    return connections.sort((a, b) => {
      const connectionALifespan = a.timeline.open;
      const connectionBLifespan = b.timeline.open;
      if (connectionALifespan < connectionBLifespan) {
        return 1;
      }
      if (connectionALifespan > connectionBLifespan) {
        return -1;
      }
      return 0;
    }).sort((a, b) => {
      if (a.direction === "outbound" && b.direction === "inbound") {
        return 1;
      }
      if (a.direction === "inbound" && b.direction === "outbound") {
        return -1;
      }
      return 0;
    }).sort((a, b) => {
      if (a.streams.length > b.streams.length) {
        return 1;
      }
      if (a.streams.length < b.streams.length) {
        return -1;
      }
      return 0;
    }).sort((a, b) => {
      const peerAValue = peerValues.get(a.remotePeer) ?? 0;
      const peerBValue = peerValues.get(b.remotePeer) ?? 0;
      if (peerAValue > peerBValue) {
        return 1;
      }
      if (peerAValue < peerBValue) {
        return -1;
      }
      return 0;
    });
  }
};

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/queue/recipient.js
var JobRecipient = class {
  constructor(signal) {
    __publicField(this, "deferred");
    __publicField(this, "signal");
    var _a12;
    this.signal = signal;
    this.deferred = pDefer();
    this.onAbort = this.onAbort.bind(this);
    (_a12 = this.signal) == null ? void 0 : _a12.addEventListener("abort", this.onAbort);
  }
  onAbort() {
    var _a12;
    this.deferred.reject(((_a12 = this.signal) == null ? void 0 : _a12.reason) ?? new AbortError());
  }
  cleanup() {
    var _a12;
    (_a12 = this.signal) == null ? void 0 : _a12.removeEventListener("abort", this.onAbort);
  }
};

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/queue/job.js
function randomId() {
  return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
}
var Job = class {
  constructor(fn, options) {
    __publicField(this, "id");
    __publicField(this, "fn");
    __publicField(this, "options");
    __publicField(this, "recipients");
    __publicField(this, "status");
    __publicField(this, "timeline");
    __publicField(this, "controller");
    this.id = randomId();
    this.status = "queued";
    this.fn = fn;
    this.options = options;
    this.recipients = [];
    this.timeline = {
      created: Date.now()
    };
    this.controller = new AbortController();
    setMaxListeners(Infinity, this.controller.signal);
    this.onAbort = this.onAbort.bind(this);
  }
  abort(err) {
    this.controller.abort(err);
  }
  onAbort() {
    const allAborted = this.recipients.reduce((acc, curr) => {
      var _a12;
      return acc && ((_a12 = curr.signal) == null ? void 0 : _a12.aborted) === true;
    }, true);
    if (allAborted) {
      this.controller.abort(new AbortError());
      this.cleanup();
    }
  }
  async join(options = {}) {
    var _a12;
    const recipient = new JobRecipient(options.signal);
    this.recipients.push(recipient);
    (_a12 = options.signal) == null ? void 0 : _a12.addEventListener("abort", this.onAbort);
    return recipient.deferred.promise;
  }
  async run() {
    this.status = "running";
    this.timeline.started = Date.now();
    try {
      this.controller.signal.throwIfAborted();
      const result = await raceSignal(this.fn({
        ...this.options ?? {},
        signal: this.controller.signal
      }), this.controller.signal);
      this.recipients.forEach((recipient) => {
        recipient.deferred.resolve(result);
      });
      this.status = "complete";
    } catch (err) {
      this.recipients.forEach((recipient) => {
        recipient.deferred.reject(err);
      });
      this.status = "errored";
    } finally {
      this.timeline.finished = Date.now();
      this.cleanup();
    }
  }
  cleanup() {
    this.recipients.forEach((recipient) => {
      var _a12;
      recipient.cleanup();
      (_a12 = recipient.signal) == null ? void 0 : _a12.removeEventListener("abort", this.onAbort);
    });
  }
};

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/queue/index.js
var Queue = class extends TypedEventEmitter {
  constructor(init = {}) {
    var _a12;
    super();
    __publicField(this, "concurrency");
    __publicField(this, "maxSize");
    __publicField(this, "queue");
    __publicField(this, "pending");
    __publicField(this, "sort");
    this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;
    this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY;
    this.pending = 0;
    if (init.metricName != null) {
      (_a12 = init.metrics) == null ? void 0 : _a12.registerMetricGroup(init.metricName, {
        calculate: () => {
          return {
            size: this.queue.length,
            running: this.pending,
            queued: this.queue.length - this.pending
          };
        }
      });
    }
    this.sort = init.sort;
    this.queue = [];
  }
  tryToStartAnother() {
    if (this.size === 0) {
      queueMicrotask(() => {
        this.safeDispatchEvent("empty");
      });
      if (this.running === 0) {
        queueMicrotask(() => {
          this.safeDispatchEvent("idle");
        });
      }
      return false;
    }
    if (this.pending < this.concurrency) {
      let job;
      for (const j of this.queue) {
        if (j.status === "queued") {
          job = j;
          break;
        }
      }
      if (job == null) {
        return false;
      }
      this.safeDispatchEvent("active");
      this.pending++;
      void job.run().finally(() => {
        for (let i = 0; i < this.queue.length; i++) {
          if (this.queue[i] === job) {
            this.queue.splice(i, 1);
            break;
          }
        }
        this.pending--;
        this.tryToStartAnother();
        this.safeDispatchEvent("next");
      });
      return true;
    }
    return false;
  }
  enqueue(job) {
    this.queue.push(job);
    if (this.sort != null) {
      this.queue.sort(this.sort);
    }
  }
  /**
   * Adds a sync or async task to the queue. Always returns a promise.
   */
  async add(fn, options) {
    var _a12;
    (_a12 = options == null ? void 0 : options.signal) == null ? void 0 : _a12.throwIfAborted();
    if (this.size === this.maxSize) {
      throw new QueueFullError();
    }
    const job = new Job(fn, options);
    this.enqueue(job);
    this.safeDispatchEvent("add");
    this.tryToStartAnother();
    return job.join(options).then((result) => {
      this.safeDispatchEvent("completed", { detail: result });
      this.safeDispatchEvent("success", { detail: { job, result } });
      return result;
    }).catch((err) => {
      if (job.status === "queued") {
        for (let i = 0; i < this.queue.length; i++) {
          if (this.queue[i] === job) {
            this.queue.splice(i, 1);
            break;
          }
        }
      }
      this.safeDispatchEvent("error", { detail: err });
      this.safeDispatchEvent("failure", { detail: { job, error: err } });
      throw err;
    });
  }
  /**
   * Clear the queue
   */
  clear() {
    this.queue.splice(0, this.queue.length);
  }
  /**
   * Abort all jobs in the queue and clear it
   */
  abort() {
    this.queue.forEach((job) => {
      job.abort(new AbortError());
    });
    this.clear();
  }
  /**
   * Can be called multiple times. Useful if you for example add additional items at a later time.
   *
   * @returns A promise that settles when the queue becomes empty.
   */
  async onEmpty(options) {
    if (this.size === 0) {
      return;
    }
    await raceEvent(this, "empty", options == null ? void 0 : options.signal);
  }
  /**
   * @returns A promise that settles when the queue size is less than the given
   * limit: `queue.size < limit`.
   *
   * If you want to avoid having the queue grow beyond a certain size you can
   * `await queue.onSizeLessThan()` before adding a new item.
   *
   * Note that this only limits the number of items waiting to start. There
   * could still be up to `concurrency` jobs already running that this call does
   * not include in its calculation.
   */
  async onSizeLessThan(limit, options) {
    if (this.size < limit) {
      return;
    }
    await raceEvent(this, "next", options == null ? void 0 : options.signal, {
      filter: () => this.size < limit
    });
  }
  /**
   * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
   * from the queue has finished. `.onEmpty` merely signals that the queue is
   * empty, but it could mean that some promises haven't completed yet.
   *
   * @returns A promise that settles when the queue becomes empty, and all
   * promises have completed; `queue.size === 0 && queue.pending === 0`.
   */
  async onIdle(options) {
    if (this.pending === 0 && this.size === 0) {
      return;
    }
    await raceEvent(this, "idle", options == null ? void 0 : options.signal);
  }
  /**
   * Size of the queue including running items
   */
  get size() {
    return this.queue.length;
  }
  /**
   * The number of queued items waiting to run.
   */
  get queued() {
    return this.queue.length - this.pending;
  }
  /**
   * The number of items currently running.
   */
  get running() {
    return this.pending;
  }
  /**
   * Returns an async generator that makes it easy to iterate over the results
   * of jobs added to the queue.
   *
   * The generator will end when the queue becomes idle, that is there are no
   * jobs running and no jobs that have yet to run.
   *
   * If you need to keep the queue open indefinitely, consider using it-pushable
   * instead.
   */
  async *toGenerator(options) {
    var _a12, _b4, _c;
    (_a12 = options == null ? void 0 : options.signal) == null ? void 0 : _a12.throwIfAborted();
    const stream = pushable({
      objectMode: true
    });
    const cleanup = (err) => {
      if (err != null) {
        this.abort();
      } else {
        this.clear();
      }
      stream.end(err);
    };
    const onQueueJobComplete = (evt) => {
      if (evt.detail != null) {
        stream.push(evt.detail);
      }
    };
    const onQueueError = (evt) => {
      cleanup(evt.detail);
    };
    const onQueueIdle = () => {
      cleanup();
    };
    const onSignalAbort = () => {
      cleanup(new AbortError("Queue aborted"));
    };
    this.addEventListener("completed", onQueueJobComplete);
    this.addEventListener("error", onQueueError);
    this.addEventListener("idle", onQueueIdle);
    (_b4 = options == null ? void 0 : options.signal) == null ? void 0 : _b4.addEventListener("abort", onSignalAbort);
    try {
      yield* stream;
    } finally {
      this.removeEventListener("completed", onQueueJobComplete);
      this.removeEventListener("error", onQueueError);
      this.removeEventListener("idle", onQueueIdle);
      (_c = options == null ? void 0 : options.signal) == null ? void 0 : _c.removeEventListener("abort", onSignalAbort);
      cleanup();
    }
  }
};

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/priority-queue.js
var PriorityQueue2 = class extends Queue {
  constructor(init = {}) {
    super({
      ...init,
      sort: (a, b) => {
        if (a.options.priority > b.options.priority) {
          return -1;
        }
        if (a.options.priority < b.options.priority) {
          return 1;
        }
        return 0;
      }
    });
  }
};

// node_modules/.pnpm/is-loopback-addr@2.0.2/node_modules/is-loopback-addr/dist/src/index.js
function isLoopbackAddr(ip) {
  return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(ip) || /^::1$/.test(ip);
}

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/multiaddr/is-loopback.js
function isLoopback(ma) {
  if (!isIpBased(ma)) {
    return false;
  }
  const { address } = ma.nodeAddress();
  return isLoopbackAddr(address);
}

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/connection-manager/address-sorter.js
function reliableTransportsFirst(a, b) {
  const isATcp = TCP.exactMatch(a.multiaddr);
  const isBTcp = TCP.exactMatch(b.multiaddr);
  if (isATcp && !isBTcp) {
    return -1;
  }
  if (!isATcp && isBTcp) {
    return 1;
  }
  const isAWebSocketSecure = WebSocketsSecure.exactMatch(a.multiaddr);
  const isBWebSocketSecure = WebSocketsSecure.exactMatch(b.multiaddr);
  if (isAWebSocketSecure && !isBWebSocketSecure) {
    return -1;
  }
  if (!isAWebSocketSecure && isBWebSocketSecure) {
    return 1;
  }
  const isAWebSocket = WebSockets.exactMatch(a.multiaddr);
  const isBWebSocket = WebSockets.exactMatch(b.multiaddr);
  if (isAWebSocket && !isBWebSocket) {
    return -1;
  }
  if (!isAWebSocket && isBWebSocket) {
    return 1;
  }
  const isAWebRTC = WebRTC.exactMatch(a.multiaddr);
  const isBWebRTC = WebRTC.exactMatch(b.multiaddr);
  if (isAWebRTC && !isBWebRTC) {
    return -1;
  }
  if (!isAWebRTC && isBWebRTC) {
    return 1;
  }
  const isAWebRTCDirect = WebRTCDirect.exactMatch(a.multiaddr);
  const isBWebRTCDirect = WebRTCDirect.exactMatch(b.multiaddr);
  if (isAWebRTCDirect && !isBWebRTCDirect) {
    return -1;
  }
  if (!isAWebRTCDirect && isBWebRTCDirect) {
    return 1;
  }
  const isAWebTransport = WebTransport.exactMatch(a.multiaddr);
  const isBWebTransport = WebTransport.exactMatch(b.multiaddr);
  if (isAWebTransport && !isBWebTransport) {
    return -1;
  }
  if (!isAWebTransport && isBWebTransport) {
    return 1;
  }
  return 0;
}
function loopbackAddressLast(a, b) {
  const isALoopback = isLoopback(a.multiaddr);
  const isBLoopback = isLoopback(b.multiaddr);
  if (isALoopback && !isBLoopback) {
    return 1;
  } else if (!isALoopback && isBLoopback) {
    return -1;
  }
  return 0;
}
function publicAddressesFirst(a, b) {
  const isAPrivate = isPrivate(a.multiaddr);
  const isBPrivate = isPrivate(b.multiaddr);
  if (isAPrivate && !isBPrivate) {
    return 1;
  } else if (!isAPrivate && isBPrivate) {
    return -1;
  }
  return 0;
}
function certifiedAddressesFirst(a, b) {
  if (a.isCertified && !b.isCertified) {
    return -1;
  } else if (!a.isCertified && b.isCertified) {
    return 1;
  }
  return 0;
}
function circuitRelayAddressesLast(a, b) {
  const isACircuit = Circuit.exactMatch(a.multiaddr);
  const isBCircuit = Circuit.exactMatch(b.multiaddr);
  if (isACircuit && !isBCircuit) {
    return 1;
  } else if (!isACircuit && isBCircuit) {
    return -1;
  }
  return 0;
}
function defaultAddressSorter(addresses) {
  return addresses.sort(reliableTransportsFirst).sort(certifiedAddressesFirst).sort(circuitRelayAddressesLast).sort(publicAddressesFirst).sort(loopbackAddressLast);
}

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/connection-manager/dial-queue.js
var defaultOptions4 = {
  maxParallelDials: MAX_PARALLEL_DIALS,
  maxDialQueueLength: MAX_DIAL_QUEUE_LENGTH,
  maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,
  dialTimeout: DIAL_TIMEOUT,
  resolvers: {
    dnsaddr: dnsaddrResolver
  }
};
var DialQueue = class {
  constructor(components, init = {}) {
    __publicField(this, "queue");
    __publicField(this, "components");
    __publicField(this, "addressSorter");
    __publicField(this, "maxPeerAddrsToDial");
    __publicField(this, "maxDialQueueLength");
    __publicField(this, "dialTimeout");
    __publicField(this, "shutDownController");
    __publicField(this, "connections");
    __publicField(this, "log");
    this.addressSorter = init.addressSorter;
    this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions4.maxPeerAddrsToDial;
    this.maxDialQueueLength = init.maxDialQueueLength ?? defaultOptions4.maxDialQueueLength;
    this.dialTimeout = init.dialTimeout ?? defaultOptions4.dialTimeout;
    this.connections = init.connections ?? new PeerMap();
    this.log = components.logger.forComponent("libp2p:connection-manager:dial-queue");
    this.components = components;
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
    for (const [key, value] of Object.entries(init.resolvers ?? {})) {
      resolvers.set(key, value);
    }
    this.queue = new PriorityQueue2({
      concurrency: init.maxParallelDials ?? defaultOptions4.maxParallelDials,
      metricName: "libp2p_dial_queue",
      metrics: components.metrics
    });
    this.queue.addEventListener("error", (event) => {
      if (event.detail.name !== AbortError.name) {
        this.log.error("error in dial queue - %e", event.detail);
      }
    });
  }
  start() {
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
  }
  /**
   * Clears any pending dials
   */
  stop() {
    this.shutDownController.abort();
    this.queue.abort();
  }
  /**
   * Connects to a given peer, multiaddr or list of multiaddrs.
   *
   * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or
   * multiaddrs are passed only those will be dialled.
   *
   * Where a list of multiaddrs is passed, if any contain a peer id then all
   * multiaddrs in the list must contain the same peer id.
   *
   * The dial to the first address that is successfully able to upgrade a
   * connection will be used, all other dials will be aborted when that happens.
   */
  async dial(peerIdOrMultiaddr, options = {}) {
    var _a12, _b4, _c;
    const { peerId, multiaddrs } = getPeerAddress(peerIdOrMultiaddr);
    const existingConnection = Array.from(this.connections.values()).flat().find((conn) => {
      if (options.force === true) {
        return false;
      }
      if (conn.remotePeer.equals(peerId)) {
        return true;
      }
      return multiaddrs.find((addr) => {
        return addr.equals(conn.remoteAddr);
      });
    });
    if ((existingConnection == null ? void 0 : existingConnection.status) === "open") {
      this.log("already connected to %a", existingConnection.remoteAddr);
      (_a12 = options.onProgress) == null ? void 0 : _a12.call(options, new CustomProgressEvent("dial-queue:already-connected"));
      return existingConnection;
    }
    const existingDial = this.queue.queue.find((job) => {
      if ((peerId == null ? void 0 : peerId.equals(job.options.peerId)) === true) {
        return true;
      }
      const addresses = job.options.multiaddrs;
      if (addresses == null) {
        return false;
      }
      for (const multiaddr2 of multiaddrs) {
        if (addresses.has(multiaddr2.toString())) {
          return true;
        }
      }
      return false;
    });
    if (existingDial != null) {
      this.log("joining existing dial target for %p", peerId);
      for (const multiaddr2 of multiaddrs) {
        existingDial.options.multiaddrs.add(multiaddr2.toString());
      }
      (_b4 = options.onProgress) == null ? void 0 : _b4.call(options, new CustomProgressEvent("dial-queue:already-in-dial-queue"));
      return existingDial.join(options);
    }
    if (this.queue.size >= this.maxDialQueueLength) {
      throw new DialError("Dial queue is full");
    }
    this.log("creating dial target for %p", peerId, multiaddrs.map((ma) => ma.toString()));
    (_c = options.onProgress) == null ? void 0 : _c.call(options, new CustomProgressEvent("dial-queue:add-to-dial-queue"));
    return this.queue.add(async (options2) => {
      var _a13;
      (_a13 = options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomProgressEvent("dial-queue:start-dial"));
      const signal = anySignal([
        this.shutDownController.signal,
        options2.signal
      ]);
      setMaxListeners(Infinity, signal);
      try {
        return await this.dialPeer(options2, signal);
      } finally {
        signal.clear();
      }
    }, {
      peerId,
      priority: options.priority ?? DEFAULT_DIAL_PRIORITY,
      multiaddrs: new Set(multiaddrs.map((ma) => ma.toString())),
      signal: options.signal ?? AbortSignal.timeout(this.dialTimeout),
      onProgress: options.onProgress
    });
  }
  async dialPeer(options, signal) {
    var _a12;
    const peerId = options.peerId;
    const multiaddrs = options.multiaddrs;
    const failedMultiaddrs = /* @__PURE__ */ new Set();
    let forcePeerLookup = options.multiaddrs.size === 0;
    let dialed = 0;
    let dialIteration = 0;
    const errors = [];
    this.log("starting dial to %p", peerId);
    while (forcePeerLookup || multiaddrs.size > 0) {
      dialIteration++;
      forcePeerLookup = false;
      const addrsToDial = [];
      const addrs = new Set(options.multiaddrs);
      multiaddrs.clear();
      this.log("calculating addrs to dial %p from %s", peerId, [...addrs]);
      const calculatedAddrs = await this.calculateMultiaddrs(peerId, addrs, {
        ...options,
        signal
      });
      for (const addr of calculatedAddrs) {
        if (failedMultiaddrs.has(addr.multiaddr.toString())) {
          this.log.trace("skipping previously failed multiaddr %a while dialing %p", addr.multiaddr, peerId);
          continue;
        }
        addrsToDial.push(addr);
      }
      this.log("%s dial to %p with %s", dialIteration === 1 ? "starting" : "continuing", peerId, addrsToDial.map((ma) => ma.multiaddr.toString()));
      (_a12 = options == null ? void 0 : options.onProgress) == null ? void 0 : _a12.call(options, new CustomProgressEvent("dial-queue:calculated-addresses", addrsToDial));
      for (const address of addrsToDial) {
        if (dialed === this.maxPeerAddrsToDial) {
          this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others", dialed, options.peerId);
          throw new DialError("Peer had more than maxPeerAddrsToDial");
        }
        dialed++;
        try {
          const conn = await this.components.transportManager.dial(address.multiaddr, {
            ...options,
            signal
          });
          this.log("dial to %a succeeded", address.multiaddr);
          try {
            await this.components.peerStore.merge(conn.remotePeer, {
              multiaddrs: [
                conn.remoteAddr
              ],
              metadata: {
                [LAST_DIAL_SUCCESS_KEY]: fromString(Date.now().toString())
              }
            });
          } catch (err) {
            this.log.error("could not update last dial failure key for %p", peerId, err);
          }
          return conn;
        } catch (err) {
          this.log.error("dial failed to %a", address.multiaddr, err);
          failedMultiaddrs.add(address.multiaddr.toString());
          if (peerId != null) {
            try {
              await this.components.peerStore.merge(peerId, {
                metadata: {
                  [LAST_DIAL_FAILURE_KEY]: fromString(Date.now().toString())
                }
              });
            } catch (err2) {
              this.log.error("could not update last dial failure key for %p", peerId, err2);
            }
          }
          if (signal.aborted) {
            throw new TimeoutError(err.message);
          }
          errors.push(err);
        }
      }
    }
    if (errors.length === 1) {
      throw errors[0];
    }
    throw new AggregateError(errors, "All multiaddr dials failed");
  }
  // eslint-disable-next-line complexity
  async calculateMultiaddrs(peerId, multiaddrs = /* @__PURE__ */ new Set(), options = {}) {
    var _a12, _b4;
    const addrs = [...multiaddrs].map((ma) => ({
      multiaddr: multiaddr(ma),
      isCertified: false
    }));
    if (peerId != null) {
      if (this.components.peerId.equals(peerId)) {
        throw new DialError("Tried to dial self");
      }
      if (await ((_b4 = (_a12 = this.components.connectionGater).denyDialPeer) == null ? void 0 : _b4.call(_a12, peerId)) === true) {
        throw new DialDeniedError("The dial request is blocked by gater.allowDialPeer");
      }
      if (addrs.length === 0) {
        this.log("loading multiaddrs for %p", peerId);
        try {
          const peer = await this.components.peerStore.get(peerId);
          addrs.push(...peer.addresses);
          this.log("loaded multiaddrs for %p", peerId, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
        } catch (err) {
          if (err.name !== "NotFoundError") {
            throw err;
          }
        }
      }
      if (addrs.length === 0) {
        this.log("looking up multiaddrs for %p in the peer routing", peerId);
        try {
          const peerInfo = await this.components.peerRouting.findPeer(peerId, options);
          this.log("found multiaddrs for %p in the peer routing", peerId, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
          addrs.push(...peerInfo.multiaddrs.map((multiaddr2) => ({
            multiaddr: multiaddr2,
            isCertified: false
          })));
        } catch (err) {
          if (err.name === "NoPeerRoutersError") {
            this.log("no peer routers configured", peerId);
          } else {
            this.log.error("looking up multiaddrs for %p in the peer routing failed - %e", peerId, err);
          }
        }
      }
    }
    let resolvedAddresses = (await Promise.all(addrs.map(async (addr) => {
      const result = await resolveMultiaddrs(addr.multiaddr, {
        dns: this.components.dns,
        ...options,
        log: this.log
      });
      if (result.length === 1 && result[0].equals(addr.multiaddr)) {
        return addr;
      }
      return result.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        isCertified: false
      }));
    }))).flat();
    if (peerId != null) {
      const peerIdMultiaddr = `/p2p/${peerId.toString()}`;
      resolvedAddresses = resolvedAddresses.map((addr) => {
        const lastProto = addr.multiaddr.protos().pop();
        if ((lastProto == null ? void 0 : lastProto.path) === true) {
          return addr;
        }
        if (addr.multiaddr.getPeerId() == null) {
          return {
            multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),
            isCertified: addr.isCertified
          };
        }
        return addr;
      });
    }
    const filteredAddrs = resolvedAddresses.filter((addr) => {
      if (this.components.transportManager.dialTransportForMultiaddr(addr.multiaddr) == null) {
        return false;
      }
      const addrPeerId = addr.multiaddr.getPeerId();
      if (peerId != null && addrPeerId != null) {
        return peerId.equals(addrPeerId);
      }
      return true;
    });
    const dedupedAddrs = /* @__PURE__ */ new Map();
    for (const addr of filteredAddrs) {
      const maStr = addr.multiaddr.toString();
      const existing = dedupedAddrs.get(maStr);
      if (existing != null) {
        existing.isCertified = existing.isCertified || addr.isCertified || false;
        continue;
      }
      dedupedAddrs.set(maStr, addr);
    }
    const dedupedMultiaddrs = [...dedupedAddrs.values()];
    if (dedupedMultiaddrs.length === 0) {
      throw new NoValidAddressesError("The dial request has no valid addresses");
    }
    const gatedAddrs = [];
    for (const addr of dedupedMultiaddrs) {
      if (this.components.connectionGater.denyDialMultiaddr != null && await this.components.connectionGater.denyDialMultiaddr(addr.multiaddr)) {
        continue;
      }
      gatedAddrs.push(addr);
    }
    const sortedGatedAddrs = this.addressSorter == null ? defaultAddressSorter(gatedAddrs) : gatedAddrs.sort(this.addressSorter);
    if (sortedGatedAddrs.length === 0) {
      throw new DialDeniedError("The connection gater denied all addresses in the dial request");
    }
    this.log.trace("addresses for %p before filtering", peerId ?? "unknown peer", resolvedAddresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    this.log.trace("addresses for %p after filtering", peerId ?? "unknown peer", sortedGatedAddrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    return sortedGatedAddrs;
  }
  async isDialable(multiaddr2, options = {}) {
    if (!Array.isArray(multiaddr2)) {
      multiaddr2 = [multiaddr2];
    }
    try {
      const addresses = await this.calculateMultiaddrs(void 0, new Set(multiaddr2.map((ma) => ma.toString())), options);
      if (options.runOnLimitedConnection === false) {
        return addresses.find((addr) => {
          return !Circuit.matches(addr.multiaddr);
        }) != null;
      }
      return true;
    } catch (err) {
      this.log.trace("error calculating if multiaddr(s) were dialable", err);
    }
    return false;
  }
};

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/peer-queue.js
var PeerQueue = class extends Queue {
  has(peerId) {
    return this.find(peerId) != null;
  }
  find(peerId) {
    return this.queue.find((job) => {
      return peerId.equals(job.options.peerId);
    });
  }
};

// node_modules/.pnpm/p-retry@6.2.1/node_modules/p-retry/index.js
var import_retry = __toESM(require_retry2());

// node_modules/.pnpm/is-network-error@1.1.0/node_modules/is-network-error/index.js
var objectToString = Object.prototype.toString;
var isError2 = (value) => objectToString.call(value) === "[object Error]";
var errorMessages = /* @__PURE__ */ new Set([
  "network error",
  // Chrome
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari 16
  "Load failed",
  // Safari 17+
  "Network request failed",
  // `cross-fetch`
  "fetch failed",
  // Undici (Node.js)
  "terminated"
  // Undici (Node.js)
]);
function isNetworkError(error) {
  const isValid = error && isError2(error) && error.name === "TypeError" && typeof error.message === "string";
  if (!isValid) {
    return false;
  }
  if (error.message === "Load failed") {
    return error.stack === void 0;
  }
  return errorMessages.has(error.message);
}

// node_modules/.pnpm/p-retry@6.2.1/node_modules/p-retry/index.js
var AbortError2 = class extends Error {
  constructor(message2) {
    super();
    if (message2 instanceof Error) {
      this.originalError = message2;
      ({ message: message2 } = message2);
    } else {
      this.originalError = new Error(message2);
      this.originalError.stack = this.stack;
    }
    this.name = "AbortError";
    this.message = message2;
  }
};
var decorateErrorWithCounts = (error, attemptNumber, options) => {
  const retriesLeft = options.retries - (attemptNumber - 1);
  error.attemptNumber = attemptNumber;
  error.retriesLeft = retriesLeft;
  return error;
};
async function pRetry(input, options) {
  return new Promise((resolve, reject) => {
    options = { ...options };
    options.onFailedAttempt ?? (options.onFailedAttempt = () => {
    });
    options.shouldRetry ?? (options.shouldRetry = () => true);
    options.retries ?? (options.retries = 10);
    const operation = import_retry.default.operation(options);
    const abortHandler = () => {
      var _a12;
      operation.stop();
      reject((_a12 = options.signal) == null ? void 0 : _a12.reason);
    };
    if (options.signal && !options.signal.aborted) {
      options.signal.addEventListener("abort", abortHandler, { once: true });
    }
    const cleanUp = () => {
      var _a12;
      (_a12 = options.signal) == null ? void 0 : _a12.removeEventListener("abort", abortHandler);
      operation.stop();
    };
    operation.attempt(async (attemptNumber) => {
      try {
        const result = await input(attemptNumber);
        cleanUp();
        resolve(result);
      } catch (error) {
        try {
          if (!(error instanceof Error)) {
            throw new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
          }
          if (error instanceof AbortError2) {
            throw error.originalError;
          }
          if (error instanceof TypeError && !isNetworkError(error)) {
            throw error;
          }
          decorateErrorWithCounts(error, attemptNumber, options);
          if (!await options.shouldRetry(error)) {
            operation.stop();
            reject(error);
          }
          await options.onFailedAttempt(error);
          if (!operation.retry(error)) {
            throw operation.mainError();
          }
        } catch (finalError) {
          decorateErrorWithCounts(finalError, attemptNumber, options);
          cleanUp();
          reject(finalError);
        }
      }
    });
  });
}

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/connection-manager/reconnect-queue.js
var ReconnectQueue = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "queue");
    __publicField(this, "started");
    __publicField(this, "peerStore");
    __publicField(this, "retries");
    __publicField(this, "retryInterval");
    __publicField(this, "backoffFactor");
    __publicField(this, "connectionManager");
    __publicField(this, "events");
    this.log = components.logger.forComponent("libp2p:reconnect-queue");
    this.peerStore = components.peerStore;
    this.connectionManager = components.connectionManager;
    this.queue = new PeerQueue({
      concurrency: init.maxParallelReconnects ?? MAX_PARALLEL_RECONNECTS,
      metricName: "libp2p_reconnect_queue",
      metrics: components.metrics
    });
    this.started = false;
    this.retries = init.retries ?? 5;
    this.backoffFactor = init.backoffFactor;
    this.retryInterval = init.retryInterval;
    this.events = components.events;
    components.events.addEventListener("peer:disconnect", (evt) => {
      this.maybeReconnect(evt.detail).catch((err) => {
        this.log.error("failed to maybe reconnect to %p - %e", evt.detail, err);
      });
    });
  }
  async maybeReconnect(peerId) {
    if (!this.started) {
      return;
    }
    const peer = await this.peerStore.get(peerId);
    if (!hasKeepAliveTag(peer)) {
      return;
    }
    if (this.queue.has(peerId)) {
      return;
    }
    this.queue.add(async (options) => {
      await pRetry(async (attempt) => {
        if (!this.started) {
          return;
        }
        try {
          await this.connectionManager.openConnection(peerId, {
            signal: options == null ? void 0 : options.signal
          });
        } catch (err) {
          this.log("reconnecting to %p attempt %d of %d failed - %e", peerId, attempt, this.retries, err);
          throw err;
        }
      }, {
        signal: options == null ? void 0 : options.signal,
        retries: this.retries,
        factor: this.backoffFactor,
        minTimeout: this.retryInterval
      });
    }, {
      peerId
    }).catch(async (err) => {
      this.log.error("failed to reconnect to %p - %e", peerId, err);
      const tags = {};
      [...peer.tags.keys()].forEach((key) => {
        if (key.startsWith(KEEP_ALIVE)) {
          tags[key] = void 0;
        }
      });
      await this.peerStore.merge(peerId, {
        tags
      });
      this.events.safeDispatchEvent("peer:reconnect-failure", {
        detail: peerId
      });
    }).catch(async (err) => {
      this.log.error("failed to remove keep-alive tag from %p - %e", peerId, err);
    });
  }
  start() {
    this.started = true;
  }
  async afterStart() {
    void Promise.resolve().then(async () => {
      const keepAlivePeers = await this.peerStore.all({
        filters: [
          (peer) => hasKeepAliveTag(peer)
        ]
      });
      await Promise.all(keepAlivePeers.map(async (peer) => {
        await this.connectionManager.openConnection(peer.id).catch((err) => {
          this.log.error(err);
        });
      }));
    }).catch((err) => {
      this.log.error(err);
    });
  }
  stop() {
    this.started = false;
    this.queue.abort();
  }
};
function hasKeepAliveTag(peer) {
  for (const tag of peer.tags.keys()) {
    if (tag.startsWith(KEEP_ALIVE)) {
      return true;
    }
  }
  return false;
}

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/connection-manager/index.js
var DEFAULT_DIAL_PRIORITY = 50;
var defaultOptions5 = {
  maxConnections: MAX_CONNECTIONS,
  inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,
  maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS
};
var _a3;
_a3 = Symbol.toStringTag;
var DefaultConnectionManager = class {
  constructor(components, init = {}) {
    __publicField(this, "started");
    __publicField(this, "connections");
    __publicField(this, "allow");
    __publicField(this, "deny");
    __publicField(this, "maxIncomingPendingConnections");
    __publicField(this, "incomingPendingConnections");
    __publicField(this, "outboundPendingConnections");
    __publicField(this, "maxConnections");
    __publicField(this, "dialQueue");
    __publicField(this, "reconnectQueue");
    __publicField(this, "connectionPruner");
    __publicField(this, "inboundConnectionRateLimiter");
    __publicField(this, "peerStore");
    __publicField(this, "metrics");
    __publicField(this, "events");
    __publicField(this, "log");
    __publicField(this, "peerId");
    __publicField(this, _a3, "@libp2p/connection-manager");
    var _a12;
    this.maxConnections = init.maxConnections ?? defaultOptions5.maxConnections;
    if (this.maxConnections < 1) {
      throw new InvalidParametersError("Connection Manager maxConnections must be greater than 0");
    }
    this.connections = new PeerMap();
    this.started = false;
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.metrics = components.metrics;
    this.events = components.events;
    this.log = components.logger.forComponent("libp2p:connection-manager");
    this.onConnect = this.onConnect.bind(this);
    this.onDisconnect = this.onDisconnect.bind(this);
    this.allow = (init.allow ?? []).map((str) => multiaddrToIpNet(str));
    this.deny = (init.deny ?? []).map((str) => multiaddrToIpNet(str));
    this.incomingPendingConnections = 0;
    this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions5.maxIncomingPendingConnections;
    this.outboundPendingConnections = 0;
    this.inboundConnectionRateLimiter = new RateLimiter({
      points: init.inboundConnectionThreshold ?? defaultOptions5.inboundConnectionThreshold,
      duration: 1
    });
    this.connectionPruner = new ConnectionPruner({
      connectionManager: this,
      peerStore: components.peerStore,
      events: components.events,
      logger: components.logger
    }, {
      maxConnections: this.maxConnections,
      allow: (_a12 = init.allow) == null ? void 0 : _a12.map((a) => multiaddr(a))
    });
    this.dialQueue = new DialQueue(components, {
      addressSorter: init.addressSorter,
      maxParallelDials: init.maxParallelDials ?? MAX_PARALLEL_DIALS,
      maxDialQueueLength: init.maxDialQueueLength ?? MAX_DIAL_QUEUE_LENGTH,
      maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,
      dialTimeout: init.dialTimeout ?? DIAL_TIMEOUT,
      resolvers: init.resolvers ?? {
        dnsaddr: dnsaddrResolver
      },
      connections: this.connections
    });
    this.reconnectQueue = new ReconnectQueue({
      events: components.events,
      peerStore: components.peerStore,
      logger: components.logger,
      connectionManager: this
    }, {
      retries: init.reconnectRetries,
      retryInterval: init.reconnectRetryInterval,
      backoffFactor: init.reconnectBackoffFactor,
      maxParallelReconnects: init.maxParallelReconnects
    });
  }
  /**
   * Starts the Connection Manager. If Metrics are not enabled on libp2p
   * only event loop and connection limits will be monitored.
   */
  async start() {
    var _a12, _b4, _c;
    (_a12 = this.metrics) == null ? void 0 : _a12.registerMetricGroup("libp2p_connection_manager_connections", {
      calculate: () => {
        const metric = {
          inbound: 0,
          "inbound pending": this.incomingPendingConnections,
          outbound: 0,
          "outbound pending": this.outboundPendingConnections
        };
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            metric[conn.direction]++;
          }
        }
        return metric;
      }
    });
    (_b4 = this.metrics) == null ? void 0 : _b4.registerMetricGroup("libp2p_protocol_streams_total", {
      label: "protocol",
      calculate: () => {
        const metric = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            for (const stream of conn.streams) {
              const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
              metric[key] = (metric[key] ?? 0) + 1;
            }
          }
        }
        return metric;
      }
    });
    (_c = this.metrics) == null ? void 0 : _c.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile", {
      label: "protocol",
      calculate: () => {
        const allStreams = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            const streams = {};
            for (const stream of conn.streams) {
              const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
              streams[key] = (streams[key] ?? 0) + 1;
            }
            for (const [protocol, count] of Object.entries(streams)) {
              allStreams[protocol] = allStreams[protocol] ?? [];
              allStreams[protocol].push(count);
            }
          }
        }
        const metric = {};
        for (let [protocol, counts] of Object.entries(allStreams)) {
          counts = counts.sort((a, b) => a - b);
          const index = Math.floor(counts.length * 0.9);
          metric[protocol] = counts[index];
        }
        return metric;
      }
    });
    this.events.addEventListener("connection:open", this.onConnect);
    this.events.addEventListener("connection:close", this.onDisconnect);
    await start(this.dialQueue, this.reconnectQueue, this.connectionPruner);
    this.started = true;
    this.log("started");
  }
  /**
   * Stops the Connection Manager
   */
  async stop() {
    this.events.removeEventListener("connection:open", this.onConnect);
    this.events.removeEventListener("connection:close", this.onDisconnect);
    await stop(this.reconnectQueue, this.dialQueue, this.connectionPruner);
    const tasks = [];
    for (const connectionList of this.connections.values()) {
      for (const connection of connectionList) {
        tasks.push((async () => {
          try {
            await connection.close();
          } catch (err) {
            this.log.error(err);
          }
        })());
      }
    }
    this.log("closing %d connections", tasks.length);
    await Promise.all(tasks);
    this.connections.clear();
    this.log("stopped");
  }
  getMaxConnections() {
    return this.maxConnections;
  }
  onConnect(evt) {
    void this._onConnect(evt).catch((err) => {
      this.log.error(err);
    });
  }
  /**
   * Tracks the incoming connection and check the connection limit
   */
  async _onConnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      await connection.close();
      return;
    }
    if (connection.status !== "open") {
      return;
    }
    const peerId = connection.remotePeer;
    const isNewPeer = !this.connections.has(peerId);
    const storedConns = this.connections.get(peerId) ?? [];
    storedConns.push(connection);
    this.connections.set(peerId, storedConns);
    if (peerId.publicKey != null && peerId.type === "RSA") {
      await this.peerStore.patch(peerId, {
        publicKey: peerId.publicKey
      });
    }
    if (isNewPeer) {
      this.events.safeDispatchEvent("peer:connect", { detail: connection.remotePeer });
    }
  }
  /**
   * Removes the connection from tracking
   */
  onDisconnect(evt) {
    const { detail: connection } = evt;
    const peerId = connection.remotePeer;
    const peerConns = this.connections.get(peerId) ?? [];
    const filteredPeerConns = peerConns.filter((conn) => conn.id !== connection.id);
    this.connections.set(peerId, filteredPeerConns);
    if (filteredPeerConns.length === 0) {
      this.log("onDisconnect remove all connections for peer %p", peerId);
      this.connections.delete(peerId);
      this.events.safeDispatchEvent("peer:disconnect", { detail: connection.remotePeer });
    }
  }
  getConnections(peerId) {
    if (peerId != null) {
      return this.connections.get(peerId) ?? [];
    }
    let conns = [];
    for (const c of this.connections.values()) {
      conns = conns.concat(c);
    }
    return conns;
  }
  getConnectionsMap() {
    return this.connections;
  }
  async openConnection(peerIdOrMultiaddr, options = {}) {
    var _a12, _b4;
    if (!this.started) {
      throw new NotStartedError("Not started");
    }
    this.outboundPendingConnections++;
    try {
      (_a12 = options.signal) == null ? void 0 : _a12.throwIfAborted();
      const { peerId } = getPeerAddress(peerIdOrMultiaddr);
      if (this.peerId.equals(peerId)) {
        throw new InvalidPeerIdError("Can not dial self");
      }
      if (peerId != null && options.force !== true) {
        this.log("dial %p", peerId);
        const existingConnection = this.getConnections(peerId).find((conn) => conn.limits == null);
        if (existingConnection != null) {
          this.log("had an existing non-limited connection to %p", peerId);
          (_b4 = options.onProgress) == null ? void 0 : _b4.call(options, new CustomProgressEvent("dial-queue:already-connected"));
          return existingConnection;
        }
      }
      const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {
        ...options,
        priority: options.priority ?? DEFAULT_DIAL_PRIORITY
      });
      if (connection.status !== "open") {
        throw new ConnectionClosedError("Remote closed connection during opening");
      }
      let peerConnections = this.connections.get(connection.remotePeer);
      if (peerConnections == null) {
        peerConnections = [];
        this.connections.set(connection.remotePeer, peerConnections);
      }
      let trackedConnection = false;
      for (const conn of peerConnections) {
        if (conn.id === connection.id) {
          trackedConnection = true;
        }
        if (options.force !== true && conn.id !== connection.id && conn.remoteAddr.equals(connection.remoteAddr)) {
          connection.abort(new InvalidMultiaddrError("Duplicate multiaddr connection"));
          return conn;
        }
      }
      if (!trackedConnection) {
        peerConnections.push(connection);
      }
      return connection;
    } finally {
      this.outboundPendingConnections--;
    }
  }
  async closeConnections(peerId, options = {}) {
    const connections = this.connections.get(peerId) ?? [];
    await Promise.all(connections.map(async (connection) => {
      try {
        await connection.close(options);
      } catch (err) {
        connection.abort(err);
      }
    }));
  }
  async acceptIncomingConnection(maConn) {
    const denyConnection = this.deny.some((ma) => {
      return ma.contains(maConn.remoteAddr.nodeAddress().address);
    });
    if (denyConnection) {
      this.log("connection from %a refused - connection remote address was in deny list", maConn.remoteAddr);
      return false;
    }
    const allowConnection = this.allow.some((ipNet) => {
      return ipNet.contains(maConn.remoteAddr.nodeAddress().address);
    });
    if (allowConnection) {
      this.incomingPendingConnections++;
      return true;
    }
    if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {
      this.log("connection from %a refused - incomingPendingConnections exceeded by host", maConn.remoteAddr);
      return false;
    }
    if (maConn.remoteAddr.isThinWaistAddress()) {
      const host = maConn.remoteAddr.nodeAddress().address;
      try {
        await this.inboundConnectionRateLimiter.consume(host, 1);
      } catch {
        this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s", maConn.remoteAddr, host);
        return false;
      }
    }
    if (this.getConnections().length < this.maxConnections) {
      this.incomingPendingConnections++;
      return true;
    }
    this.log("connection from %a refused - maxConnections exceeded", maConn.remoteAddr);
    return false;
  }
  afterUpgradeInbound() {
    this.incomingPendingConnections--;
  }
  getDialQueue() {
    const statusMap = {
      queued: "queued",
      running: "active",
      errored: "error",
      complete: "success"
    };
    return this.dialQueue.queue.queue.map((job) => {
      return {
        id: job.id,
        status: statusMap[job.status],
        peerId: job.options.peerId,
        multiaddrs: [...job.options.multiaddrs].map((ma) => multiaddr(ma))
      };
    });
  }
  async isDialable(multiaddr2, options = {}) {
    return this.dialQueue.isDialable(multiaddr2, options);
  }
};

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/moving-average.js
var MovingAverage = class {
  constructor(timeSpan) {
    __publicField(this, "movingAverage");
    __publicField(this, "variance");
    __publicField(this, "deviation");
    __publicField(this, "forecast");
    __publicField(this, "timeSpan");
    __publicField(this, "previousTime");
    this.timeSpan = timeSpan;
    this.movingAverage = 0;
    this.variance = 0;
    this.deviation = 0;
    this.forecast = 0;
  }
  alpha(t, pt) {
    return 1 - Math.exp(-(t - pt) / this.timeSpan);
  }
  push(value, time = Date.now()) {
    if (this.previousTime != null) {
      const a = this.alpha(time, this.previousTime);
      const diff = value - this.movingAverage;
      const incr = a * diff;
      this.movingAverage = a * value + (1 - a) * this.movingAverage;
      this.variance = (1 - a) * (this.variance + diff * incr);
      this.deviation = Math.sqrt(this.variance);
      this.forecast = this.movingAverage + a * diff;
    } else {
      this.movingAverage = value;
    }
    this.previousTime = time;
  }
};

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/adaptive-timeout.js
var DEFAULT_TIMEOUT_MULTIPLIER = 1.2;
var DEFAULT_FAILURE_MULTIPLIER = 2;
var DEFAULT_MIN_TIMEOUT = 2e3;
var AdaptiveTimeout = class {
  constructor(init = {}) {
    __publicField(this, "success");
    __publicField(this, "failure");
    __publicField(this, "next");
    __publicField(this, "metric");
    __publicField(this, "timeoutMultiplier");
    __publicField(this, "failureMultiplier");
    __publicField(this, "minTimeout");
    var _a12;
    this.success = new MovingAverage(init.interval ?? 5e3);
    this.failure = new MovingAverage(init.interval ?? 5e3);
    this.next = new MovingAverage(init.interval ?? 5e3);
    this.failureMultiplier = init.failureMultiplier ?? DEFAULT_FAILURE_MULTIPLIER;
    this.timeoutMultiplier = init.timeoutMultiplier ?? DEFAULT_TIMEOUT_MULTIPLIER;
    this.minTimeout = init.minTimeout ?? DEFAULT_MIN_TIMEOUT;
    if (init.metricName != null) {
      this.metric = (_a12 = init.metrics) == null ? void 0 : _a12.registerMetricGroup(init.metricName);
    }
  }
  getTimeoutSignal(options = {}) {
    const timeout = Math.max(Math.round(this.next.movingAverage * (options.timeoutFactor ?? this.timeoutMultiplier)), this.minTimeout);
    const sendTimeout = AbortSignal.timeout(timeout);
    const timeoutSignal = anySignal([options.signal, sendTimeout]);
    setMaxListeners(Infinity, timeoutSignal, sendTimeout);
    timeoutSignal.start = Date.now();
    timeoutSignal.timeout = timeout;
    return timeoutSignal;
  }
  cleanUp(signal) {
    var _a12, _b4;
    const time = Date.now() - signal.start;
    if (signal.aborted) {
      this.failure.push(time);
      this.next.push(time * this.failureMultiplier);
      (_a12 = this.metric) == null ? void 0 : _a12.update({
        failureMovingAverage: this.failure.movingAverage,
        failureDeviation: this.failure.deviation,
        failureForecast: this.failure.forecast,
        failureVariance: this.failure.variance,
        failure: time
      });
    } else {
      this.success.push(time);
      this.next.push(time);
      (_b4 = this.metric) == null ? void 0 : _b4.update({
        successMovingAverage: this.success.movingAverage,
        successDeviation: this.success.deviation,
        successForecast: this.success.forecast,
        successVariance: this.success.variance,
        success: time
      });
    }
  }
};

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/connection-monitor.js
var DEFAULT_PING_INTERVAL_MS = 1e4;
var PROTOCOL_VERSION = "1.0.0";
var PROTOCOL_NAME = "ping";
var PROTOCOL_PREFIX = "ipfs";
var PING_LENGTH = 32;
var DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE = true;
var _a4, _b;
_b = Symbol.toStringTag, _a4 = serviceCapabilities;
var ConnectionMonitor = class {
  constructor(components, init = {}) {
    __publicField(this, "protocol");
    __publicField(this, "components");
    __publicField(this, "log");
    __publicField(this, "heartbeatInterval");
    __publicField(this, "pingIntervalMs");
    __publicField(this, "abortController");
    __publicField(this, "timeout");
    __publicField(this, "abortConnectionOnPingFailure");
    __publicField(this, _b, "@libp2p/connection-monitor");
    __publicField(this, _a4, [
      "@libp2p/connection-monitor"
    ]);
    this.components = components;
    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
    this.log = components.logger.forComponent("libp2p:connection-monitor");
    this.pingIntervalMs = init.pingInterval ?? DEFAULT_PING_INTERVAL_MS;
    this.abortConnectionOnPingFailure = init.abortConnectionOnPingFailure ?? DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE;
    this.timeout = new AdaptiveTimeout({
      ...init.pingTimeout ?? {},
      metrics: components.metrics,
      metricName: "libp2p_connection_monitor_ping_time_milliseconds"
    });
  }
  start() {
    this.abortController = new AbortController();
    setMaxListeners(Infinity, this.abortController.signal);
    this.heartbeatInterval = setInterval(() => {
      this.components.connectionManager.getConnections().forEach((conn) => {
        Promise.resolve().then(async () => {
          var _a12;
          let start2 = Date.now();
          try {
            const signal = this.timeout.getTimeoutSignal({
              signal: (_a12 = this.abortController) == null ? void 0 : _a12.signal
            });
            const stream = await conn.newStream(this.protocol, {
              signal,
              runOnLimitedConnection: true
            });
            const bs = byteStream(stream);
            start2 = Date.now();
            await Promise.all([
              bs.write(randomBytes(PING_LENGTH), {
                signal
              }),
              bs.read(PING_LENGTH, {
                signal
              })
            ]);
            conn.rtt = Date.now() - start2;
            await bs.unwrap().close({
              signal
            });
          } catch (err) {
            if (err.name !== "UnsupportedProtocolError") {
              throw err;
            }
            conn.rtt = (Date.now() - start2) / 2;
          }
        }).catch((err) => {
          this.log.error("error during heartbeat", err);
          if (this.abortConnectionOnPingFailure) {
            this.log.error("aborting connection due to ping failure");
            conn.abort(err);
          } else {
            this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag");
          }
        });
      });
    }, this.pingIntervalMs);
  }
  stop() {
    var _a12;
    (_a12 = this.abortController) == null ? void 0 : _a12.abort();
    if (this.heartbeatInterval != null) {
      clearInterval(this.heartbeatInterval);
    }
  }
};

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/content-routing.js
var _a5;
_a5 = Symbol.toStringTag;
var CompoundContentRouting = class {
  constructor(components, init) {
    __publicField(this, "routers");
    __publicField(this, "started");
    __publicField(this, "components");
    __publicField(this, _a5, "@libp2p/content-routing");
    var _a12, _b4, _c, _d, _e;
    this.routers = init.routers ?? [];
    this.started = false;
    this.components = components;
    this.findProviders = ((_a12 = components.metrics) == null ? void 0 : _a12.traceFunction("libp2p.contentRouting.findProviders", this.findProviders.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      },
      getAttributesFromYieldedValue: (value, attrs) => {
        return {
          ...attrs,
          providers: [...Array.isArray(attrs.providers) ? attrs.providers : [], value.id.toString()]
        };
      }
    })) ?? this.findProviders;
    this.provide = ((_b4 = components.metrics) == null ? void 0 : _b4.traceFunction("libp2p.contentRouting.provide", this.provide.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      }
    })) ?? this.provide;
    this.cancelReprovide = ((_c = components.metrics) == null ? void 0 : _c.traceFunction("libp2p.contentRouting.cancelReprovide", this.cancelReprovide.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      }
    })) ?? this.cancelReprovide;
    this.put = ((_d = components.metrics) == null ? void 0 : _d.traceFunction("libp2p.contentRouting.put", this.put.bind(this), {
      optionsIndex: 2,
      getAttributesFromArgs: ([key]) => {
        return {
          key: toString(key, "base36")
        };
      }
    })) ?? this.put;
    this.get = ((_e = components.metrics) == null ? void 0 : _e.traceFunction("libp2p.contentRouting.get", this.get.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([key]) => {
        return {
          key: toString(key, "base36")
        };
      }
    })) ?? this.get;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
  }
  /**
   * Iterates over all content routers in parallel to find providers of the given key
   */
  async *findProviders(key, options = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    const self = this;
    const seen = new PeerSet();
    for await (const peer of src_default(...self.routers.map((router) => router.findProviders(key, options)))) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.components.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        });
      }
      if (seen.has(peer.id)) {
        continue;
      }
      seen.add(peer.id);
      yield peer;
    }
  }
  /**
   * Iterates over all content routers in parallel to notify it is
   * a provider of the given key
   */
  async provide(key, options = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    await Promise.all(this.routers.map(async (router) => {
      await router.provide(key, options);
    }));
  }
  async cancelReprovide(key, options = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    await Promise.all(this.routers.map(async (router) => {
      await router.cancelReprovide(key, options);
    }));
  }
  /**
   * Store the given key/value pair in the available content routings
   */
  async put(key, value, options) {
    if (!this.isStarted()) {
      throw new NotStartedError();
    }
    await Promise.all(this.routers.map(async (router) => {
      await router.put(key, value, options);
    }));
  }
  /**
   * Get the value to the given key.
   * Times out after 1 minute by default.
   */
  async get(key, options) {
    if (!this.isStarted()) {
      throw new NotStartedError();
    }
    return Promise.any(this.routers.map(async (router) => {
      return router.get(key, options);
    }));
  }
};

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/peer-routing.js
var _a6;
_a6 = Symbol.toStringTag;
var DefaultPeerRouting = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "peerId");
    __publicField(this, "peerStore");
    __publicField(this, "routers");
    __publicField(this, _a6, "@libp2p/peer-routing");
    var _a12, _b4;
    this.log = components.logger.forComponent("libp2p:peer-routing");
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.routers = init.routers ?? [];
    this.findPeer = ((_a12 = components.metrics) == null ? void 0 : _a12.traceFunction("libp2p.peerRouting.findPeer", this.findPeer.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([peer], attrs) => {
        return {
          ...attrs,
          peer: peer.toString()
        };
      }
    })) ?? this.findPeer;
    this.getClosestPeers = ((_b4 = components.metrics) == null ? void 0 : _b4.traceFunction("libp2p.peerRouting.getClosestPeers", this.getClosestPeers.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([key], attrs) => {
        return {
          ...attrs,
          key: toString(key, "base36")
        };
      },
      getAttributesFromYieldedValue: (value, attrs) => {
        return {
          ...attrs,
          peers: [...Array.isArray(attrs.peers) ? attrs.peers : [], value.id.toString()]
        };
      }
    })) ?? this.getClosestPeers;
  }
  /**
   * Iterates over all peer routers in parallel to find the given peer
   */
  async findPeer(id, options) {
    if (this.routers.length === 0) {
      throw new NoPeerRoutersError("No peer routers available");
    }
    if (id.toString() === this.peerId.toString()) {
      throw new QueriedForSelfError("Should not try to find self");
    }
    const self = this;
    const source = src_default(...this.routers.map((router) => async function* () {
      try {
        yield await router.findPeer(id, options);
      } catch (err) {
        self.log.error(err);
      }
    }()));
    for await (const peer of source) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        });
      }
      return peer;
    }
    throw new NotFoundError();
  }
  /**
   * Attempt to find the closest peers on the network to the given key
   */
  async *getClosestPeers(key, options = {}) {
    if (this.routers.length === 0) {
      throw new NoPeerRoutersError("No peer routers available");
    }
    const self = this;
    const seen = createScalableCuckooFilter(1024);
    for await (const peer of parallel(async function* () {
      const source = src_default(...self.routers.map((router) => router.getClosestPeers(key, options)));
      for await (let peer2 of source) {
        yield async () => {
          if (peer2.multiaddrs.length === 0) {
            try {
              peer2 = await self.findPeer(peer2.id, {
                ...options,
                useCache: false
              });
            } catch (err) {
              self.log.error("could not find peer multiaddrs", err);
              return;
            }
          }
          return peer2;
        };
      }
    }())) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        });
      }
      if (seen.has(peer.id.toMultihash().bytes)) {
        continue;
      }
      seen.add(peer.id.toMultihash().bytes);
      yield peer;
    }
  }
};

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/random-walk.js
var _a7, _b2;
var RandomWalk = class extends (_b2 = TypedEventEmitter, _a7 = Symbol.toStringTag, _b2) {
  constructor(components) {
    super();
    __publicField(this, "peerRouting");
    __publicField(this, "log");
    __publicField(this, "walking");
    __publicField(this, "walkers");
    __publicField(this, "shutdownController");
    __publicField(this, "walkController");
    __publicField(this, "needNext");
    __publicField(this, _a7, "@libp2p/random-walk");
    this.log = components.logger.forComponent("libp2p:random-walk");
    this.peerRouting = components.peerRouting;
    this.walkers = 0;
    this.walking = false;
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
  }
  start() {
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
  }
  stop() {
    this.shutdownController.abort();
  }
  async *walk(options) {
    var _a12, _b4;
    if (!this.walking) {
      this.startWalk();
    }
    this.walkers++;
    const signal = anySignal([this.shutdownController.signal, options == null ? void 0 : options.signal]);
    setMaxListeners(Infinity, signal);
    try {
      while (true) {
        (_a12 = this.needNext) == null ? void 0 : _a12.resolve();
        this.needNext = pDefer();
        const event = await raceEvent(this, "walk:peer", signal, {
          errorEvent: "walk:error"
        });
        yield event.detail;
      }
    } finally {
      signal.clear();
      this.walkers--;
      if (this.walkers === 0) {
        (_b4 = this.walkController) == null ? void 0 : _b4.abort();
        this.walkController = void 0;
      }
    }
  }
  startWalk() {
    this.walking = true;
    this.walkController = new AbortController();
    setMaxListeners(Infinity, this.walkController.signal);
    const signal = anySignal([this.walkController.signal, this.shutdownController.signal]);
    setMaxListeners(Infinity, signal);
    const start2 = Date.now();
    let found = 0;
    Promise.resolve().then(async () => {
      this.log("start walk");
      while (this.walkers > 0) {
        try {
          const data = randomBytes(32);
          let s2 = Date.now();
          for await (const peer of this.peerRouting.getClosestPeers(data, { signal })) {
            if (signal.aborted) {
              this.log("aborting walk");
            }
            signal.throwIfAborted();
            this.log("found peer %p after %dms for %d walkers", peer.id, Date.now() - s2, this.walkers);
            found++;
            this.safeDispatchEvent("walk:peer", {
              detail: peer
            });
            if (this.walkers === 1 && this.needNext != null) {
              this.log("wait for need next");
              await raceSignal(this.needNext.promise, signal);
            }
            s2 = Date.now();
          }
          this.log("walk iteration for %b and %d walkers finished, found %d peers", data, this.walkers, found);
        } catch (err) {
          this.log.error("random walk errored", err);
          this.safeDispatchEvent("walk:error", {
            detail: err
          });
        }
      }
      this.log("no walkers left, ended walk");
    }).catch((err) => {
      this.log.error("random walk errored", err);
    }).finally(() => {
      this.log("finished walk, found %d peers after %dms", found, Date.now() - start2);
      this.walking = false;
    });
  }
};

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/registrar.js
var DEFAULT_MAX_INBOUND_STREAMS = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS = 64;
var _a8;
_a8 = Symbol.toStringTag;
var Registrar = class {
  constructor(components) {
    __publicField(this, "log");
    __publicField(this, "topologies");
    __publicField(this, "handlers");
    __publicField(this, "components");
    __publicField(this, _a8, "@libp2p/registrar");
    this.log = components.logger.forComponent("libp2p:registrar");
    this.topologies = /* @__PURE__ */ new Map();
    this.handlers = /* @__PURE__ */ new Map();
    this.components = components;
    this._onDisconnect = this._onDisconnect.bind(this);
    this._onPeerUpdate = this._onPeerUpdate.bind(this);
    this._onPeerIdentify = this._onPeerIdentify.bind(this);
    this.components.events.addEventListener("peer:disconnect", this._onDisconnect);
    this.components.events.addEventListener("peer:update", this._onPeerUpdate);
    this.components.events.addEventListener("peer:identify", this._onPeerIdentify);
  }
  getProtocols() {
    return Array.from(/* @__PURE__ */ new Set([
      ...this.handlers.keys()
    ])).sort();
  }
  getHandler(protocol) {
    const handler = this.handlers.get(protocol);
    if (handler == null) {
      throw new UnhandledProtocolError(`No handler registered for protocol ${protocol}`);
    }
    return handler;
  }
  getTopologies(protocol) {
    const topologies = this.topologies.get(protocol);
    if (topologies == null) {
      return [];
    }
    return [
      ...topologies.values()
    ];
  }
  /**
   * Registers the `handler` for each protocol
   */
  async handle(protocol, handler, opts) {
    if (this.handlers.has(protocol) && (opts == null ? void 0 : opts.force) !== true) {
      throw new DuplicateProtocolHandlerError(`Handler already registered for protocol ${protocol}`);
    }
    const options = merge_options_default.bind({ ignoreUndefined: true })({
      maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,
      maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS
    }, opts);
    this.handlers.set(protocol, {
      handler,
      options
    });
    await this.components.peerStore.merge(this.components.peerId, {
      protocols: [protocol]
    });
  }
  /**
   * Removes the handler for each protocol. The protocol
   * will no longer be supported on streams.
   */
  async unhandle(protocols) {
    const protocolList = Array.isArray(protocols) ? protocols : [protocols];
    protocolList.forEach((protocol) => {
      this.handlers.delete(protocol);
    });
    await this.components.peerStore.patch(this.components.peerId, {
      protocols: this.getProtocols()
    });
  }
  /**
   * Register handlers for a set of multicodecs given
   */
  async register(protocol, topology) {
    if (topology == null) {
      throw new InvalidParametersError("invalid topology");
    }
    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
    let topologies = this.topologies.get(protocol);
    if (topologies == null) {
      topologies = /* @__PURE__ */ new Map();
      this.topologies.set(protocol, topologies);
    }
    topologies.set(id, topology);
    return id;
  }
  /**
   * Unregister topology
   */
  unregister(id) {
    for (const [protocol, topologies] of this.topologies.entries()) {
      if (topologies.has(id)) {
        topologies.delete(id);
        if (topologies.size === 0) {
          this.topologies.delete(protocol);
        }
      }
    }
  }
  /**
   * Remove a disconnected peer from the record
   */
  _onDisconnect(evt) {
    const remotePeer = evt.detail;
    void this.components.peerStore.get(remotePeer).then((peer) => {
      var _a12, _b4, _c;
      for (const protocol of peer.protocols) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        for (const topology of topologies.values()) {
          if (((_a12 = topology.filter) == null ? void 0 : _a12.has(remotePeer)) === false) {
            continue;
          }
          (_b4 = topology.filter) == null ? void 0 : _b4.remove(remotePeer);
          (_c = topology.onDisconnect) == null ? void 0 : _c.call(topology, remotePeer);
        }
      }
    }).catch((err) => {
      if (err.name === "NotFoundError") {
        return;
      }
      this.log.error("could not inform topologies of disconnecting peer %p", remotePeer, err);
    });
  }
  /**
   * When a peer is updated, if they have removed supported protocols notify any
   * topologies interested in the removed protocols.
   */
  _onPeerUpdate(evt) {
    var _a12, _b4, _c;
    const { peer, previous } = evt.detail;
    const removed = ((previous == null ? void 0 : previous.protocols) ?? []).filter((protocol) => !peer.protocols.includes(protocol));
    for (const protocol of removed) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        if (((_a12 = topology.filter) == null ? void 0 : _a12.has(peer.id)) === false) {
          continue;
        }
        (_b4 = topology.filter) == null ? void 0 : _b4.remove(peer.id);
        (_c = topology.onDisconnect) == null ? void 0 : _c.call(topology, peer.id);
      }
    }
  }
  /**
   * After identify has completed and we have received the list of supported
   * protocols, notify any topologies interested in those protocols.
   */
  _onPeerIdentify(evt) {
    var _a12, _b4, _c;
    const protocols = evt.detail.protocols;
    const connection = evt.detail.connection;
    const peerId = evt.detail.peerId;
    for (const protocol of protocols) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        if (connection.limits != null && topology.notifyOnLimitedConnection !== true) {
          continue;
        }
        if (((_a12 = topology.filter) == null ? void 0 : _a12.has(peerId)) === true) {
          continue;
        }
        (_b4 = topology.filter) == null ? void 0 : _b4.add(peerId);
        (_c = topology.onConnect) == null ? void 0 : _c.call(topology, peerId, connection);
      }
    }
  }
};

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/tracked-map.js
var TrackedMap = class extends Map {
  constructor(init) {
    super();
    __publicField(this, "metric");
    const { name: name2, metrics } = init;
    this.metric = metrics.registerMetric(name2);
    this.updateComponentMetric();
  }
  set(key, value) {
    super.set(key, value);
    this.updateComponentMetric();
    return this;
  }
  delete(key) {
    const deleted = super.delete(key);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metric.update(this.size);
  }
};
function trackedMap(config) {
  const { name: name2, metrics } = config;
  let map;
  if (metrics != null) {
    map = new TrackedMap({ name: name2, metrics });
  } else {
    map = /* @__PURE__ */ new Map();
  }
  return map;
}

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/transport-manager.js
var _a9;
_a9 = Symbol.toStringTag;
var DefaultTransportManager = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "components");
    __publicField(this, "transports");
    __publicField(this, "listeners");
    __publicField(this, "faultTolerance");
    __publicField(this, "started");
    __publicField(this, _a9, "@libp2p/transport-manager");
    this.log = components.logger.forComponent("libp2p:transports");
    this.components = components;
    this.started = false;
    this.transports = /* @__PURE__ */ new Map();
    this.listeners = trackedMap({
      name: "libp2p_transport_manager_listeners",
      metrics: this.components.metrics
    });
    this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL;
  }
  /**
   * Adds a `Transport` to the manager
   */
  add(transport) {
    const tag = transport[Symbol.toStringTag];
    if (tag == null) {
      throw new InvalidParametersError("Transport must have a valid tag");
    }
    if (this.transports.has(tag)) {
      throw new InvalidParametersError(`There is already a transport with the tag ${tag}`);
    }
    this.log("adding transport %s", tag);
    this.transports.set(tag, transport);
    if (!this.listeners.has(tag)) {
      this.listeners.set(tag, []);
    }
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  async afterStart() {
    const addrs = this.components.addressManager.getListenAddrs();
    await this.listen(addrs);
  }
  /**
   * Stops all listeners
   */
  async stop() {
    const tasks = [];
    for (const [key, listeners] of this.listeners) {
      this.log("closing listeners for %s", key);
      while (listeners.length > 0) {
        const listener = listeners.pop();
        if (listener == null) {
          continue;
        }
        tasks.push(listener.close());
      }
    }
    await Promise.all(tasks);
    this.log("all listeners closed");
    for (const key of this.listeners.keys()) {
      this.listeners.set(key, []);
    }
    this.started = false;
  }
  /**
   * Dials the given Multiaddr over it's supported transport
   */
  async dial(ma, options) {
    var _a12;
    const transport = this.dialTransportForMultiaddr(ma);
    if (transport == null) {
      throw new TransportUnavailableError(`No transport available for address ${String(ma)}`);
    }
    (_a12 = options == null ? void 0 : options.onProgress) == null ? void 0 : _a12.call(options, new CustomProgressEvent("transport-manager:selected-transport", transport[Symbol.toStringTag]));
    return transport.dial(ma, {
      ...options,
      upgrader: this.components.upgrader
    });
  }
  /**
   * Returns all Multiaddr's the listeners are using
   */
  getAddrs() {
    let addrs = [];
    for (const listeners of this.listeners.values()) {
      for (const listener of listeners) {
        addrs = [...addrs, ...listener.getAddrs()];
      }
    }
    return addrs;
  }
  /**
   * Returns all the transports instances
   */
  getTransports() {
    return Array.of(...this.transports.values());
  }
  /**
   * Returns all the listener instances
   */
  getListeners() {
    return Array.of(...this.listeners.values()).flat();
  }
  /**
   * Finds a transport that matches the given Multiaddr
   */
  dialTransportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.dialFilter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  /**
   * Finds a transport that matches the given Multiaddr
   */
  listenTransportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.listenFilter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  /**
   * Starts listeners for each listen Multiaddr
   */
  async listen(addrs) {
    if (!this.isStarted()) {
      throw new NotStartedError("Not started");
    }
    if (addrs == null || addrs.length === 0) {
      this.log("no addresses were provided for listening, this node is dial only");
      return;
    }
    const listenStats = {
      errors: /* @__PURE__ */ new Map(),
      ipv4: {
        success: 0,
        attempts: 0
      },
      ipv6: {
        success: 0,
        attempts: 0
      }
    };
    addrs.forEach((ma) => {
      listenStats.errors.set(ma.toString(), new UnsupportedListenAddressError());
    });
    const tasks = [];
    for (const [key, transport] of this.transports.entries()) {
      const supportedAddrs = transport.listenFilter(addrs);
      for (const addr of supportedAddrs) {
        this.log("creating listener for %s on %a", key, addr);
        const listener = transport.createListener({
          upgrader: this.components.upgrader
        });
        let listeners = this.listeners.get(key) ?? [];
        if (listeners == null) {
          listeners = [];
          this.listeners.set(key, listeners);
        }
        listeners.push(listener);
        listener.addEventListener("listening", () => {
          this.components.events.safeDispatchEvent("transport:listening", {
            detail: listener
          });
        });
        listener.addEventListener("close", () => {
          const index = listeners.findIndex((l) => l === listener);
          listeners.splice(index, 1);
          this.components.events.safeDispatchEvent("transport:close", {
            detail: listener
          });
        });
        if (IP4.matches(addr)) {
          listenStats.ipv4.attempts++;
        } else if (IP6.matches(addr)) {
          listenStats.ipv6.attempts++;
        }
        tasks.push(listener.listen(addr).then(() => {
          listenStats.errors.delete(addr.toString());
          if (IP4.matches(addr)) {
            listenStats.ipv4.success++;
          }
          if (IP6.matches(addr)) {
            listenStats.ipv6.success++;
          }
        }, (err) => {
          this.log.error("transport %s could not listen on address %a - %e", key, addr, err);
          listenStats.errors.set(addr.toString(), err);
          throw err;
        }));
      }
    }
    const results = await Promise.allSettled(tasks);
    if (results.length > 0 && results.every((res) => res.status === "fulfilled")) {
      return;
    }
    if (this.ipv6Unsupported(listenStats)) {
      this.log("all IPv4 addresses succeed but all IPv6 failed");
      return;
    }
    if (this.faultTolerance === FaultTolerance.NO_FATAL) {
      this.log("failed to listen on any address but fault tolerance allows this");
      return;
    }
    throw new UnsupportedListenAddressesError(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...listenStats.errors.entries()].map(([addr, err]) => {
      return `
  ${addr}: ${`${err.stack ?? err}`.split("\n").join("\n  ")}
`;
    }).join("")}`);
  }
  ipv6Unsupported(listenStats) {
    if (listenStats.ipv4.attempts === 0 || listenStats.ipv6.attempts === 0) {
      return false;
    }
    const allIpv4Succeeded = listenStats.ipv4.attempts === listenStats.ipv4.success;
    const allIpv6Failed = listenStats.ipv6.success === 0;
    return allIpv4Succeeded && allIpv6Failed;
  }
  /**
   * Removes the given transport from the manager.
   * If a transport has any running listeners, they will be closed.
   */
  async remove(key) {
    const listeners = this.listeners.get(key) ?? [];
    this.log.trace("removing transport %s", key);
    const tasks = [];
    this.log.trace("closing listeners for %s", key);
    while (listeners.length > 0) {
      const listener = listeners.pop();
      if (listener == null) {
        continue;
      }
      tasks.push(listener.close());
    }
    await Promise.all(tasks);
    this.transports.delete(key);
    this.listeners.delete(key);
  }
  /**
   * Removes all transports from the manager.
   * If any listeners are running, they will be closed.
   *
   * @async
   */
  async removeAll() {
    const tasks = [];
    for (const key of this.transports.keys()) {
      tasks.push(this.remove(key));
    }
    await Promise.all(tasks);
  }
};

// node_modules/.pnpm/@libp2p+multistream-select@6.0.20/node_modules/@libp2p/multistream-select/dist/src/constants.js
var PROTOCOL_ID = "/multistream/1.0.0";
var MAX_PROTOCOL_LENGTH = 1024;

// node_modules/.pnpm/@libp2p+multistream-select@6.0.20/node_modules/@libp2p/multistream-select/dist/src/multistream.js
var NewLine = fromString("\n");
async function write(writer, buffer, options) {
  await writer.write(buffer, options);
}
async function writeAll(writer, buffers, options) {
  await writer.writeV(buffers, options);
}
async function read(reader, options) {
  const buf = await reader.read(options);
  if (buf.byteLength === 0 || buf.get(buf.byteLength - 1) !== NewLine[0]) {
    options.log.error("Invalid mss message - missing newline", buf);
    throw new InvalidMessageError("Missing newline");
  }
  return buf.sublist(0, -1);
}
async function readString(reader, options) {
  const buf = await read(reader, options);
  return toString(buf.subarray());
}

// node_modules/.pnpm/@libp2p+multistream-select@6.0.20/node_modules/@libp2p/multistream-select/dist/src/select.js
async function select(stream, protocols, options) {
  protocols = Array.isArray(protocols) ? [...protocols] : [protocols];
  if (protocols.length === 1 && options.negotiateFully === false) {
    return optimisticSelect(stream, protocols[0], options);
  }
  const lp = lpStream(stream, {
    ...options,
    maxDataLength: MAX_PROTOCOL_LENGTH
  });
  const protocol = protocols.shift();
  if (protocol == null) {
    throw new Error("At least one protocol must be specified");
  }
  options.log.trace('select: write ["%s", "%s"]', PROTOCOL_ID, protocol);
  const p1 = fromString(`${PROTOCOL_ID}
`);
  const p2 = fromString(`${protocol}
`);
  await writeAll(lp, [p1, p2], options);
  options.log.trace("select: reading multistream-select header");
  let response = await readString(lp, options);
  options.log.trace('select: read "%s"', response);
  if (response === PROTOCOL_ID) {
    options.log.trace("select: reading protocol response");
    response = await readString(lp, options);
    options.log.trace('select: read "%s"', response);
  }
  if (response === protocol) {
    return { stream: lp.unwrap(), protocol };
  }
  for (const protocol2 of protocols) {
    options.log.trace('select: write "%s"', protocol2);
    await write(lp, fromString(`${protocol2}
`), options);
    options.log.trace("select: reading protocol response");
    const response2 = await readString(lp, options);
    options.log.trace('select: read "%s" for "%s"', response2, protocol2);
    if (response2 === protocol2) {
      return { stream: lp.unwrap(), protocol: protocol2 };
    }
  }
  throw new UnsupportedProtocolError("protocol selection failed");
}
function optimisticSelect(stream, protocol, options) {
  const originalSink = stream.sink.bind(stream);
  const originalSource = stream.source;
  let negotiated = false;
  let negotiating = false;
  const doneNegotiating = pDefer();
  let sentProtocol = false;
  let sendingProtocol = false;
  const doneSendingProtocol = pDefer();
  let readProtocol = false;
  let readingProtocol = false;
  const doneReadingProtocol = pDefer();
  const lp = lpStream({
    sink: originalSink,
    source: originalSource
  }, {
    ...options,
    maxDataLength: MAX_PROTOCOL_LENGTH
  });
  stream.sink = async (source) => {
    const { sink } = lp.unwrap();
    await sink(async function* () {
      let sentData = false;
      for await (const buf of source) {
        if (sendingProtocol) {
          await doneSendingProtocol.promise;
        }
        if (!sentProtocol) {
          sendingProtocol = true;
          options.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink', PROTOCOL_ID, protocol, buf.byteLength);
          const protocolString = `${protocol}
`;
          yield new Uint8ArrayList(
            Uint8Array.from([19]),
            // length of PROTOCOL_ID plus newline
            fromString(`${PROTOCOL_ID}
`),
            encode(protocolString.length),
            fromString(protocolString),
            buf
          ).subarray();
          options.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink', PROTOCOL_ID, protocol, buf.byteLength);
          sentProtocol = true;
          sendingProtocol = false;
          doneSendingProtocol.resolve();
          negotiate().catch((err) => {
            options.log.error("could not finish optimistic protocol negotiation of %s", protocol, err);
          });
        } else {
          yield buf;
        }
        sentData = true;
      }
      if (!sentData) {
        await negotiate();
      }
    }());
  };
  async function negotiate() {
    if (negotiating) {
      options.log.trace("optimistic: already negotiating %s stream", protocol);
      await doneNegotiating.promise;
      return;
    }
    negotiating = true;
    try {
      if (!sentProtocol) {
        options.log.trace("optimistic: doing send protocol for %s stream", protocol);
        await doSendProtocol();
      }
      if (!readProtocol) {
        options.log.trace("optimistic: doing read protocol for %s stream", protocol);
        await doReadProtocol();
      }
    } finally {
      negotiating = false;
      negotiated = true;
      doneNegotiating.resolve();
    }
  }
  async function doSendProtocol() {
    if (sendingProtocol) {
      await doneSendingProtocol.promise;
      return;
    }
    sendingProtocol = true;
    try {
      options.log.trace('optimistic: write ["%s", "%s", data] in source', PROTOCOL_ID, protocol);
      await lp.writeV([
        fromString(`${PROTOCOL_ID}
`),
        fromString(`${protocol}
`)
      ]);
      options.log.trace('optimistic: wrote ["%s", "%s", data] in source', PROTOCOL_ID, protocol);
    } finally {
      sentProtocol = true;
      sendingProtocol = false;
      doneSendingProtocol.resolve();
    }
  }
  async function doReadProtocol() {
    if (readingProtocol) {
      await doneReadingProtocol.promise;
      return;
    }
    readingProtocol = true;
    try {
      options.log.trace("optimistic: reading multistream select header");
      let response = await readString(lp, options);
      options.log.trace('optimistic: read multistream select header "%s"', response);
      if (response === PROTOCOL_ID) {
        response = await readString(lp, options);
      }
      options.log.trace('optimistic: read protocol "%s", expecting "%s"', response, protocol);
      if (response !== protocol) {
        throw new UnsupportedProtocolError("protocol selection failed");
      }
    } finally {
      readProtocol = true;
      readingProtocol = false;
      doneReadingProtocol.resolve();
    }
  }
  stream.source = async function* () {
    await negotiate();
    options.log.trace('optimistic: reading data from "%s" stream', protocol);
    yield* lp.unwrap().source;
  }();
  if (stream.closeRead != null) {
    const originalCloseRead = stream.closeRead.bind(stream);
    stream.closeRead = async (opts) => {
      if (!negotiated) {
        await negotiate().catch((err) => {
          options.log.error("could not negotiate protocol before close read", err);
        });
      }
      await originalCloseRead(opts);
    };
  }
  if (stream.closeWrite != null) {
    const originalCloseWrite = stream.closeWrite.bind(stream);
    stream.closeWrite = async (opts) => {
      if (!negotiated) {
        await negotiate().catch((err) => {
          options.log.error("could not negotiate protocol before close write", err);
        });
      }
      await originalCloseWrite(opts);
    };
  }
  if (stream.close != null) {
    const originalClose = stream.close.bind(stream);
    stream.close = async (opts) => {
      const tasks = [];
      if (sendingProtocol) {
        tasks.push(doneSendingProtocol.promise);
      }
      if (readingProtocol) {
        tasks.push(doneReadingProtocol.promise);
      }
      if (tasks.length > 0) {
        await raceSignal(Promise.all(tasks), opts == null ? void 0 : opts.signal);
      } else {
        negotiated = true;
        negotiating = false;
        doneNegotiating.resolve();
      }
      await originalClose(opts);
    };
  }
  return {
    stream,
    protocol
  };
}

// node_modules/.pnpm/@libp2p+multistream-select@6.0.20/node_modules/@libp2p/multistream-select/dist/src/handle.js
async function handle(stream, protocols, options) {
  protocols = Array.isArray(protocols) ? protocols : [protocols];
  options.log.trace("handle: available protocols %s", protocols);
  const lp = lpStream(stream, {
    ...options,
    maxDataLength: MAX_PROTOCOL_LENGTH,
    maxLengthLength: 2
    // 2 bytes is enough to length-prefix MAX_PROTOCOL_LENGTH
  });
  while (true) {
    options.log.trace("handle: reading incoming string");
    const protocol = await readString(lp, options);
    options.log.trace('handle: read "%s"', protocol);
    if (protocol === PROTOCOL_ID) {
      options.log.trace('handle: respond with "%s" for "%s"', PROTOCOL_ID, protocol);
      await write(lp, fromString(`${PROTOCOL_ID}
`), options);
      options.log.trace('handle: responded with "%s" for "%s"', PROTOCOL_ID, protocol);
      continue;
    }
    if (protocols.includes(protocol)) {
      options.log.trace('handle: respond with "%s" for "%s"', protocol, protocol);
      await write(lp, fromString(`${protocol}
`), options);
      options.log.trace('handle: responded with "%s" for "%s"', protocol, protocol);
      return { stream: lp.unwrap(), protocol };
    }
    if (protocol === "ls") {
      const protos = new Uint8ArrayList(...protocols.map((p) => encode2.single(fromString(`${p}
`))), fromString("\n"));
      options.log.trace('handle: respond with "%s" for %s', protocols, protocol);
      await write(lp, protos, options);
      options.log.trace('handle: responded with "%s" for %s', protocols, protocol);
      continue;
    }
    options.log.trace('handle: respond with "na" for "%s"', protocol);
    await write(lp, fromString("na\n"), options);
    options.log('handle: responded with "na" for "%s"', protocol);
  }
}

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/connection/index.js
var CLOSE_TIMEOUT = 500;
var _a10, _b3;
_b3 = Symbol.toStringTag, _a10 = connectionSymbol;
var ConnectionImpl = class {
  /**
   * An implementation of the js-libp2p connection.
   * Any libp2p transport should use an upgrader to return this connection.
   */
  constructor(init) {
    /**
     * Connection identifier.
     */
    __publicField(this, "id");
    /**
     * Observed multiaddr of the remote peer
     */
    __publicField(this, "remoteAddr");
    /**
     * Remote peer id
     */
    __publicField(this, "remotePeer");
    __publicField(this, "direction");
    __publicField(this, "timeline");
    __publicField(this, "multiplexer");
    __publicField(this, "encryption");
    __publicField(this, "status");
    __publicField(this, "limits");
    __publicField(this, "log");
    /**
     * User provided tags
     *
     */
    __publicField(this, "tags");
    /**
     * Reference to the new stream function of the multiplexer
     */
    __publicField(this, "_newStream");
    /**
     * Reference to the close function of the raw connection
     */
    __publicField(this, "_close");
    __publicField(this, "_abort");
    /**
     * Reference to the getStreams function of the muxer
     */
    __publicField(this, "_getStreams");
    __publicField(this, _b3, "Connection");
    __publicField(this, _a10, true);
    const { remoteAddr, remotePeer, newStream, close, abort, getStreams } = init;
    this.id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
    this.remoteAddr = remoteAddr;
    this.remotePeer = remotePeer;
    this.direction = init.direction;
    this.status = "open";
    this.timeline = init.timeline;
    this.multiplexer = init.multiplexer;
    this.encryption = init.encryption;
    this.limits = init.limits;
    this.log = init.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`);
    if (this.remoteAddr.getPeerId() == null) {
      this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`);
    }
    this._newStream = newStream;
    this._close = close;
    this._abort = abort;
    this._getStreams = getStreams;
    this.tags = [];
  }
  /**
   * Get all the streams of the muxer
   */
  get streams() {
    return this._getStreams();
  }
  /**
   * Create a new stream from this connection
   */
  async newStream(protocols, options) {
    if (this.status === "closing") {
      throw new ConnectionClosingError("the connection is being closed");
    }
    if (this.status === "closed") {
      throw new ConnectionClosedError("the connection is closed");
    }
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    if (this.limits != null && (options == null ? void 0 : options.runOnLimitedConnection) !== true) {
      throw new LimitedConnectionError("Cannot open protocol stream on limited connection");
    }
    const stream = await this._newStream(protocols, options);
    stream.direction = "outbound";
    return stream;
  }
  /**
   * Close the connection
   */
  async close(options = {}) {
    if (this.status === "closed" || this.status === "closing") {
      return;
    }
    this.log("closing connection to %a", this.remoteAddr);
    this.status = "closing";
    if (options.signal == null) {
      const signal = AbortSignal.timeout(CLOSE_TIMEOUT);
      setMaxListeners(Infinity, signal);
      options = {
        ...options,
        signal
      };
    }
    try {
      this.log.trace("closing underlying transport");
      await this._close(options);
      this.log.trace("updating timeline with close time");
      this.status = "closed";
      this.timeline.close = Date.now();
    } catch (err) {
      this.log.error("error encountered during graceful close of connection to %a", this.remoteAddr, err);
      this.abort(err);
    }
  }
  abort(err) {
    if (this.status === "closed") {
      return;
    }
    this.log.error("aborting connection to %a due to error", this.remoteAddr, err);
    this.status = "closing";
    this._abort(err);
    this.status = "closed";
    this.timeline.close = Date.now();
  }
};
function createConnection(init) {
  return new ConnectionImpl(init);
}

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/upgrader.js
function findIncomingStreamLimit(protocol, registrar) {
  try {
    const { options } = registrar.getHandler(protocol);
    return options.maxInboundStreams;
  } catch (err) {
    if (err.name !== "UnhandledProtocolError") {
      throw err;
    }
  }
  return DEFAULT_MAX_INBOUND_STREAMS;
}
function findOutgoingStreamLimit(protocol, registrar, options = {}) {
  try {
    const { options: options2 } = registrar.getHandler(protocol);
    if (options2.maxOutboundStreams != null) {
      return options2.maxOutboundStreams;
    }
  } catch (err) {
    if (err.name !== "UnhandledProtocolError") {
      throw err;
    }
  }
  return options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;
}
function countStreams(protocol, direction, connection) {
  let streamCount = 0;
  connection.streams.forEach((stream) => {
    if (stream.direction === direction && stream.protocol === protocol) {
      streamCount++;
    }
  });
  return streamCount;
}
var _a11;
_a11 = Symbol.toStringTag;
var Upgrader = class {
  constructor(components, init) {
    __publicField(this, "components");
    __publicField(this, "connectionEncrypters");
    __publicField(this, "streamMuxers");
    __publicField(this, "inboundUpgradeTimeout");
    __publicField(this, "inboundStreamProtocolNegotiationTimeout");
    __publicField(this, "outboundStreamProtocolNegotiationTimeout");
    __publicField(this, "events");
    __publicField(this, "metrics");
    __publicField(this, _a11, "@libp2p/upgrader");
    var _a12, _b4;
    this.components = components;
    this.connectionEncrypters = /* @__PURE__ */ new Map();
    init.connectionEncrypters.forEach((encrypter) => {
      this.connectionEncrypters.set(encrypter.protocol, encrypter);
    });
    this.streamMuxers = /* @__PURE__ */ new Map();
    init.streamMuxers.forEach((muxer) => {
      this.streamMuxers.set(muxer.protocol, muxer);
    });
    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? INBOUND_UPGRADE_TIMEOUT;
    this.inboundStreamProtocolNegotiationTimeout = init.inboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
    this.outboundStreamProtocolNegotiationTimeout = init.outboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
    this.events = components.events;
    this.metrics = {
      dials: (_a12 = components.metrics) == null ? void 0 : _a12.registerCounterGroup("libp2p_connection_manager_dials_total"),
      errors: (_b4 = components.metrics) == null ? void 0 : _b4.registerCounterGroup("libp2p_connection_manager_dial_errors_total")
    };
  }
  async shouldBlockConnection(method, ...args) {
    const denyOperation = this.components.connectionGater[method];
    if (denyOperation == null) {
      return;
    }
    const result = await denyOperation.apply(this.components.connectionGater, args);
    if (result === true) {
      throw new ConnectionInterceptedError(`The multiaddr connection is blocked by gater.${method}`);
    }
  }
  createInboundAbortSignal(signal) {
    const output = anySignal([
      AbortSignal.timeout(this.inboundUpgradeTimeout),
      signal
    ]);
    setMaxListeners(Infinity, output);
    return output;
  }
  /**
   * Upgrades an inbound connection
   */
  async upgradeInbound(maConn, opts) {
    var _a12, _b4;
    let accepted = false;
    const signal = this.createInboundAbortSignal(opts.signal);
    try {
      (_a12 = this.metrics.dials) == null ? void 0 : _a12.increment({
        inbound: true
      });
      accepted = await this.components.connectionManager.acceptIncomingConnection(maConn);
      if (!accepted) {
        throw new ConnectionDeniedError("Connection denied");
      }
      await this.shouldBlockConnection("denyInboundConnection", maConn);
      await this._performUpgrade(maConn, "inbound", {
        ...opts,
        signal
      });
    } catch (err) {
      (_b4 = this.metrics.errors) == null ? void 0 : _b4.increment({
        inbound: true
      });
      throw err;
    } finally {
      signal.clear();
      if (accepted) {
        this.components.connectionManager.afterUpgradeInbound();
      }
    }
  }
  /**
   * Upgrades an outbound connection
   */
  async upgradeOutbound(maConn, opts) {
    var _a12, _b4;
    try {
      (_a12 = this.metrics.dials) == null ? void 0 : _a12.increment({
        outbound: true
      });
      const idStr = maConn.remoteAddr.getPeerId();
      let remotePeerId;
      if (idStr != null) {
        remotePeerId = peerIdFromString(idStr);
        await this.shouldBlockConnection("denyOutboundConnection", remotePeerId, maConn);
      }
      let direction = "outbound";
      if (opts.initiator === false) {
        direction = "inbound";
      }
      return await this._performUpgrade(maConn, direction, opts);
    } catch (err) {
      (_b4 = this.metrics.errors) == null ? void 0 : _b4.increment({
        outbound: true
      });
      throw err;
    }
  }
  async _performUpgrade(maConn, direction, opts) {
    var _a12, _b4, _c;
    let encryptedConn;
    let remotePeer;
    let upgradedConn;
    let muxerFactory;
    let cryptoProtocol;
    (_a12 = this.components.metrics) == null ? void 0 : _a12.trackMultiaddrConnection(maConn);
    maConn.log.trace("starting the %s connection upgrade", direction);
    let protectedConn = maConn;
    if ((opts == null ? void 0 : opts.skipProtection) !== true) {
      const protector = this.components.connectionProtector;
      if (protector != null) {
        maConn.log("protecting the %s connection", direction);
        protectedConn = await protector.protect(maConn, opts);
      }
    }
    try {
      encryptedConn = protectedConn;
      if ((opts == null ? void 0 : opts.skipEncryption) !== true) {
        (_b4 = opts == null ? void 0 : opts.onProgress) == null ? void 0 : _b4.call(opts, new CustomProgressEvent(`upgrader:encrypt-${direction}-connection`));
        ({
          conn: encryptedConn,
          remotePeer,
          protocol: cryptoProtocol,
          streamMuxer: muxerFactory
        } = await (direction === "inbound" ? this._encryptInbound(protectedConn, opts) : this._encryptOutbound(protectedConn, opts)));
        const maConn2 = {
          ...protectedConn,
          ...encryptedConn
        };
        await this.shouldBlockConnection(direction === "inbound" ? "denyInboundEncryptedConnection" : "denyOutboundEncryptedConnection", remotePeer, maConn2);
      } else {
        const idStr = maConn.remoteAddr.getPeerId();
        if (idStr == null) {
          throw new InvalidMultiaddrError(`${direction} connection that skipped encryption must have a peer id`);
        }
        const remotePeerId = peerIdFromString(idStr);
        cryptoProtocol = "native";
        remotePeer = remotePeerId;
      }
      if (remotePeer.equals(this.components.peerId)) {
        const err = new InvalidPeerIdError("Can not dial self");
        maConn.abort(err);
        throw err;
      }
      upgradedConn = encryptedConn;
      if ((opts == null ? void 0 : opts.muxerFactory) != null) {
        muxerFactory = opts.muxerFactory;
      } else if (muxerFactory == null && this.streamMuxers.size > 0) {
        (_c = opts == null ? void 0 : opts.onProgress) == null ? void 0 : _c.call(opts, new CustomProgressEvent(`upgrader:multiplex-${direction}-connection`));
        const multiplexed = await (direction === "inbound" ? this._multiplexInbound({
          ...protectedConn,
          ...encryptedConn
        }, this.streamMuxers, opts) : this._multiplexOutbound({
          ...protectedConn,
          ...encryptedConn
        }, this.streamMuxers, opts));
        muxerFactory = multiplexed.muxerFactory;
        upgradedConn = multiplexed.stream;
      }
    } catch (err) {
      maConn.log.error("failed to upgrade inbound connection %s %a - %e", direction === "inbound" ? "from" : "to", maConn.remoteAddr, err);
      throw err;
    }
    await this.shouldBlockConnection(direction === "inbound" ? "denyInboundUpgradedConnection" : "denyOutboundUpgradedConnection", remotePeer, maConn);
    maConn.log("successfully upgraded %s connection", direction);
    return this._createConnection({
      cryptoProtocol,
      direction,
      maConn,
      upgradedConn,
      muxerFactory,
      remotePeer,
      limits: opts == null ? void 0 : opts.limits
    });
  }
  /**
   * A convenience method for generating a new `Connection`
   */
  _createConnection(opts) {
    const { cryptoProtocol, direction, maConn, upgradedConn, remotePeer, muxerFactory, limits } = opts;
    let muxer;
    let newStream;
    let connection;
    if (muxerFactory != null) {
      muxer = muxerFactory.createStreamMuxer({
        direction,
        // Run anytime a remote stream is created
        onIncomingStream: (muxedStream) => {
          if (connection == null) {
            return;
          }
          void Promise.resolve().then(async () => {
            var _a12;
            const protocols = this.components.registrar.getProtocols();
            const signal = AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);
            setMaxListeners(Infinity, signal);
            const { stream, protocol } = await handle(muxedStream, protocols, {
              signal,
              log: muxedStream.log,
              yieldBytes: false
            });
            if (connection == null) {
              return;
            }
            connection.log("incoming stream opened on %s", protocol);
            const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar);
            const streamCount = countStreams(protocol, "inbound", connection);
            if (streamCount === incomingLimit) {
              const err = new TooManyInboundProtocolStreamsError(`Too many inbound protocol streams for protocol "${protocol}" - limit ${incomingLimit}`);
              muxedStream.abort(err);
              throw err;
            }
            muxedStream.source = stream.source;
            muxedStream.sink = stream.sink;
            muxedStream.protocol = protocol;
            if (stream.closeWrite != null) {
              muxedStream.closeWrite = stream.closeWrite;
            }
            if (stream.closeRead != null) {
              muxedStream.closeRead = stream.closeRead;
            }
            if (stream.close != null) {
              muxedStream.close = stream.close;
            }
            await this.components.peerStore.merge(remotePeer, {
              protocols: [protocol]
            });
            (_a12 = this.components.metrics) == null ? void 0 : _a12.trackProtocolStream(muxedStream, connection);
            this._onStream({ connection, stream: muxedStream, protocol });
          }).catch(async (err) => {
            connection.log.error("error handling incoming stream id %s - %e", muxedStream.id, err);
            if (muxedStream.timeline.close == null) {
              await muxedStream.close();
            }
          });
        }
      });
      newStream = async (protocols, options = {}) => {
        var _a12;
        if (muxer == null) {
          throw new MuxerUnavailableError("Connection is not multiplexed");
        }
        connection.log.trace("starting new stream for protocols %s", protocols);
        const muxedStream = await muxer.newStream();
        connection.log.trace("started new stream %s for protocols %s", muxedStream.id, protocols);
        try {
          if (options.signal == null) {
            muxedStream.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout", protocols);
            const signal = AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);
            setMaxListeners(Infinity, signal);
            options = {
              ...options,
              signal
            };
          }
          muxedStream.log.trace("selecting protocol from protocols %s", protocols);
          const { stream, protocol } = await select(muxedStream, protocols, {
            ...options,
            log: muxedStream.log,
            yieldBytes: true
          });
          muxedStream.log.trace("selected protocol %s", protocol);
          const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar, options);
          const streamCount = countStreams(protocol, "outbound", connection);
          if (streamCount >= outgoingLimit) {
            const err = new TooManyOutboundProtocolStreamsError(`Too many outbound protocol streams for protocol "${protocol}" - ${streamCount}/${outgoingLimit}`);
            muxedStream.abort(err);
            throw err;
          }
          await this.components.peerStore.merge(remotePeer, {
            protocols: [protocol]
          });
          muxedStream.source = stream.source;
          muxedStream.sink = stream.sink;
          muxedStream.protocol = protocol;
          if (stream.closeWrite != null) {
            muxedStream.closeWrite = stream.closeWrite;
          }
          if (stream.closeRead != null) {
            muxedStream.closeRead = stream.closeRead;
          }
          if (stream.close != null) {
            muxedStream.close = stream.close;
          }
          (_a12 = this.components.metrics) == null ? void 0 : _a12.trackProtocolStream(muxedStream, connection);
          return muxedStream;
        } catch (err) {
          connection.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e", direction === "inbound" ? "from" : "to", opts.maConn.remoteAddr, protocols, err);
          if (muxedStream.timeline.close == null) {
            muxedStream.abort(err);
          }
          throw err;
        }
      };
      void Promise.all([
        muxer.sink(upgradedConn.source),
        upgradedConn.sink(muxer.source)
      ]).catch((err) => {
        connection.log.error("error piping data through muxer - %e", err);
      });
    }
    const _timeline = maConn.timeline;
    maConn.timeline = new Proxy(_timeline, {
      set: (...args) => {
        if (args[1] === "close" && args[2] != null && _timeline.close == null) {
          (async () => {
            try {
              if (connection.status === "open") {
                await connection.close();
              }
            } catch (err) {
              connection.log.error("error closing connection after timeline close %e", err);
            } finally {
              this.events.safeDispatchEvent("connection:close", {
                detail: connection
              });
            }
          })().catch((err) => {
            connection.log.error("error thrown while dispatching connection:close event %e", err);
          });
        }
        return Reflect.set(...args);
      }
    });
    maConn.timeline.upgraded = Date.now();
    const errConnectionNotMultiplexed = () => {
      throw new MuxerUnavailableError("Connection is not multiplexed");
    };
    connection = createConnection({
      remoteAddr: maConn.remoteAddr,
      remotePeer,
      status: "open",
      direction,
      timeline: maConn.timeline,
      multiplexer: muxer == null ? void 0 : muxer.protocol,
      encryption: cryptoProtocol,
      limits,
      logger: this.components.logger,
      newStream: newStream ?? errConnectionNotMultiplexed,
      getStreams: () => {
        return (muxer == null ? void 0 : muxer.streams) ?? [];
      },
      close: async (options) => {
        await (muxer == null ? void 0 : muxer.close(options));
        await maConn.close(options);
      },
      abort: (err) => {
        maConn.abort(err);
        muxer == null ? void 0 : muxer.abort(err);
      }
    });
    this.events.safeDispatchEvent("connection:open", {
      detail: connection
    });
    connection.__maConnTimeline = _timeline;
    return connection;
  }
  /**
   * Routes incoming streams to the correct handler
   */
  _onStream(opts) {
    const { connection, stream, protocol } = opts;
    const { handler, options } = this.components.registrar.getHandler(protocol);
    if (connection.limits != null && options.runOnLimitedConnection !== true) {
      throw new LimitedConnectionError("Cannot open protocol stream on limited connection");
    }
    handler({ connection, stream });
  }
  /**
   * Attempts to encrypt the incoming `connection` with the provided `cryptos`
   */
  async _encryptInbound(connection, options) {
    const protocols = Array.from(this.connectionEncrypters.keys());
    try {
      const { stream, protocol } = await handle(connection, protocols, {
        ...options,
        log: connection.log
      });
      const encrypter = this.connectionEncrypters.get(protocol);
      if (encrypter == null) {
        throw new EncryptionFailedError(`no crypto module found for ${protocol}`);
      }
      connection.log("encrypting inbound connection to %a using %s", connection.remoteAddr, protocol);
      return {
        ...await encrypter.secureInbound(stream, options),
        protocol
      };
    } catch (err) {
      connection.log.error("encrypting inbound connection from %a failed", connection.remoteAddr, err);
      throw new EncryptionFailedError(err.message);
    }
  }
  /**
   * Attempts to encrypt the given `connection` with the provided connection encrypters.
   * The first `ConnectionEncrypter` module to succeed will be used
   */
  async _encryptOutbound(connection, options) {
    const protocols = Array.from(this.connectionEncrypters.keys());
    try {
      connection.log.trace("selecting encrypter from %s", protocols);
      const { stream, protocol } = await select(connection, protocols, {
        ...options,
        log: connection.log,
        yieldBytes: true
      });
      const encrypter = this.connectionEncrypters.get(protocol);
      if (encrypter == null) {
        throw new EncryptionFailedError(`no crypto module found for ${protocol}`);
      }
      connection.log("encrypting outbound connection to %a using %s", connection.remoteAddr, protocol);
      return {
        ...await encrypter.secureOutbound(stream, options),
        protocol
      };
    } catch (err) {
      connection.log.error("encrypting outbound connection to %a failed", connection.remoteAddr, err);
      throw new EncryptionFailedError(err.message);
    }
  }
  /**
   * Selects one of the given muxers via multistream-select. That
   * muxer will be used for all future streams on the connection.
   */
  async _multiplexOutbound(connection, muxers, options) {
    const protocols = Array.from(muxers.keys());
    connection.log("outbound selecting muxer %s", protocols);
    try {
      connection.log.trace("selecting stream muxer from %s", protocols);
      const { stream, protocol } = await select(connection, protocols, {
        ...options,
        log: connection.log,
        yieldBytes: true
      });
      connection.log("selected %s as muxer protocol", protocol);
      const muxerFactory = muxers.get(protocol);
      return { stream, muxerFactory };
    } catch (err) {
      connection.log.error("error multiplexing outbound connection", err);
      throw new MuxerUnavailableError(String(err));
    }
  }
  /**
   * Registers support for one of the given muxers via multistream-select. The
   * selected muxer will be used for all future streams on the connection.
   */
  async _multiplexInbound(connection, muxers, options) {
    const protocols = Array.from(muxers.keys());
    connection.log("inbound handling muxers %s", protocols);
    try {
      const { stream, protocol } = await handle(connection, protocols, {
        ...options,
        log: connection.log
      });
      const muxerFactory = muxers.get(protocol);
      return { stream, muxerFactory };
    } catch (err) {
      connection.log.error("error multiplexing inbound connection", err);
      throw new MuxerUnavailableError(String(err));
    }
  }
  getConnectionEncrypters() {
    return this.connectionEncrypters;
  }
  getStreamMuxers() {
    return this.streamMuxers;
  }
};

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/version.js
var version = "2.8.2";
var name = "js-libp2p";

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/user-agent.browser.js
function userAgent(name2, version2) {
  return `${name2 ?? name}/${version2 ?? version} browser/${globalThis.navigator.userAgent}`;
}

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/libp2p.js
var _Libp2p_instances, onDiscoveryPeer_fn;
var Libp2p = class extends TypedEventEmitter {
  // eslint-disable-next-line complexity
  constructor(init) {
    var _a12, _b4, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    super();
    __privateAdd(this, _Libp2p_instances);
    __publicField(this, "peerId");
    __publicField(this, "peerStore");
    __publicField(this, "contentRouting");
    __publicField(this, "peerRouting");
    __publicField(this, "metrics");
    __publicField(this, "services");
    __publicField(this, "logger");
    __publicField(this, "status");
    __publicField(this, "components");
    __publicField(this, "log");
    this.status = "stopped";
    const events2 = new TypedEventEmitter();
    const originalDispatch = events2.dispatchEvent.bind(events2);
    events2.dispatchEvent = (evt) => {
      const internalResult = originalDispatch(evt);
      const externalResult = this.dispatchEvent(new CustomEvent(evt.type, { detail: evt.detail }));
      return internalResult || externalResult;
    };
    setMaxListeners(Infinity, events2);
    this.peerId = init.peerId;
    this.logger = init.logger ?? defaultLogger();
    this.log = this.logger.forComponent("libp2p");
    this.services = {};
    const nodeInfoName = ((_a12 = init.nodeInfo) == null ? void 0 : _a12.name) ?? name;
    const nodeInfoVersion = ((_b4 = init.nodeInfo) == null ? void 0 : _b4.version) ?? version;
    const components = this.components = defaultComponents({
      peerId: init.peerId,
      privateKey: init.privateKey,
      nodeInfo: {
        name: nodeInfoName,
        version: nodeInfoVersion,
        userAgent: ((_c = init.nodeInfo) == null ? void 0 : _c.userAgent) ?? userAgent(nodeInfoName, nodeInfoVersion)
      },
      logger: this.logger,
      events: events2,
      datastore: init.datastore ?? new MemoryDatastore(),
      connectionGater: connectionGater(init.connectionGater),
      dns: init.dns
    });
    this.peerStore = this.configureComponent("peerStore", persistentPeerStore(components, {
      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,
      ...init.peerStore
    }));
    if (init.metrics != null) {
      this.metrics = this.configureComponent("metrics", init.metrics(this.components));
    }
    components.events.addEventListener("peer:update", (evt) => {
      if (evt.detail.previous == null) {
        const peerInfo = {
          id: evt.detail.peer.id,
          multiaddrs: evt.detail.peer.addresses.map((a) => a.multiaddr)
        };
        components.events.safeDispatchEvent("peer:discovery", { detail: peerInfo });
      }
    });
    if (init.connectionProtector != null) {
      this.configureComponent("connectionProtector", init.connectionProtector(components));
    }
    this.components.upgrader = new Upgrader(this.components, {
      connectionEncrypters: (init.connectionEncrypters ?? []).map((fn, index) => this.configureComponent(`connection-encryption-${index}`, fn(this.components))),
      streamMuxers: (init.streamMuxers ?? []).map((fn, index) => this.configureComponent(`stream-muxers-${index}`, fn(this.components))),
      inboundUpgradeTimeout: (_d = init.connectionManager) == null ? void 0 : _d.inboundUpgradeTimeout,
      inboundStreamProtocolNegotiationTimeout: ((_e = init.connectionManager) == null ? void 0 : _e.inboundStreamProtocolNegotiationTimeout) ?? ((_f = init.connectionManager) == null ? void 0 : _f.protocolNegotiationTimeout),
      outboundStreamProtocolNegotiationTimeout: ((_g = init.connectionManager) == null ? void 0 : _g.outboundStreamProtocolNegotiationTimeout) ?? ((_h = init.connectionManager) == null ? void 0 : _h.protocolNegotiationTimeout)
    });
    this.configureComponent("transportManager", new DefaultTransportManager(this.components, init.transportManager));
    this.configureComponent("connectionManager", new DefaultConnectionManager(this.components, init.connectionManager));
    if (((_i = init.connectionMonitor) == null ? void 0 : _i.enabled) !== false) {
      this.configureComponent("connectionMonitor", new ConnectionMonitor(this.components, init.connectionMonitor));
    }
    this.configureComponent("registrar", new Registrar(this.components));
    this.configureComponent("addressManager", new AddressManager(this.components, init.addresses));
    const peerRouters = (init.peerRouters ?? []).map((fn, index) => this.configureComponent(`peer-router-${index}`, fn(this.components)));
    this.peerRouting = this.components.peerRouting = this.configureComponent("peerRouting", new DefaultPeerRouting(this.components, {
      routers: peerRouters
    }));
    const contentRouters = (init.contentRouters ?? []).map((fn, index) => this.configureComponent(`content-router-${index}`, fn(this.components)));
    this.contentRouting = this.components.contentRouting = this.configureComponent("contentRouting", new CompoundContentRouting(this.components, {
      routers: contentRouters
    }));
    this.configureComponent("randomWalk", new RandomWalk(this.components));
    (init.peerDiscovery ?? []).forEach((fn, index) => {
      const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components));
      service.addEventListener("peer", (evt) => {
        __privateMethod(this, _Libp2p_instances, onDiscoveryPeer_fn).call(this, evt);
      });
    });
    (_j = init.transports) == null ? void 0 : _j.forEach((fn, index) => {
      this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)));
    });
    if (init.services != null) {
      for (const name2 of Object.keys(init.services)) {
        const createService = init.services[name2];
        const service = createService(this.components);
        if (service == null) {
          this.log.error("service factory %s returned null or undefined instance", name2);
          continue;
        }
        this.services[name2] = service;
        this.configureComponent(name2, service);
        if (service[contentRoutingSymbol] != null) {
          this.log("registering service %s for content routing", name2);
          contentRouters.push(service[contentRoutingSymbol]);
        }
        if (service[peerRoutingSymbol] != null) {
          this.log("registering service %s for peer routing", name2);
          peerRouters.push(service[peerRoutingSymbol]);
        }
        if (service[peerDiscoverySymbol] != null) {
          this.log("registering service %s for peer discovery", name2);
          (_l = (_k = service[peerDiscoverySymbol]).addEventListener) == null ? void 0 : _l.call(_k, "peer", (evt) => {
            __privateMethod(this, _Libp2p_instances, onDiscoveryPeer_fn).call(this, evt);
          });
        }
      }
    }
    checkServiceDependencies(components);
  }
  configureComponent(name2, component) {
    if (component == null) {
      this.log.error("component %s was null or undefined", name2);
    }
    this.components[name2] = component;
    return component;
  }
  /**
   * Starts the libp2p node and all its subsystems
   */
  async start() {
    var _a12, _b4, _c, _d;
    if (this.status !== "stopped") {
      return;
    }
    this.status = "starting";
    this.log("libp2p is starting");
    try {
      await ((_b4 = (_a12 = this.components).beforeStart) == null ? void 0 : _b4.call(_a12));
      await this.components.start();
      await ((_d = (_c = this.components).afterStart) == null ? void 0 : _d.call(_c));
      this.status = "started";
      this.safeDispatchEvent("start", { detail: this });
      this.log("libp2p has started");
    } catch (err) {
      this.log.error("An error occurred starting libp2p", err);
      this.status = "started";
      await this.stop();
      throw err;
    }
  }
  /**
   * Stop the libp2p node by closing its listeners and open connections
   */
  async stop() {
    var _a12, _b4, _c, _d;
    if (this.status !== "started") {
      return;
    }
    this.log("libp2p is stopping");
    this.status = "stopping";
    await ((_b4 = (_a12 = this.components).beforeStop) == null ? void 0 : _b4.call(_a12));
    await this.components.stop();
    await ((_d = (_c = this.components).afterStop) == null ? void 0 : _d.call(_c));
    this.status = "stopped";
    this.safeDispatchEvent("stop", { detail: this });
    this.log("libp2p has stopped");
  }
  getConnections(peerId) {
    return this.components.connectionManager.getConnections(peerId);
  }
  getDialQueue() {
    return this.components.connectionManager.getDialQueue();
  }
  getPeers() {
    const peerSet2 = new PeerSet();
    for (const conn of this.components.connectionManager.getConnections()) {
      peerSet2.add(conn.remotePeer);
    }
    return Array.from(peerSet2);
  }
  async dial(peer, options = {}) {
    return this.components.connectionManager.openConnection(peer, {
      // ensure any userland dials take top priority in the queue
      priority: 75,
      ...options
    });
  }
  async dialProtocol(peer, protocols, options = {}) {
    if (protocols == null) {
      throw new InvalidParametersError("no protocols were provided to open a stream");
    }
    protocols = Array.isArray(protocols) ? protocols : [protocols];
    if (protocols.length === 0) {
      throw new InvalidParametersError("no protocols were provided to open a stream");
    }
    const connection = await this.dial(peer, options);
    return connection.newStream(protocols, options);
  }
  getMultiaddrs() {
    return this.components.addressManager.getAddresses();
  }
  getProtocols() {
    return this.components.registrar.getProtocols();
  }
  async hangUp(peer, options = {}) {
    if (isMultiaddr(peer)) {
      peer = peerIdFromString(peer.getPeerId() ?? "");
    }
    await this.components.connectionManager.closeConnections(peer, options);
  }
  async getPublicKey(peer, options = {}) {
    this.log("getPublicKey %p", peer);
    if (peer.publicKey != null) {
      return peer.publicKey;
    }
    try {
      const peerInfo = await this.peerStore.get(peer);
      if (peerInfo.id.publicKey != null) {
        return peerInfo.id.publicKey;
      }
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    const peerKey = concat([
      fromString("/pk/"),
      peer.toMultihash().bytes
    ]);
    const bytes = await this.contentRouting.get(peerKey, options);
    const publicKey = publicKeyFromProtobuf(bytes);
    await this.peerStore.patch(peer, {
      publicKey
    });
    return publicKey;
  }
  async handle(protocols, handler, options) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol) => {
      await this.components.registrar.handle(protocol, handler, options);
    }));
  }
  async unhandle(protocols) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol) => {
      await this.components.registrar.unhandle(protocol);
    }));
  }
  async register(protocol, topology) {
    return this.components.registrar.register(protocol, topology);
  }
  unregister(id) {
    this.components.registrar.unregister(id);
  }
  async isDialable(multiaddr2, options = {}) {
    return this.components.connectionManager.isDialable(multiaddr2, options);
  }
};
_Libp2p_instances = new WeakSet();
/**
 * Called whenever peer discovery services emit `peer` events and adds peers
 * to the peer store.
 */
onDiscoveryPeer_fn = function(evt) {
  const { detail: peer } = evt;
  if (peer.id.toString() === this.peerId.toString()) {
    this.log.error("peer discovery mechanism discovered self");
    return;
  }
  void this.components.peerStore.merge(peer.id, {
    multiaddrs: peer.multiaddrs
  }).catch((err) => {
    this.log.error(err);
  });
};

// node_modules/.pnpm/libp2p@2.8.2/node_modules/libp2p/dist/src/index.js
async function createLibp2p(options = {}) {
  options.privateKey ?? (options.privateKey = await generateKeyPair("Ed25519"));
  const node = new Libp2p({
    ...await validateConfig(options),
    peerId: peerIdFromPrivateKey(options.privateKey)
  });
  if (options.start !== false) {
    await node.start();
  }
  return node;
}
export {
  createLibp2p
};
//# sourceMappingURL=libp2p.js.map
