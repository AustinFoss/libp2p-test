import {
  pDefer
} from "./chunk-2B23ONA5.js";
import {
  __privateAdd,
  __privateGet,
  __publicField
} from "./chunk-WOOG5QLI.js";

// node_modules/.pnpm/@libp2p+interface@2.7.0/node_modules/@libp2p/interface/dist/src/transport.js
var transportSymbol = Symbol.for("@libp2p/transport");
var FaultTolerance;
(function(FaultTolerance2) {
  FaultTolerance2[FaultTolerance2["FATAL_ALL"] = 0] = "FATAL_ALL";
  FaultTolerance2[FaultTolerance2["NO_FATAL"] = 1] = "NO_FATAL";
})(FaultTolerance || (FaultTolerance = {}));

// node_modules/.pnpm/@libp2p+interface@2.7.0/node_modules/@libp2p/interface/dist/src/errors.js
var AbortError = class extends Error {
  constructor(message = "The operation was aborted") {
    super(message);
    this.name = "AbortError";
  }
};
__publicField(AbortError, "name", "AbortError");
var UnexpectedPeerError = class extends Error {
  constructor(message = "Unexpected Peer") {
    super(message);
    this.name = "UnexpectedPeerError";
  }
};
__publicField(UnexpectedPeerError, "name", "UnexpectedPeerError");
var InvalidCryptoExchangeError = class extends Error {
  constructor(message = "Invalid crypto exchange") {
    super(message);
    this.name = "InvalidCryptoExchangeError";
  }
};
__publicField(InvalidCryptoExchangeError, "name", "InvalidCryptoExchangeError");
var InvalidParametersError = class extends Error {
  constructor(message = "Invalid parameters") {
    super(message);
    this.name = "InvalidParametersError";
  }
};
__publicField(InvalidParametersError, "name", "InvalidParametersError");
var InvalidPublicKeyError = class extends Error {
  constructor(message = "Invalid public key") {
    super(message);
    this.name = "InvalidPublicKeyError";
  }
};
__publicField(InvalidPublicKeyError, "name", "InvalidPublicKeyError");
var InvalidPrivateKeyError = class extends Error {
  constructor(message = "Invalid private key") {
    super(message);
    this.name = "InvalidPrivateKeyError";
  }
};
__publicField(InvalidPrivateKeyError, "name", "InvalidPrivateKeyError");
var ConnectionClosingError = class extends Error {
  constructor(message = "The connection is closing") {
    super(message);
    this.name = "ConnectionClosingError";
  }
};
__publicField(ConnectionClosingError, "name", "ConnectionClosingError");
var ConnectionClosedError = class extends Error {
  constructor(message = "The connection is closed") {
    super(message);
    this.name = "ConnectionClosedError";
  }
};
__publicField(ConnectionClosedError, "name", "ConnectionClosedError");
var MuxerClosedError = class extends Error {
  constructor(message = "The muxer is closed") {
    super(message);
    this.name = "MuxerClosedError";
  }
};
__publicField(MuxerClosedError, "name", "MuxerClosedError");
var StreamResetError = class extends Error {
  constructor(message = "The stream has been reset") {
    super(message);
    this.name = "StreamResetError";
  }
};
__publicField(StreamResetError, "name", "StreamResetError");
var StreamStateError = class extends Error {
  constructor(message = "The stream is in an invalid state") {
    super(message);
    this.name = "StreamStateError";
  }
};
__publicField(StreamStateError, "name", "StreamStateError");
var NotFoundError = class extends Error {
  constructor(message = "Not found") {
    super(message);
    this.name = "NotFoundError";
  }
};
__publicField(NotFoundError, "name", "NotFoundError");
var InvalidPeerIdError = class extends Error {
  constructor(message = "Invalid PeerID") {
    super(message);
    this.name = "InvalidPeerIdError";
  }
};
__publicField(InvalidPeerIdError, "name", "InvalidPeerIdError");
var InvalidMultiaddrError = class extends Error {
  constructor(message = "Invalid multiaddr") {
    super(message);
    this.name = "InvalidMultiaddrError";
  }
};
__publicField(InvalidMultiaddrError, "name", "InvalidMultiaddrError");
var UnsupportedProtocolError = class extends Error {
  constructor(message = "Unsupported protocol error") {
    super(message);
    this.name = "UnsupportedProtocolError";
  }
};
__publicField(UnsupportedProtocolError, "name", "UnsupportedProtocolError");
var InvalidMessageError = class extends Error {
  constructor(message = "Invalid message") {
    super(message);
    this.name = "InvalidMessageError";
  }
};
__publicField(InvalidMessageError, "name", "InvalidMessageError");
var TimeoutError = class extends Error {
  constructor(message = "Timed out") {
    super(message);
    this.name = "TimeoutError";
  }
};
__publicField(TimeoutError, "name", "TimeoutError");
var NotStartedError = class extends Error {
  constructor(message = "Not started") {
    super(message);
    this.name = "NotStartedError";
  }
};
__publicField(NotStartedError, "name", "NotStartedError");
var DialError = class extends Error {
  constructor(message = "Dial error") {
    super(message);
    this.name = "DialError";
  }
};
__publicField(DialError, "name", "DialError");
var LimitedConnectionError = class extends Error {
  constructor(message = "Limited connection") {
    super(message);
    this.name = "LimitedConnectionError";
  }
};
__publicField(LimitedConnectionError, "name", "LimitedConnectionError");
var TooManyInboundProtocolStreamsError = class extends Error {
  constructor(message = "Too many inbound protocol streams") {
    super(message);
    this.name = "TooManyInboundProtocolStreamsError";
  }
};
__publicField(TooManyInboundProtocolStreamsError, "name", "TooManyInboundProtocolStreamsError");
var TooManyOutboundProtocolStreamsError = class extends Error {
  constructor(message = "Too many outbound protocol streams") {
    super(message);
    this.name = "TooManyOutboundProtocolStreamsError";
  }
};
__publicField(TooManyOutboundProtocolStreamsError, "name", "TooManyOutboundProtocolStreamsError");
var UnsupportedKeyTypeError = class extends Error {
  constructor(message = "Unsupported key type") {
    super(message);
    this.name = "UnsupportedKeyTypeError";
  }
};
__publicField(UnsupportedKeyTypeError, "name", "UnsupportedKeyTypeError");

// node_modules/.pnpm/@libp2p+interface@2.7.0/node_modules/@libp2p/interface/dist/src/connection.js
var connectionSymbol = Symbol.for("@libp2p/connection");

// node_modules/.pnpm/@libp2p+interface@2.7.0/node_modules/@libp2p/interface/dist/src/content-routing.js
var contentRoutingSymbol = Symbol.for("@libp2p/content-routing");

// node_modules/.pnpm/@libp2p+interface@2.7.0/node_modules/@libp2p/interface/dist/src/peer-discovery.js
var peerDiscoverySymbol = Symbol.for("@libp2p/peer-discovery");

// node_modules/.pnpm/@libp2p+interface@2.7.0/node_modules/@libp2p/interface/dist/src/peer-id.js
var peerIdSymbol = Symbol.for("@libp2p/peer-id");
function isPeerId(other) {
  return Boolean(other == null ? void 0 : other[peerIdSymbol]);
}

// node_modules/.pnpm/@libp2p+interface@2.7.0/node_modules/@libp2p/interface/dist/src/peer-routing.js
var peerRoutingSymbol = Symbol.for("@libp2p/peer-routing");

// node_modules/.pnpm/@libp2p+interface@2.7.0/node_modules/@libp2p/interface/dist/src/peer-store.js
var KEEP_ALIVE = "keep-alive";

// node_modules/.pnpm/@libp2p+interface@2.7.0/node_modules/@libp2p/interface/dist/src/pubsub.js
var TopicValidatorResult;
(function(TopicValidatorResult2) {
  TopicValidatorResult2["Accept"] = "accept";
  TopicValidatorResult2["Ignore"] = "ignore";
  TopicValidatorResult2["Reject"] = "reject";
})(TopicValidatorResult || (TopicValidatorResult = {}));
var pubSubSymbol = Symbol.for("@libp2p/pubsub");

// node_modules/.pnpm/@libp2p+interface@2.7.0/node_modules/@libp2p/interface/dist/src/events.browser.js
function setMaxListeners() {
}

// node_modules/.pnpm/@libp2p+interface@2.7.0/node_modules/@libp2p/interface/dist/src/event-target.js
var _listeners;
var TypedEventEmitter = class extends EventTarget {
  constructor() {
    super();
    __privateAdd(this, _listeners, /* @__PURE__ */ new Map());
    setMaxListeners(Infinity, this);
  }
  listenerCount(type) {
    const listeners = __privateGet(this, _listeners).get(type);
    if (listeners == null) {
      return 0;
    }
    return listeners.length;
  }
  addEventListener(type, listener, options) {
    super.addEventListener(type, listener, options);
    let list = __privateGet(this, _listeners).get(type);
    if (list == null) {
      list = [];
      __privateGet(this, _listeners).set(type, list);
    }
    list.push({
      callback: listener,
      once: (options !== true && options !== false && (options == null ? void 0 : options.once)) ?? false
    });
  }
  removeEventListener(type, listener, options) {
    super.removeEventListener(type.toString(), listener ?? null, options);
    let list = __privateGet(this, _listeners).get(type);
    if (list == null) {
      return;
    }
    list = list.filter(({ callback }) => callback !== listener);
    __privateGet(this, _listeners).set(type, list);
  }
  dispatchEvent(event) {
    const result = super.dispatchEvent(event);
    let list = __privateGet(this, _listeners).get(event.type);
    if (list == null) {
      return result;
    }
    list = list.filter(({ once }) => !once);
    __privateGet(this, _listeners).set(event.type, list);
    return result;
  }
  safeDispatchEvent(type, detail = {}) {
    return this.dispatchEvent(new CustomEvent(type, detail));
  }
};
_listeners = new WeakMap();

// node_modules/.pnpm/@libp2p+interface@2.7.0/node_modules/@libp2p/interface/dist/src/startable.js
function isStartable(obj) {
  return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
}
async function start(...objs) {
  const startables = [];
  for (const obj of objs) {
    if (isStartable(obj)) {
      startables.push(obj);
    }
  }
  await Promise.all(startables.map(async (s) => {
    if (s.beforeStart != null) {
      await s.beforeStart();
    }
  }));
  await Promise.all(startables.map(async (s) => {
    await s.start();
  }));
  await Promise.all(startables.map(async (s) => {
    if (s.afterStart != null) {
      await s.afterStart();
    }
  }));
}
async function stop(...objs) {
  const startables = [];
  for (const obj of objs) {
    if (isStartable(obj)) {
      startables.push(obj);
    }
  }
  await Promise.all(startables.map(async (s) => {
    if (s.beforeStop != null) {
      await s.beforeStop();
    }
  }));
  await Promise.all(startables.map(async (s) => {
    await s.stop();
  }));
  await Promise.all(startables.map(async (s) => {
    if (s.afterStop != null) {
      await s.afterStop();
    }
  }));
}

// node_modules/.pnpm/@libp2p+interface@2.7.0/node_modules/@libp2p/interface/dist/src/index.js
var serviceCapabilities = Symbol.for("@libp2p/service-capabilities");
var serviceDependencies = Symbol.for("@libp2p/service-dependencies");

// node_modules/.pnpm/it-pushable@3.2.3/node_modules/it-pushable/dist/src/fifo.js
var FixedFIFO = class {
  constructor(hwm) {
    __publicField(this, "buffer");
    __publicField(this, "mask");
    __publicField(this, "top");
    __publicField(this, "btm");
    __publicField(this, "next");
    if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
      throw new Error("Max size for a FixedFIFO should be a power of two");
    }
    this.buffer = new Array(hwm);
    this.mask = hwm - 1;
    this.top = 0;
    this.btm = 0;
    this.next = null;
  }
  push(data) {
    if (this.buffer[this.top] !== void 0) {
      return false;
    }
    this.buffer[this.top] = data;
    this.top = this.top + 1 & this.mask;
    return true;
  }
  shift() {
    const last = this.buffer[this.btm];
    if (last === void 0) {
      return void 0;
    }
    this.buffer[this.btm] = void 0;
    this.btm = this.btm + 1 & this.mask;
    return last;
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
};
var FIFO = class {
  constructor(options = {}) {
    __publicField(this, "size");
    __publicField(this, "hwm");
    __publicField(this, "head");
    __publicField(this, "tail");
    this.hwm = options.splitLimit ?? 16;
    this.head = new FixedFIFO(this.hwm);
    this.tail = this.head;
    this.size = 0;
  }
  calculateSize(obj) {
    if ((obj == null ? void 0 : obj.byteLength) != null) {
      return obj.byteLength;
    }
    return 1;
  }
  push(val) {
    if ((val == null ? void 0 : val.value) != null) {
      this.size += this.calculateSize(val.value);
    }
    if (!this.head.push(val)) {
      const prev = this.head;
      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
      this.head.push(val);
    }
  }
  shift() {
    let val = this.tail.shift();
    if (val === void 0 && this.tail.next != null) {
      const next = this.tail.next;
      this.tail.next = null;
      this.tail = next;
      val = this.tail.shift();
    }
    if ((val == null ? void 0 : val.value) != null) {
      this.size -= this.calculateSize(val.value);
    }
    return val;
  }
  isEmpty() {
    return this.head.isEmpty();
  }
};

// node_modules/.pnpm/it-pushable@3.2.3/node_modules/it-pushable/dist/src/index.js
var AbortError2 = class extends Error {
  constructor(message, code) {
    super(message ?? "The operation was aborted");
    __publicField(this, "type");
    __publicField(this, "code");
    this.type = "aborted";
    this.code = code ?? "ABORT_ERR";
  }
};
function pushable(options = {}) {
  const getNext = (buffer) => {
    const next = buffer.shift();
    if (next == null) {
      return { done: true };
    }
    if (next.error != null) {
      throw next.error;
    }
    return {
      done: next.done === true,
      // @ts-expect-error if done is false, value will be present
      value: next.value
    };
  };
  return _pushable(getNext, options);
}
function _pushable(getNext, options) {
  options = options ?? {};
  let onEnd = options.onEnd;
  let buffer = new FIFO();
  let pushable2;
  let onNext;
  let ended;
  let drain = pDefer();
  const waitNext = async () => {
    try {
      if (!buffer.isEmpty()) {
        return getNext(buffer);
      }
      if (ended) {
        return { done: true };
      }
      return await new Promise((resolve, reject) => {
        onNext = (next) => {
          onNext = null;
          buffer.push(next);
          try {
            resolve(getNext(buffer));
          } catch (err) {
            reject(err);
          }
          return pushable2;
        };
      });
    } finally {
      if (buffer.isEmpty()) {
        queueMicrotask(() => {
          drain.resolve();
          drain = pDefer();
        });
      }
    }
  };
  const bufferNext = (next) => {
    if (onNext != null) {
      return onNext(next);
    }
    buffer.push(next);
    return pushable2;
  };
  const bufferError = (err) => {
    buffer = new FIFO();
    if (onNext != null) {
      return onNext({ error: err });
    }
    buffer.push({ error: err });
    return pushable2;
  };
  const push = (value) => {
    if (ended) {
      return pushable2;
    }
    if ((options == null ? void 0 : options.objectMode) !== true && (value == null ? void 0 : value.byteLength) == null) {
      throw new Error("objectMode was not true but tried to push non-Uint8Array value");
    }
    return bufferNext({ done: false, value });
  };
  const end = (err) => {
    if (ended)
      return pushable2;
    ended = true;
    return err != null ? bufferError(err) : bufferNext({ done: true });
  };
  const _return = () => {
    buffer = new FIFO();
    end();
    return { done: true };
  };
  const _throw = (err) => {
    end(err);
    return { done: true };
  };
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next: waitNext,
    return: _return,
    throw: _throw,
    push,
    end,
    get readableLength() {
      return buffer.size;
    },
    onEmpty: async (options2) => {
      const signal = options2 == null ? void 0 : options2.signal;
      signal == null ? void 0 : signal.throwIfAborted();
      if (buffer.isEmpty()) {
        return;
      }
      let cancel;
      let listener;
      if (signal != null) {
        cancel = new Promise((resolve, reject) => {
          listener = () => {
            reject(new AbortError2());
          };
          signal.addEventListener("abort", listener);
        });
      }
      try {
        await Promise.race([
          drain.promise,
          cancel
        ]);
      } finally {
        if (listener != null && signal != null) {
          signal == null ? void 0 : signal.removeEventListener("abort", listener);
        }
      }
    }
  };
  if (onEnd == null) {
    return pushable2;
  }
  const _pushable2 = pushable2;
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      return _pushable2.next();
    },
    throw(err) {
      _pushable2.throw(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return { done: true };
    },
    return() {
      _pushable2.return();
      if (onEnd != null) {
        onEnd();
        onEnd = void 0;
      }
      return { done: true };
    },
    push,
    end(err) {
      _pushable2.end(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return pushable2;
    },
    get readableLength() {
      return _pushable2.readableLength;
    },
    onEmpty: (opts) => {
      return _pushable2.onEmpty(opts);
    }
  };
  return pushable2;
}

export {
  connectionSymbol,
  contentRoutingSymbol,
  peerDiscoverySymbol,
  isPeerId,
  peerRoutingSymbol,
  KEEP_ALIVE,
  transportSymbol,
  FaultTolerance,
  AbortError,
  UnexpectedPeerError,
  InvalidCryptoExchangeError,
  InvalidParametersError,
  InvalidPublicKeyError,
  InvalidPrivateKeyError,
  ConnectionClosingError,
  ConnectionClosedError,
  MuxerClosedError,
  StreamResetError,
  StreamStateError,
  NotFoundError,
  InvalidPeerIdError,
  InvalidMultiaddrError,
  UnsupportedProtocolError,
  InvalidMessageError,
  TimeoutError,
  NotStartedError,
  DialError,
  LimitedConnectionError,
  TooManyInboundProtocolStreamsError,
  TooManyOutboundProtocolStreamsError,
  UnsupportedKeyTypeError,
  setMaxListeners,
  TypedEventEmitter,
  isStartable,
  start,
  stop,
  serviceCapabilities,
  serviceDependencies,
  pushable
};
//# sourceMappingURL=chunk-OB37O552.js.map
