import {
  decodeMessage,
  ed25519,
  encodeMessage,
  enumeration,
  message,
  secp256k1
} from "./chunk-4WIHOBZE.js";
import {
  Uint8ArrayList
} from "./chunk-BYS5BAPP.js";
import {
  CID,
  base58btc,
  decode,
  fromString,
  identity,
  sha256,
  toString
} from "./chunk-AV7VJIQH.js";
import {
  equals
} from "./chunk-PM7HCL6E.js";
import {
  __publicField
} from "./chunk-WOOG5QLI.js";

// node_modules/.pnpm/@libp2p+interface@2.9.0/node_modules/@libp2p/interface/dist/src/connection.js
var connectionSymbol = Symbol.for("@libp2p/connection");

// node_modules/.pnpm/@libp2p+interface@2.9.0/node_modules/@libp2p/interface/dist/src/content-routing.js
var contentRoutingSymbol = Symbol.for("@libp2p/content-routing");

// node_modules/.pnpm/@libp2p+interface@2.9.0/node_modules/@libp2p/interface/dist/src/peer-discovery.js
var peerDiscoverySymbol = Symbol.for("@libp2p/peer-discovery");

// node_modules/.pnpm/@libp2p+interface@2.9.0/node_modules/@libp2p/interface/dist/src/peer-id.js
var peerIdSymbol = Symbol.for("@libp2p/peer-id");

// node_modules/.pnpm/@libp2p+interface@2.9.0/node_modules/@libp2p/interface/dist/src/peer-routing.js
var peerRoutingSymbol = Symbol.for("@libp2p/peer-routing");

// node_modules/.pnpm/@libp2p+interface@2.9.0/node_modules/@libp2p/interface/dist/src/pubsub.js
var TopicValidatorResult;
(function(TopicValidatorResult2) {
  TopicValidatorResult2["Accept"] = "accept";
  TopicValidatorResult2["Ignore"] = "ignore";
  TopicValidatorResult2["Reject"] = "reject";
})(TopicValidatorResult || (TopicValidatorResult = {}));
var pubSubSymbol = Symbol.for("@libp2p/pubsub");

// node_modules/.pnpm/@libp2p+interface@2.9.0/node_modules/@libp2p/interface/dist/src/transport.js
var transportSymbol = Symbol.for("@libp2p/transport");
var FaultTolerance;
(function(FaultTolerance2) {
  FaultTolerance2[FaultTolerance2["FATAL_ALL"] = 0] = "FATAL_ALL";
  FaultTolerance2[FaultTolerance2["NO_FATAL"] = 1] = "NO_FATAL";
})(FaultTolerance || (FaultTolerance = {}));

// node_modules/.pnpm/@libp2p+interface@2.9.0/node_modules/@libp2p/interface/dist/src/errors.js
var InvalidParametersError = class extends Error {
  constructor(message2 = "Invalid parameters") {
    super(message2);
    this.name = "InvalidParametersError";
  }
};
__publicField(InvalidParametersError, "name", "InvalidParametersError");
var InvalidPublicKeyError = class extends Error {
  constructor(message2 = "Invalid public key") {
    super(message2);
    this.name = "InvalidPublicKeyError";
  }
};
__publicField(InvalidPublicKeyError, "name", "InvalidPublicKeyError");
var InvalidCIDError = class extends Error {
  constructor(message2 = "Invalid CID") {
    super(message2);
    this.name = "InvalidCIDError";
  }
};
__publicField(InvalidCIDError, "name", "InvalidCIDError");
var InvalidMultihashError = class extends Error {
  constructor(message2 = "Invalid Multihash") {
    super(message2);
    this.name = "InvalidMultihashError";
  }
};
__publicField(InvalidMultihashError, "name", "InvalidMultihashError");
var UnsupportedKeyTypeError = class extends Error {
  constructor(message2 = "Unsupported key type") {
    super(message2);
    this.name = "UnsupportedKeyTypeError";
  }
};
__publicField(UnsupportedKeyTypeError, "name", "UnsupportedKeyTypeError");

// node_modules/.pnpm/@libp2p+interface@2.9.0/node_modules/@libp2p/interface/dist/src/index.js
var serviceCapabilities = Symbol.for("@libp2p/service-capabilities");
var serviceDependencies = Symbol.for("@libp2p/service-dependencies");

// node_modules/.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/dist/src/keys/rsa/der.js
var TAG_MASK = parseInt("11111", 2);
var LONG_LENGTH_MASK = parseInt("10000000", 2);
var LONG_LENGTH_BYTES_MASK = parseInt("01111111", 2);
var decoders = {
  0: readSequence,
  1: readSequence,
  2: readInteger,
  3: readBitString,
  4: readOctetString,
  5: readNull,
  6: readObjectIdentifier,
  16: readSequence,
  22: readSequence,
  48: readSequence
};
function decodeDer(buf, context = { offset: 0 }) {
  const tag = buf[context.offset] & TAG_MASK;
  context.offset++;
  if (decoders[tag] != null) {
    return decoders[tag](buf, context);
  }
  throw new Error("No decoder for tag " + tag);
}
function readLength(buf, context) {
  let length = 0;
  if ((buf[context.offset] & LONG_LENGTH_MASK) === LONG_LENGTH_MASK) {
    const count = buf[context.offset] & LONG_LENGTH_BYTES_MASK;
    let str = "0x";
    context.offset++;
    for (let i = 0; i < count; i++, context.offset++) {
      str += buf[context.offset].toString(16).padStart(2, "0");
    }
    length = parseInt(str, 16);
  } else {
    length = buf[context.offset];
    context.offset++;
  }
  return length;
}
function readSequence(buf, context) {
  readLength(buf, context);
  const entries = [];
  while (true) {
    if (context.offset >= buf.byteLength) {
      break;
    }
    const result = decodeDer(buf, context);
    if (result === null) {
      break;
    }
    entries.push(result);
  }
  return entries;
}
function readInteger(buf, context) {
  const length = readLength(buf, context);
  const start = context.offset;
  const end = context.offset + length;
  const vals = [];
  for (let i = start; i < end; i++) {
    if (i === start && buf[i] === 0) {
      continue;
    }
    vals.push(buf[i]);
  }
  context.offset += length;
  return Uint8Array.from(vals);
}
function readObjectIdentifier(buf, context) {
  const count = readLength(buf, context);
  const finalOffset = context.offset + count;
  const byte = buf[context.offset];
  context.offset++;
  let val1 = 0;
  let val2 = 0;
  if (byte < 40) {
    val1 = 0;
    val2 = byte;
  } else if (byte < 80) {
    val1 = 1;
    val2 = byte - 40;
  } else {
    val1 = 2;
    val2 = byte - 80;
  }
  let oid = `${val1}.${val2}`;
  let num = [];
  while (context.offset < finalOffset) {
    const byte2 = buf[context.offset];
    context.offset++;
    num.push(byte2 & 127);
    if (byte2 < 128) {
      num.reverse();
      let val = 0;
      for (let i = 0; i < num.length; i++) {
        val += num[i] << i * 7;
      }
      oid += `.${val}`;
      num = [];
    }
  }
  return oid;
}
function readNull(buf, context) {
  context.offset++;
  return null;
}
function readBitString(buf, context) {
  const length = readLength(buf, context);
  const unusedBits = buf[context.offset];
  context.offset++;
  const bytes = buf.subarray(context.offset, context.offset + length - 1);
  context.offset += length;
  if (unusedBits !== 0) {
    throw new Error("Unused bits in bit string is unimplemented");
  }
  return bytes;
}
function readOctetString(buf, context) {
  const length = readLength(buf, context);
  const bytes = buf.subarray(context.offset, context.offset + length);
  context.offset += length;
  return bytes;
}
function encodeNumber(value) {
  let number = value.toString(16);
  if (number.length % 2 === 1) {
    number = "0" + number;
  }
  const array = new Uint8ArrayList();
  for (let i = 0; i < number.length; i += 2) {
    array.append(Uint8Array.from([parseInt(`${number[i]}${number[i + 1]}`, 16)]));
  }
  return array;
}
function encodeLength(bytes) {
  if (bytes.byteLength < 128) {
    return Uint8Array.from([bytes.byteLength]);
  }
  const length = encodeNumber(bytes.byteLength);
  return new Uint8ArrayList(Uint8Array.from([
    length.byteLength | LONG_LENGTH_MASK
  ]), length);
}
function encodeInteger(value) {
  const contents = new Uint8ArrayList();
  const mask = 128;
  const positive = (value.subarray()[0] & mask) === mask;
  if (positive) {
    contents.append(Uint8Array.from([0]));
  }
  contents.append(value);
  return new Uint8ArrayList(Uint8Array.from([2]), encodeLength(contents), contents);
}
function encodeBitString(value) {
  const unusedBits = Uint8Array.from([0]);
  const contents = new Uint8ArrayList(unusedBits, value);
  return new Uint8ArrayList(Uint8Array.from([3]), encodeLength(contents), contents);
}
function encodeSequence(values, tag = 48) {
  const output = new Uint8ArrayList();
  for (const buf of values) {
    output.append(buf);
  }
  return new Uint8ArrayList(Uint8Array.from([tag]), encodeLength(output), output);
}

// node_modules/.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/dist/src/keys/ecdsa/index.js
async function hashAndVerify(key, sig, msg) {
  const publicKey = await crypto.subtle.importKey("jwk", key, {
    name: "ECDSA",
    namedCurve: key.crv ?? "P-256"
  }, false, ["verify"]);
  return crypto.subtle.verify({
    name: "ECDSA",
    hash: {
      name: "SHA-256"
    }
  }, publicKey, sig, msg.subarray());
}

// node_modules/.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/dist/src/keys/ecdsa/utils.js
var OID_256 = Uint8Array.from([6, 8, 42, 134, 72, 206, 61, 3, 1, 7]);
var OID_384 = Uint8Array.from([6, 5, 43, 129, 4, 0, 34]);
var OID_521 = Uint8Array.from([6, 5, 43, 129, 4, 0, 35]);
var P_256_KEY_JWK = {
  ext: true,
  kty: "EC",
  crv: "P-256"
};
var P_384_KEY_JWK = {
  ext: true,
  kty: "EC",
  crv: "P-384"
};
var P_521_KEY_JWK = {
  ext: true,
  kty: "EC",
  crv: "P-521"
};
var P_256_KEY_LENGTH = 32;
var P_384_KEY_LENGTH = 48;
var P_521_KEY_LENGTH = 66;
function unmarshalECDSAPublicKey(bytes) {
  const message2 = decodeDer(bytes);
  return pkiMessageToECDSAPublicKey(message2);
}
function pkiMessageToECDSAPublicKey(message2) {
  const coordinates = message2[1][1][0];
  const offset = 1;
  let x;
  let y;
  if (coordinates.byteLength === P_256_KEY_LENGTH * 2 + 1) {
    x = toString(coordinates.subarray(offset, offset + P_256_KEY_LENGTH), "base64url");
    y = toString(coordinates.subarray(offset + P_256_KEY_LENGTH), "base64url");
    return new ECDSAPublicKey({
      ...P_256_KEY_JWK,
      key_ops: ["verify"],
      x,
      y
    });
  }
  if (coordinates.byteLength === P_384_KEY_LENGTH * 2 + 1) {
    x = toString(coordinates.subarray(offset, offset + P_384_KEY_LENGTH), "base64url");
    y = toString(coordinates.subarray(offset + P_384_KEY_LENGTH), "base64url");
    return new ECDSAPublicKey({
      ...P_384_KEY_JWK,
      key_ops: ["verify"],
      x,
      y
    });
  }
  if (coordinates.byteLength === P_521_KEY_LENGTH * 2 + 1) {
    x = toString(coordinates.subarray(offset, offset + P_521_KEY_LENGTH), "base64url");
    y = toString(coordinates.subarray(offset + P_521_KEY_LENGTH), "base64url");
    return new ECDSAPublicKey({
      ...P_521_KEY_JWK,
      key_ops: ["verify"],
      x,
      y
    });
  }
  throw new InvalidParametersError(`coordinates were wrong length, got ${coordinates.byteLength}, expected 65, 97 or 133`);
}
function publicKeyToPKIMessage(publicKey) {
  return encodeSequence([
    encodeInteger(Uint8Array.from([1])),
    // header
    encodeSequence([
      getOID(publicKey.crv)
    ], 160),
    encodeSequence([
      encodeBitString(new Uint8ArrayList(Uint8Array.from([4]), fromString(publicKey.x ?? "", "base64url"), fromString(publicKey.y ?? "", "base64url")))
    ], 161)
  ]).subarray();
}
function getOID(curve) {
  if (curve === "P-256") {
    return OID_256;
  }
  if (curve === "P-384") {
    return OID_384;
  }
  if (curve === "P-521") {
    return OID_521;
  }
  throw new InvalidParametersError(`Invalid curve ${curve}`);
}

// node_modules/.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/dist/src/keys/ecdsa/ecdsa.js
var ECDSAPublicKey = class {
  constructor(jwk) {
    __publicField(this, "type", "ECDSA");
    __publicField(this, "jwk");
    __publicField(this, "_raw");
    this.jwk = jwk;
  }
  get raw() {
    if (this._raw == null) {
      this._raw = publicKeyToPKIMessage(this.jwk);
    }
    return this._raw;
  }
  toMultihash() {
    return identity.digest(publicKeyToProtobuf(this));
  }
  toCID() {
    return CID.createV1(114, this.toMultihash());
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key.raw);
  }
  async verify(data, sig) {
    return hashAndVerify(this.jwk, sig, data);
  }
};

// node_modules/.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/dist/src/keys/ed25519/index.browser.js
var PUBLIC_KEY_BYTE_LENGTH = 32;
function hashAndVerify2(publicKey, sig, msg) {
  return ed25519.verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey);
}

// node_modules/.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/dist/src/keys/ed25519/ed25519.js
var Ed25519PublicKey = class {
  constructor(key) {
    __publicField(this, "type", "Ed25519");
    __publicField(this, "raw");
    this.raw = ensureEd25519Key(key, PUBLIC_KEY_BYTE_LENGTH);
  }
  toMultihash() {
    return identity.digest(publicKeyToProtobuf(this));
  }
  toCID() {
    return CID.createV1(114, this.toMultihash());
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key.raw);
  }
  verify(data, sig) {
    return hashAndVerify2(this.raw, sig, data);
  }
};

// node_modules/.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/dist/src/keys/ed25519/utils.js
function unmarshalEd25519PublicKey(bytes) {
  bytes = ensureEd25519Key(bytes, PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PublicKey(bytes);
}
function ensureEd25519Key(key, length) {
  key = Uint8Array.from(key ?? []);
  if (key.length !== length) {
    throw new InvalidParametersError(`Key must be a Uint8Array of length ${length}, got ${key.length}`);
  }
  return key;
}

// node_modules/.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/dist/src/keys/keys.js
var KeyType;
(function(KeyType2) {
  KeyType2["RSA"] = "RSA";
  KeyType2["Ed25519"] = "Ed25519";
  KeyType2["secp256k1"] = "secp256k1";
  KeyType2["ECDSA"] = "ECDSA";
})(KeyType || (KeyType = {}));
var __KeyTypeValues;
(function(__KeyTypeValues2) {
  __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
  __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
  __KeyTypeValues2[__KeyTypeValues2["secp256k1"] = 2] = "secp256k1";
  __KeyTypeValues2[__KeyTypeValues2["ECDSA"] = 3] = "ECDSA";
})(__KeyTypeValues || (__KeyTypeValues = {}));
(function(KeyType2) {
  KeyType2.codec = () => {
    return enumeration(__KeyTypeValues);
  };
})(KeyType || (KeyType = {}));
var PublicKey;
(function(PublicKey2) {
  let _codec;
  PublicKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {};
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.Type = KeyType.codec().decode(reader);
              break;
            }
            case 2: {
              obj.Data = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PublicKey2.encode = (obj) => {
    return encodeMessage(obj, PublicKey2.codec());
  };
  PublicKey2.decode = (buf, opts) => {
    return decodeMessage(buf, PublicKey2.codec(), opts);
  };
})(PublicKey || (PublicKey = {}));
var PrivateKey;
(function(PrivateKey2) {
  let _codec;
  PrivateKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {};
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.Type = KeyType.codec().decode(reader);
              break;
            }
            case 2: {
              obj.Data = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PrivateKey2.encode = (obj) => {
    return encodeMessage(obj, PrivateKey2.codec());
  };
  PrivateKey2.decode = (buf, opts) => {
    return decodeMessage(buf, PrivateKey2.codec(), opts);
  };
})(PrivateKey || (PrivateKey = {}));

// node_modules/.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/dist/src/errors.js
var VerificationError = class extends Error {
  constructor(message2 = "An error occurred while verifying a message") {
    super(message2);
    this.name = "VerificationError";
  }
};

// node_modules/.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/dist/src/keys/rsa/utils.js
var RSA_ALGORITHM_IDENTIFIER = Uint8Array.from([
  48,
  13,
  6,
  9,
  42,
  134,
  72,
  134,
  247,
  13,
  1,
  1,
  1,
  5,
  0
]);

// node_modules/.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/dist/src/util.js
function isPromise(thing) {
  if (thing == null) {
    return false;
  }
  return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}

// node_modules/.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/dist/src/keys/secp256k1/index.browser.js
function hashAndVerify4(key, sig, msg) {
  const p = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray());
  if (isPromise(p)) {
    return p.then(({ digest }) => secp256k1.verify(sig, digest, key)).catch((err) => {
      throw new VerificationError(String(err));
    });
  }
  try {
    return secp256k1.verify(sig, p.digest, key);
  } catch (err) {
    throw new VerificationError(String(err));
  }
}

// node_modules/.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/dist/src/keys/secp256k1/secp256k1.js
var Secp256k1PublicKey = class {
  constructor(key) {
    __publicField(this, "type", "secp256k1");
    __publicField(this, "raw");
    __publicField(this, "_key");
    this._key = validateSecp256k1PublicKey(key);
    this.raw = compressSecp256k1PublicKey(this._key);
  }
  toMultihash() {
    return identity.digest(publicKeyToProtobuf(this));
  }
  toCID() {
    return CID.createV1(114, this.toMultihash());
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key.raw);
  }
  verify(data, sig) {
    return hashAndVerify4(this._key, sig, data);
  }
};

// node_modules/.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/dist/src/keys/secp256k1/utils.js
function unmarshalSecp256k1PublicKey(bytes) {
  return new Secp256k1PublicKey(bytes);
}
function compressSecp256k1PublicKey(key) {
  const point = secp256k1.ProjectivePoint.fromHex(key).toRawBytes(true);
  return point;
}
function validateSecp256k1PublicKey(key) {
  try {
    secp256k1.ProjectivePoint.fromHex(key);
    return key;
  } catch (err) {
    throw new InvalidPublicKeyError(String(err));
  }
}

// node_modules/.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/dist/src/keys/ecdh/index.browser.js
var curveLengths = {
  "P-256": 32,
  "P-384": 48,
  "P-521": 66
};
var curveTypes = Object.keys(curveLengths);
var names = curveTypes.join(" / ");

// node_modules/.pnpm/@libp2p+crypto@5.1.1/node_modules/@libp2p/crypto/dist/src/keys/index.js
function publicKeyFromMultihash(digest) {
  const { Type, Data } = PublicKey.decode(digest.digest);
  const data = Data ?? new Uint8Array();
  switch (Type) {
    case KeyType.Ed25519:
      return unmarshalEd25519PublicKey(data);
    case KeyType.secp256k1:
      return unmarshalSecp256k1PublicKey(data);
    case KeyType.ECDSA:
      return unmarshalECDSAPublicKey(data);
    default:
      throw new UnsupportedKeyTypeError();
  }
}
function publicKeyToProtobuf(key) {
  return PublicKey.encode({
    Type: KeyType[key.type],
    Data: key.raw
  });
}

// node_modules/.pnpm/@libp2p+peer-id@5.1.2/node_modules/@libp2p/peer-id/dist/src/peer-id.js
var inspect = Symbol.for("nodejs.util.inspect.custom");
var LIBP2P_KEY_CODE = 114;
var _a;
var PeerIdImpl = class {
  constructor(init) {
    __publicField(this, "type");
    __publicField(this, "multihash");
    __publicField(this, "publicKey");
    __publicField(this, "string");
    __publicField(this, _a, true);
    this.type = init.type;
    this.multihash = init.multihash;
    Object.defineProperty(this, "string", {
      enumerable: false,
      writable: true
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  toString() {
    if (this.string == null) {
      this.string = base58btc.encode(this.multihash.bytes).slice(1);
    }
    return this.string;
  }
  toMultihash() {
    return this.multihash;
  }
  // return self-describing String representation
  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
  toCID() {
    return CID.createV1(LIBP2P_KEY_CODE, this.multihash);
  }
  toJSON() {
    return this.toString();
  }
  /**
   * Checks the equality of `this` peer against a given PeerId
   */
  equals(id) {
    var _a3;
    if (id == null) {
      return false;
    }
    if (id instanceof Uint8Array) {
      return equals(this.multihash.bytes, id);
    } else if (typeof id === "string") {
      return this.toString() === id;
    } else if (((_a3 = id == null ? void 0 : id.toMultihash()) == null ? void 0 : _a3.bytes) != null) {
      return equals(this.multihash.bytes, id.toMultihash().bytes);
    } else {
      throw new Error("not valid Id");
    }
  }
  /**
   * Returns PeerId as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```TypeScript
   * import { peerIdFromString } from '@libp2p/peer-id'
   *
   * console.info(peerIdFromString('QmFoo'))
   * // 'PeerId(QmFoo)'
   * ```
   */
  [(_a = peerIdSymbol, inspect)]() {
    return `PeerId(${this.toString()})`;
  }
};
var RSAPeerId = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "RSA" });
    __publicField(this, "type", "RSA");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var Ed25519PeerId = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "Ed25519" });
    __publicField(this, "type", "Ed25519");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var Secp256k1PeerId = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "secp256k1" });
    __publicField(this, "type", "secp256k1");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var TRANSPORT_IPFS_GATEWAY_HTTP_CODE = 2336;
var _a2, _b;
var URLPeerId = class {
  constructor(url) {
    __publicField(this, "type", "url");
    __publicField(this, "multihash");
    __publicField(this, "publicKey");
    __publicField(this, "url");
    __publicField(this, _a2, true);
    this.url = url.toString();
    this.multihash = identity.digest(fromString(this.url));
  }
  [(_b = inspect, _a2 = peerIdSymbol, _b)]() {
    return `PeerId(${this.url})`;
  }
  toString() {
    return this.toCID().toString();
  }
  toMultihash() {
    return this.multihash;
  }
  toCID() {
    return CID.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE, this.toMultihash());
  }
  toJSON() {
    return this.toString();
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (other instanceof Uint8Array) {
      other = toString(other);
    }
    return other.toString() === this.toString();
  }
};

// node_modules/.pnpm/@libp2p+peer-id@5.1.2/node_modules/@libp2p/peer-id/dist/src/index.js
var LIBP2P_KEY_CODE2 = 114;
var TRANSPORT_IPFS_GATEWAY_HTTP_CODE2 = 2336;
function peerIdFromString(str, decoder) {
  let multihash;
  if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
    multihash = decode(base58btc.decode(`z${str}`));
  } else if (str.startsWith("k51qzi5uqu5") || str.startsWith("kzwfwjn5ji4") || str.startsWith("k2k4r8") || str.startsWith("bafz")) {
    return peerIdFromCID(CID.parse(str));
  } else {
    if (decoder == null) {
      throw new InvalidParametersError('Please pass a multibase decoder for strings that do not start with "1" or "Q"');
    }
    multihash = decode(decoder.decode(str));
  }
  return peerIdFromMultihash(multihash);
}
function peerIdFromPublicKey(publicKey) {
  if (publicKey.type === "Ed25519") {
    return new Ed25519PeerId({
      multihash: publicKey.toCID().multihash,
      publicKey
    });
  } else if (publicKey.type === "secp256k1") {
    return new Secp256k1PeerId({
      multihash: publicKey.toCID().multihash,
      publicKey
    });
  } else if (publicKey.type === "RSA") {
    return new RSAPeerId({
      multihash: publicKey.toCID().multihash,
      publicKey
    });
  }
  throw new UnsupportedKeyTypeError();
}
function peerIdFromPrivateKey(privateKey) {
  return peerIdFromPublicKey(privateKey.publicKey);
}
function peerIdFromMultihash(multihash) {
  if (isSha256Multihash(multihash)) {
    return new RSAPeerId({ multihash });
  } else if (isIdentityMultihash(multihash)) {
    try {
      const publicKey = publicKeyFromMultihash(multihash);
      if (publicKey.type === "Ed25519") {
        return new Ed25519PeerId({ multihash, publicKey });
      } else if (publicKey.type === "secp256k1") {
        return new Secp256k1PeerId({ multihash, publicKey });
      }
    } catch (err) {
      const url = toString(multihash.digest);
      return new URLPeerId(new URL(url));
    }
  }
  throw new InvalidMultihashError("Supplied PeerID Multihash is invalid");
}
function peerIdFromCID(cid) {
  if ((cid == null ? void 0 : cid.multihash) == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE2 && cid.code !== TRANSPORT_IPFS_GATEWAY_HTTP_CODE2) {
    throw new InvalidCIDError("Supplied PeerID CID is invalid");
  }
  if (cid.code === TRANSPORT_IPFS_GATEWAY_HTTP_CODE2) {
    const url = toString(cid.multihash.digest);
    return new URLPeerId(new URL(url));
  }
  return peerIdFromMultihash(cid.multihash);
}
function isIdentityMultihash(multihash) {
  return multihash.code === identity.code;
}
function isSha256Multihash(multihash) {
  return multihash.code === sha256.code;
}

export {
  peerIdFromString,
  peerIdFromPublicKey,
  peerIdFromPrivateKey,
  peerIdFromMultihash,
  peerIdFromCID
};
//# sourceMappingURL=chunk-5LMJJA6Q.js.map
