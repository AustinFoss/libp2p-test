{
  "version": 3,
  "sources": ["../../.pnpm/@libp2p+webtransport@5.0.37/node_modules/@libp2p/webtransport/src/constants.ts", "../../.pnpm/@libp2p+webtransport@5.0.37/node_modules/@libp2p/webtransport/src/listener.browser.ts", "../../.pnpm/@libp2p+webtransport@5.0.37/node_modules/@libp2p/webtransport/src/stream.ts", "../../.pnpm/@libp2p+webtransport@5.0.37/node_modules/@libp2p/webtransport/src/utils/inert-duplex.ts", "../../.pnpm/@libp2p+webtransport@5.0.37/node_modules/@libp2p/webtransport/src/muxer.ts", "../../.pnpm/@libp2p+webtransport@5.0.37/node_modules/@libp2p/webtransport/src/utils/is-subset.ts", "../../.pnpm/@libp2p+webtransport@5.0.37/node_modules/@libp2p/webtransport/src/utils/parse-multiaddr.ts", "../../.pnpm/@libp2p+webtransport@5.0.37/node_modules/@libp2p/webtransport/src/webtransport.browser.ts", "../../.pnpm/@libp2p+webtransport@5.0.37/node_modules/@libp2p/webtransport/src/index.ts"],
  "sourcesContent": ["export const MAX_INBOUND_STREAMS = 1_000\n", "import type { CreateListenerOptions, Listener } from '@libp2p/interface'\n\nexport default function createListener (options: CreateListenerOptions): Listener {\n  throw new Error('Not implemented')\n}\n", "import { AbstractStream, type AbstractStreamInit } from '@libp2p/utils/abstract-stream'\nimport { raceSignal } from 'race-signal'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport type { AbortOptions, ComponentLogger, Direction, Stream } from '@libp2p/interface'\n\ninterface WebTransportStreamInit extends AbstractStreamInit {\n  bidiStream: WebTransportBidirectionalStream\n}\n\nclass WebTransportStream extends AbstractStream {\n  private readonly writer: WritableStreamDefaultWriter<Uint8Array>\n  private readonly reader: ReadableStreamDefaultReader<Uint8Array>\n\n  constructor (init: WebTransportStreamInit) {\n    super(init)\n\n    this.writer = init.bidiStream.writable.getWriter()\n    this.reader = init.bidiStream.readable.getReader()\n\n    Promise.resolve()\n      .then(async () => {\n        while (true) {\n          const result = await this.reader.read()\n\n          if (result.done) {\n            init.log('remote closed write')\n            return\n          }\n\n          if (result.value != null) {\n            this.sourcePush(new Uint8ArrayList(result.value))\n          }\n        }\n      })\n      .catch(err => {\n        init.log.error('error reading from stream', err)\n        this.abort(err)\n      })\n      .finally(() => {\n        this.remoteCloseWrite()\n      })\n\n    void this.writer.closed\n      .then(() => {\n        init.log('writer closed')\n      })\n      .catch((err) => {\n        init.log('writer close promise rejected', err)\n      })\n      .finally(() => {\n        this.remoteCloseRead()\n      })\n  }\n\n  sendNewStream (options?: AbortOptions | undefined): void {\n    // this is a no-op\n  }\n\n  async sendData (buf: Uint8ArrayList, options?: AbortOptions): Promise<void> {\n    for await (const chunk of buf) {\n      this.log('sendData waiting for writer to be ready')\n      await raceSignal(this.writer.ready, options?.signal)\n\n      // the streams spec recommends not waiting for data to be sent\n      // https://streams.spec.whatwg.org/#example-manual-write-dont-await\n      this.writer.write(chunk)\n        .catch(err => {\n          this.log.error('error sending stream data', err)\n        })\n    }\n  }\n\n  async sendReset (options?: AbortOptions): Promise<void> {\n    this.log('sendReset aborting writer')\n    await raceSignal(this.writer.abort(), options?.signal)\n    this.log('sendReset aborted writer')\n  }\n\n  async sendCloseWrite (options?: AbortOptions): Promise<void> {\n    this.log('sendCloseWrite closing writer')\n    await raceSignal(this.writer.close(), options?.signal)\n    this.log('sendCloseWrite closed writer')\n  }\n\n  async sendCloseRead (options?: AbortOptions): Promise<void> {\n    this.log('sendCloseRead cancelling reader')\n    await raceSignal(this.reader.cancel(), options?.signal)\n    this.log('sendCloseRead cancelled reader')\n  }\n}\n\nexport async function webtransportBiDiStreamToStream (bidiStream: WebTransportBidirectionalStream, streamId: string, direction: Direction, activeStreams: Stream[], onStreamEnd: undefined | ((s: Stream) => void), logger: ComponentLogger): Promise<Stream> {\n  const log = logger.forComponent(`libp2p:webtransport:stream:${direction}:${streamId}`)\n\n  const stream = new WebTransportStream({\n    bidiStream,\n    id: streamId,\n    direction,\n    log,\n    onEnd: () => {\n      const index = activeStreams.findIndex(s => s === stream)\n      if (index !== -1) {\n        activeStreams.splice(index, 1)\n      }\n\n      onStreamEnd?.(stream)\n    }\n  })\n\n  return stream\n}\n", "import type { Duplex, Source } from 'it-stream-types'\n\n// Duplex that does nothing. Needed to fulfill the interface\nexport function inertDuplex (): Duplex<any, any, any> {\n  return {\n    source: {\n      [Symbol.asyncIterator] () {\n        return {\n          async next () {\n            // This will never resolve\n            return new Promise(() => { })\n          }\n        }\n      }\n    },\n    sink: async (source: Source<any>) => {\n      // This will never resolve\n      return new Promise(() => { })\n    }\n  }\n}\n", "import { webtransportBiDiStreamToStream } from './stream.js'\nimport { inertDuplex } from './utils/inert-duplex.js'\nimport type WebTransport from './webtransport.js'\nimport type { ComponentLogger, Stream, StreamMuxer, StreamMuxerFactory, StreamMuxerInit } from '@libp2p/interface'\n\nexport interface WebTransportMuxerInit {\n  maxInboundStreams: number\n}\n\nexport function webtransportMuxer (wt: Pick<WebTransport, 'close' | 'createBidirectionalStream'>, reader: ReadableStreamDefaultReader<WebTransportBidirectionalStream>, logger: ComponentLogger, config: WebTransportMuxerInit): StreamMuxerFactory {\n  let streamIDCounter = 0\n  const log = logger.forComponent('libp2p:webtransport:muxer')\n\n  return {\n    protocol: 'webtransport',\n    createStreamMuxer: (init?: StreamMuxerInit): StreamMuxer => {\n      // !TODO handle abort signal when WebTransport supports this.\n\n      if (typeof init === 'function') {\n        // The api docs say that init may be a function\n        init = { onIncomingStream: init }\n      }\n\n      const activeStreams: Stream[] = []\n\n      Promise.resolve()\n        .then(async () => {\n          //! TODO unclear how to add backpressure here?\n          while (true) {\n            const { done, value: wtStream } = await reader.read()\n\n            if (done) {\n              break\n            }\n\n            if (activeStreams.length >= config.maxInboundStreams) {\n              log(`too many inbound streams open - ${activeStreams.length}/${config.maxInboundStreams}, closing new incoming stream`)\n              // We've reached our limit, close this stream.\n              wtStream.writable.close().catch((err: Error) => {\n                log.error(`failed to close inbound stream that crossed our maxInboundStream limit: ${err.message}`)\n              })\n              wtStream.readable.cancel().catch((err: Error) => {\n                log.error(`failed to close inbound stream that crossed our maxInboundStream limit: ${err.message}`)\n              })\n            } else {\n              const stream = await webtransportBiDiStreamToStream(\n                wtStream,\n                String(streamIDCounter++),\n                'inbound',\n                activeStreams,\n                init?.onStreamEnd,\n                logger\n              )\n              activeStreams.push(stream)\n              init?.onIncomingStream?.(stream)\n            }\n          }\n        })\n        .catch(err => {\n          log.error('could not create a new stream', err)\n        })\n\n      const muxer: StreamMuxer = {\n        protocol: 'webtransport',\n        streams: activeStreams,\n        newStream: async (name?: string): Promise<Stream> => {\n          log('new outgoing stream', name)\n\n          const wtStream = await wt.createBidirectionalStream()\n          const stream = await webtransportBiDiStreamToStream(wtStream, String(streamIDCounter++), init?.direction ?? 'outbound', activeStreams, init?.onStreamEnd, logger)\n          activeStreams.push(stream)\n\n          return stream\n        },\n\n        /**\n         * Close all tracked streams and stop the muxer\n         */\n        close: async () => {\n          log('closing webtransport muxer gracefully')\n\n          try {\n            wt.close()\n          } catch (err: any) {\n            muxer.abort(err)\n          }\n        },\n\n        /**\n         * Abort all tracked streams and stop the muxer\n         */\n        abort: (err: Error) => {\n          log('closing webtransport muxer with err:', err)\n\n          try {\n            wt.close()\n          } catch (err: any) {\n            log.error('webtransport session threw error during close', err)\n          }\n        },\n\n        // This stream muxer is webtransport native. Therefore it doesn't plug in with any other duplex.\n        ...inertDuplex()\n      }\n\n      return muxer\n    }\n  }\n}\n", "import { equals as uint8ArrayEquals } from 'uint8arrays/equals'\n\n/**\n * Determines if `maybeSubset` is a subset of `set`. This means that all byte\n * arrays in `maybeSubset` are present in `set`.\n */\nexport function isSubset (set: Uint8Array[], maybeSubset: Uint8Array[]): boolean {\n  const intersection = maybeSubset.filter(byteArray => {\n    return Boolean(set.find((otherByteArray: Uint8Array) => uint8ArrayEquals(byteArray, otherByteArray)))\n  })\n  return (intersection.length === maybeSubset.length)\n}\n", "import { InvalidMultiaddrError } from '@libp2p/interface'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { type Multiaddr, protocols } from '@multiformats/multiaddr'\nimport { WebTransport } from '@multiformats/multiaddr-matcher'\nimport { bases, digest } from 'multiformats/basics'\nimport type { PeerId } from '@libp2p/interface'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\n\n// @ts-expect-error - Not easy to combine these types.\nconst multibaseDecoder = Object.values(bases).map(b => b.decoder).reduce((d, b) => d.or(b))\n\nfunction decodeCerthashStr (s: string): MultihashDigest {\n  return digest.decode(multibaseDecoder.decode(s))\n}\n\nexport interface ParsedMultiaddr {\n  url: string\n  certhashes: MultihashDigest[]\n  remotePeer?: PeerId\n}\n\nexport function parseMultiaddr (ma: Multiaddr): ParsedMultiaddr {\n  if (!WebTransport.matches(ma)) {\n    throw new InvalidMultiaddrError('Invalid multiaddr, was not a WebTransport address')\n  }\n\n  const parts = ma.stringTuples()\n  const certhashes = parts\n    .filter(([name, _]) => name === protocols('certhash').code)\n    .map(([_, value]) => decodeCerthashStr(value ?? ''))\n\n  // only take the first peer id in the multiaddr as it may be a relay\n  const remotePeer = parts\n    .filter(([name, _]) => name === protocols('p2p').code)\n    .map(([_, value]) => peerIdFromString(value ?? ''))[0]\n\n  const opts = ma.toOptions()\n  let host = opts.host\n\n  if (opts.family === 6 && host?.includes(':')) {\n    /**\n     * This resolves cases where `new WebTransport()` fails to construct because of an invalid URL being passed.\n     *\n     * `new URL('https://::1:4001/blah')` will throw a `TypeError: Failed to construct 'URL': Invalid URL`\n     * `new URL('https://[::1]:4001/blah')` is valid and will not.\n     *\n     * @see https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2\n     */\n    host = `[${host}]`\n  }\n\n  return {\n    // All webtransport urls are https\n    url: `https://${host}:${opts.port}`,\n    certhashes,\n    remotePeer\n  }\n}\n", "// exporting property of globalThis allows us to fail gracefully in browsers\n// without WebTransport support\nexport default globalThis.WebTransport\n", "/**\n * @packageDocumentation\n *\n * A [libp2p transport](https://docs.libp2p.io/concepts/transports/overview/) based on [WebTransport](https://www.w3.org/TR/webtransport/).\n *\n * >\n * > ⚠️ **Note**\n * >\n * > This WebTransport implementation currently only allows dialing to other nodes. It does not yet allow listening for incoming dials. This feature requires QUIC support to land in Node JS first.\n * >\n * > QUIC support in Node JS is actively being worked on. You can keep an eye on the progress by watching the [related issues on the Node JS issue tracker](https://github.com/nodejs/node/labels/quic)\n * >\n *\n * @example\n *\n * ```TypeScript\n * import { createLibp2p } from 'libp2p'\n * import { webTransport } from '@libp2p/webtransport'\n * import { noise } from '@chainsafe/libp2p-noise'\n *\n * const node = await createLibp2p({\n *   transports: [\n *     webTransport()\n *   ],\n *   connectionEncrypters: [\n *     noise()\n *   ]\n * })\n * ```\n */\n\nimport { noise } from '@chainsafe/libp2p-noise'\nimport { InvalidCryptoExchangeError, InvalidParametersError, serviceCapabilities, transportSymbol } from '@libp2p/interface'\nimport { WebTransport as WebTransportMatcher } from '@multiformats/multiaddr-matcher'\nimport { CustomProgressEvent } from 'progress-events'\nimport { raceSignal } from 'race-signal'\nimport { MAX_INBOUND_STREAMS } from './constants.js'\nimport createListener from './listener.js'\nimport { webtransportMuxer } from './muxer.js'\nimport { inertDuplex } from './utils/inert-duplex.js'\nimport { isSubset } from './utils/is-subset.js'\nimport { parseMultiaddr } from './utils/parse-multiaddr.js'\nimport WebTransport from './webtransport.js'\nimport type { Upgrader, Transport, CreateListenerOptions, DialTransportOptions, Listener, ComponentLogger, Logger, Connection, MultiaddrConnection, CounterGroup, Metrics, PeerId, OutboundConnectionUpgradeEvents, PrivateKey } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Source } from 'it-stream-types'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\nimport type { ProgressEvent } from 'progress-events'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\n/**\n * PEM format server certificate and private key\n */\nexport interface WebTransportCertificate {\n  privateKey: string\n  pem: string\n  hash: MultihashDigest<number>\n  secret: string\n}\n\ninterface WebTransportSessionCleanup {\n  (metric: string): void\n}\n\nexport interface WebTransportInit {\n  maxInboundStreams?: number\n  certificates?: WebTransportCertificate[]\n}\n\nexport interface WebTransportComponents {\n  peerId: PeerId\n  privateKey: PrivateKey\n  metrics?: Metrics\n  logger: ComponentLogger\n  upgrader: Upgrader\n}\n\nexport interface WebTransportMetrics {\n  dialerEvents: CounterGroup\n}\n\nexport type WebTransportDialEvents =\n  OutboundConnectionUpgradeEvents |\n  ProgressEvent<'webtransport:wait-for-session'> |\n  ProgressEvent<'webtransport:open-authentication-stream'> |\n  ProgressEvent<'webtransport:secure-outbound-connection'> |\n  ProgressEvent<'webtransport:close-authentication-stream'>\n\ninterface AuthenticateWebTransportOptions extends DialTransportOptions<WebTransportDialEvents> {\n  wt: WebTransport\n  remotePeer?: PeerId\n  certhashes: Array<MultihashDigest<number>>\n}\n\nclass WebTransportTransport implements Transport<WebTransportDialEvents> {\n  private readonly log: Logger\n  private readonly components: WebTransportComponents\n  private readonly config: Required<WebTransportInit>\n  private readonly metrics?: WebTransportMetrics\n\n  constructor (components: WebTransportComponents, init: WebTransportInit = {}) {\n    this.log = components.logger.forComponent('libp2p:webtransport')\n    this.components = components\n    this.config = {\n      ...init,\n      maxInboundStreams: init.maxInboundStreams ?? MAX_INBOUND_STREAMS,\n      certificates: init.certificates ?? []\n    }\n\n    if (components.metrics != null) {\n      this.metrics = {\n        dialerEvents: components.metrics.registerCounterGroup('libp2p_webtransport_dialer_events_total', {\n          label: 'event',\n          help: 'Total count of WebTransport dialer events by type'\n        })\n      }\n    }\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/webtransport'\n\n  readonly [transportSymbol] = true\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/transport'\n  ]\n\n  async dial (ma: Multiaddr, options: DialTransportOptions<WebTransportDialEvents>): Promise<Connection> {\n    options.signal.throwIfAborted()\n\n    this.log('dialing %s', ma)\n\n    options = options ?? {}\n\n    const { url, certhashes, remotePeer } = parseMultiaddr(ma)\n    let abortListener: (() => void) | undefined\n    let maConn: MultiaddrConnection | undefined\n    let cleanUpWTSession: WebTransportSessionCleanup = () => {}\n    let closed = false\n    let ready = false\n    let authenticated = false\n\n    try {\n      this.metrics?.dialerEvents.increment({ pending: true })\n\n      const wt = new WebTransport(`${url}/.well-known/libp2p-webtransport?type=noise`, {\n        serverCertificateHashes: certhashes.map(certhash => ({\n          algorithm: 'sha-256',\n          value: certhash.digest\n        }))\n      })\n\n      cleanUpWTSession = (metric: string) => {\n        if (closed) {\n          // already closed session\n          return\n        }\n\n        try {\n          this.metrics?.dialerEvents.increment({ [metric]: true })\n          wt.close()\n        } catch (err) {\n          this.log.error('error closing wt session', err)\n        } finally {\n          // This is how we specify the connection is closed and shouldn't be used.\n          if (maConn != null) {\n            maConn.timeline.close = Date.now()\n          }\n\n          closed = true\n        }\n      }\n\n      // if the dial is aborted before we are ready, close the WebTransport session\n      abortListener = () => {\n        if (ready) {\n          cleanUpWTSession('noise_timeout')\n        } else {\n          cleanUpWTSession('ready_timeout')\n        }\n      }\n      options.signal.addEventListener('abort', abortListener, {\n        once: true\n      })\n\n      this.log('wait for session to be ready')\n      options.onProgress?.(new CustomProgressEvent('webtransport:wait-for-session'))\n      await Promise.race([\n        wt.closed,\n        wt.ready\n      ])\n      this.log('session became ready')\n\n      ready = true\n      this.metrics?.dialerEvents.increment({ ready: true })\n\n      // this promise resolves/throws when the session is closed\n      wt.closed.catch((err: Error) => {\n        this.log.error('error on remote wt session close', err)\n      })\n        .finally(() => {\n          cleanUpWTSession('remote_close')\n        })\n\n      authenticated = await raceSignal(this.authenticateWebTransport({ wt, remotePeer, certhashes, ...options }), options.signal)\n\n      if (!authenticated) {\n        throw new InvalidCryptoExchangeError('Failed to authenticate webtransport')\n      }\n\n      this.metrics?.dialerEvents.increment({ open: true })\n\n      maConn = {\n        close: async () => {\n          this.log('closing webtransport')\n          cleanUpWTSession('close')\n        },\n        abort: (err: Error) => {\n          this.log('aborting webtransport due to passed err', err)\n          cleanUpWTSession('abort')\n        },\n        remoteAddr: ma,\n        timeline: {\n          open: Date.now()\n        },\n        log: this.components.logger.forComponent('libp2p:webtransport:maconn'),\n        // This connection is never used directly since webtransport supports native streams.\n        ...inertDuplex()\n      }\n\n      return await options.upgrader.upgradeOutbound(maConn, {\n        ...options,\n        skipEncryption: true,\n        muxerFactory: webtransportMuxer(wt, wt.incomingBidirectionalStreams.getReader(), this.components.logger, this.config),\n        skipProtection: true\n      })\n    } catch (err: any) {\n      this.log.error('caught wt session err', err)\n\n      if (authenticated) {\n        cleanUpWTSession('upgrade_error')\n      } else if (ready) {\n        cleanUpWTSession('noise_error')\n      } else {\n        cleanUpWTSession('ready_error')\n      }\n\n      throw err\n    } finally {\n      if (abortListener != null) {\n        options.signal?.removeEventListener('abort', abortListener)\n      }\n    }\n  }\n\n  async authenticateWebTransport ({ wt, remotePeer, certhashes, onProgress, signal }: AuthenticateWebTransportOptions): Promise<boolean> {\n    signal?.throwIfAborted()\n\n    onProgress?.(new CustomProgressEvent('webtransport:open-authentication-stream'))\n    const stream = await wt.createBidirectionalStream()\n    const writer = stream.writable.getWriter()\n    const reader = stream.readable.getReader()\n\n    const duplex = {\n      source: (async function * () {\n        while (true) {\n          const val = await reader.read()\n\n          if (val.value != null) {\n            yield val.value\n          }\n\n          if (val.done) {\n            break\n          }\n        }\n      })(),\n      sink: async (source: Source<Uint8Array | Uint8ArrayList>) => {\n        for await (const chunk of source) {\n          await raceSignal(writer.ready, signal)\n\n          const buf = chunk instanceof Uint8Array ? chunk : chunk.subarray()\n\n          writer.write(buf).catch(err => {\n            this.log.error('could not write chunk during authentication of WebTransport stream', err)\n          })\n        }\n      }\n    }\n\n    const n = noise()(this.components)\n\n    onProgress?.(new CustomProgressEvent('webtransport:secure-outbound-connection'))\n    const { remoteExtensions } = await n.secureOutbound(duplex, {\n      signal,\n      remotePeer\n    })\n\n    onProgress?.(new CustomProgressEvent('webtransport:close-authentication-stream'))\n    // We're done with this authentication stream\n    writer.close().catch((err: Error) => {\n      this.log.error(`Failed to close authentication stream writer: ${err.message}`)\n    })\n\n    reader.cancel().catch((err: Error) => {\n      this.log.error(`Failed to close authentication stream reader: ${err.message}`)\n    })\n\n    // Verify the certhashes we used when dialing are a subset of the certhashes relayed by the remote peer\n    if (!isSubset(remoteExtensions?.webtransportCerthashes ?? [], certhashes.map(ch => ch.bytes))) {\n      throw new InvalidParametersError(\"Our certhashes are not a subset of the remote's reported certhashes\")\n    }\n\n    return true\n  }\n\n  createListener (options: CreateListenerOptions): Listener {\n    return createListener(this.components, {\n      ...options,\n      certificates: this.config.certificates,\n      maxInboundStreams: this.config.maxInboundStreams\n    })\n  }\n\n  /**\n   * Filter check for all Multiaddrs that this transport can listen on\n   */\n  listenFilter (): Multiaddr[] {\n    return []\n  }\n\n  /**\n   * Filter check for all Multiaddrs that this transport can dial\n   */\n  dialFilter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    // test for WebTransport support\n    if (globalThis.WebTransport == null) {\n      return []\n    }\n\n    return multiaddrs.filter(ma => {\n      if (!WebTransportMatcher.exactMatch(ma)) {\n        return false\n      }\n\n      const { url, certhashes } = parseMultiaddr(ma)\n\n      return url != null && certhashes.length > 0\n    })\n  }\n}\n\nexport function webTransport (init: WebTransportInit = {}): (components: WebTransportComponents) => Transport {\n  return (components: WebTransportComponents) => new WebTransportTransport(components, init)\n}\n"],
  "mappings": "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",
  "names": ["_a", "err", "_a", "_b", "_c"]
}
