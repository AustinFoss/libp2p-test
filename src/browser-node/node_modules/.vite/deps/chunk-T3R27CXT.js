import {
  byteStream
} from "./chunk-BFPWPRED.js";
import {
  Uint8ArrayList
} from "./chunk-BYS5BAPP.js";
import {
  decode2 as decode,
  encode,
  encodingLength
} from "./chunk-AV7VJIQH.js";
import {
  __publicField
} from "./chunk-WOOG5QLI.js";

// node_modules/.pnpm/it-length-prefixed-stream@2.0.1/node_modules/it-length-prefixed-stream/dist/src/errors.js
var InvalidMessageLengthError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidMessageLengthError");
    __publicField(this, "code", "ERR_INVALID_MSG_LENGTH");
  }
};
var InvalidDataLengthError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthError");
    __publicField(this, "code", "ERR_MSG_DATA_TOO_LONG");
  }
};
var InvalidDataLengthLengthError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthLengthError");
    __publicField(this, "code", "ERR_MSG_LENGTH_TOO_LONG");
  }
};

// node_modules/.pnpm/it-length-prefixed-stream@2.0.1/node_modules/it-length-prefixed-stream/dist/src/index.js
function lpStream(duplex, opts = {}) {
  const bytes = byteStream(duplex, opts);
  if (opts.maxDataLength != null && opts.maxLengthLength == null) {
    opts.maxLengthLength = encodingLength(opts.maxDataLength);
  }
  const decodeLength = (opts == null ? void 0 : opts.lengthDecoder) ?? decode;
  const encodeLength = (opts == null ? void 0 : opts.lengthEncoder) ?? encode;
  const W = {
    read: async (options) => {
      let dataLength = -1;
      const lengthBuffer = new Uint8ArrayList();
      while (true) {
        lengthBuffer.append(await bytes.read({
          ...options,
          bytes: 1
        }));
        try {
          dataLength = decodeLength(lengthBuffer);
        } catch (err) {
          if (err instanceof RangeError) {
            continue;
          }
          throw err;
        }
        if (dataLength < 0) {
          throw new InvalidMessageLengthError("Invalid message length");
        }
        if ((opts == null ? void 0 : opts.maxLengthLength) != null && lengthBuffer.byteLength > opts.maxLengthLength) {
          throw new InvalidDataLengthLengthError("message length length too long");
        }
        if (dataLength > -1) {
          break;
        }
      }
      if ((opts == null ? void 0 : opts.maxDataLength) != null && dataLength > opts.maxDataLength) {
        throw new InvalidDataLengthError("message length too long");
      }
      return bytes.read({
        ...options,
        bytes: dataLength
      });
    },
    write: async (data, options) => {
      await bytes.write(new Uint8ArrayList(encodeLength(data.byteLength), data), options);
    },
    writeV: async (data, options) => {
      const list = new Uint8ArrayList(...data.flatMap((buf) => [encodeLength(buf.byteLength), buf]));
      await bytes.write(list, options);
    },
    unwrap: () => {
      return bytes.unwrap();
    }
  };
  return W;
}

// node_modules/.pnpm/it-protobuf-stream@2.0.1/node_modules/it-protobuf-stream/dist/src/index.js
function pbStream(duplex, opts) {
  const lp = lpStream(duplex, opts);
  const W = {
    read: async (proto, options) => {
      const value = await lp.read(options);
      return proto.decode(value);
    },
    write: async (message, proto, options) => {
      await lp.write(proto.encode(message), options);
    },
    writeV: async (messages, proto, options) => {
      await lp.writeV(messages.map((message) => proto.encode(message)), options);
    },
    pb: (proto) => {
      return {
        read: async (options) => W.read(proto, options),
        write: async (d, options) => W.write(d, proto, options),
        writeV: async (d, options) => W.writeV(d, proto, options),
        unwrap: () => W
      };
    },
    unwrap: () => {
      return lp.unwrap();
    }
  };
  return W;
}

export {
  pbStream
};
//# sourceMappingURL=chunk-T3R27CXT.js.map
