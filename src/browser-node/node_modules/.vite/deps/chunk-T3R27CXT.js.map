{
  "version": 3,
  "sources": ["../../.pnpm/it-length-prefixed-stream@2.0.1/node_modules/it-length-prefixed-stream/src/errors.ts", "../../.pnpm/it-length-prefixed-stream@2.0.1/node_modules/it-length-prefixed-stream/src/index.ts", "../../.pnpm/it-protobuf-stream@2.0.1/node_modules/it-protobuf-stream/src/index.ts"],
  "sourcesContent": ["/**\n * The reported length of the next data message was not a positive integer\n */\nexport class InvalidMessageLengthError extends Error {\n  name = 'InvalidMessageLengthError'\n  code = 'ERR_INVALID_MSG_LENGTH'\n}\n\n/**\n * The reported length of the next data message was larger than the configured\n * max allowable value\n */\nexport class InvalidDataLengthError extends Error {\n  name = 'InvalidDataLengthError'\n  code = 'ERR_MSG_DATA_TOO_LONG'\n}\n\n/**\n * The varint used to specify the length of the next data message contained more\n * bytes than the configured max allowable value\n */\nexport class InvalidDataLengthLengthError extends Error {\n  name = 'InvalidDataLengthLengthError'\n  code = 'ERR_MSG_LENGTH_TOO_LONG'\n}\n", "/**\n * @packageDocumentation\n *\n * This module makes it easy to send and receive length-prefixed byte arrays over streams.\n *\n * @example\n *\n * ```typescript\n * import { lpStream } from 'it-length-prefixed-stream'\n *\n * const stream = lpStream(duplex)\n *\n * // read the next length-prefixed chunk\n * const bytes = await stream.read()\n *\n * // write a length-prefixed chunk\n * await stream.write(Uint8Array.from([0, 1, 2, 3, 4]))\n *\n * // write several chunks, all individually length-prefixed\n * await stream.writeV([\n *   Uint8Array.from([0, 1, 2, 3, 4]),\n *   Uint8Array.from([5, 6, 7, 8, 9])\n * ])\n * ```\n */\nimport { byteStream, type ByteStreamOpts } from 'it-byte-stream'\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { InvalidDataLengthError, InvalidDataLengthLengthError, InvalidMessageLengthError } from './errors.js'\nimport type { AbortOptions } from 'abort-error'\nimport type { Duplex } from 'it-stream-types'\n\nexport interface LengthPrefixedStream <Stream = unknown> {\n  /**\n   * Read the next length-prefixed number of bytes from the stream\n   */\n  read(options?: AbortOptions): Promise<Uint8ArrayList>\n\n  /**\n   * Write the passed bytes to the stream prefixed by their length\n   */\n  write(input: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<void>\n\n  /**\n   * Write passed list of bytes, prefix by their individual lengths to the stream as a single write\n   */\n  writeV(input: Array<Uint8Array | Uint8ArrayList>, options?: AbortOptions): Promise<void>\n\n  /**\n   * Returns the underlying stream\n   */\n  unwrap(): Stream\n}\n\nexport interface LengthPrefixedStreamOpts extends ByteStreamOpts {\n  // encoding opts\n  lengthEncoder (value: number): Uint8ArrayList | Uint8Array\n\n  // decoding opts\n  lengthDecoder (data: Uint8ArrayList): number\n  maxLengthLength: number\n  maxDataLength: number\n}\n\nexport function lpStream <Stream extends Duplex<any, any, any>> (duplex: Stream, opts: Partial<LengthPrefixedStreamOpts> = {}): LengthPrefixedStream<Stream> {\n  const bytes = byteStream(duplex, opts)\n\n  if (opts.maxDataLength != null && opts.maxLengthLength == null) {\n    // if max data length is set but max length length is not, calculate the\n    // max length length needed to encode max data length\n    opts.maxLengthLength = varint.encodingLength(opts.maxDataLength)\n  }\n\n  const decodeLength = opts?.lengthDecoder ?? varint.decode\n  const encodeLength = opts?.lengthEncoder ?? varint.encode\n\n  const W: LengthPrefixedStream<Stream> = {\n    read: async (options?: AbortOptions) => {\n      let dataLength: number = -1\n      const lengthBuffer = new Uint8ArrayList()\n\n      while (true) {\n        // read one byte at a time until we can decode a varint\n        lengthBuffer.append(await bytes.read({\n          ...options,\n          bytes: 1\n        }))\n\n        try {\n          dataLength = decodeLength(lengthBuffer)\n        } catch (err) {\n          if (err instanceof RangeError) {\n            continue\n          }\n\n          throw err\n        }\n\n        if (dataLength < 0) {\n          throw new InvalidMessageLengthError('Invalid message length')\n        }\n\n        if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {\n          throw new InvalidDataLengthLengthError('message length length too long')\n        }\n\n        if (dataLength > -1) {\n          break\n        }\n      }\n\n      if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {\n        throw new InvalidDataLengthError('message length too long')\n      }\n\n      return bytes.read({\n        ...options,\n        bytes: dataLength\n      })\n    },\n    write: async (data, options?: AbortOptions) => {\n      // encode, write\n      await bytes.write(new Uint8ArrayList(encodeLength(data.byteLength), data), options)\n    },\n    writeV: async (data, options?: AbortOptions) => {\n      const list = new Uint8ArrayList(\n        ...data.flatMap(buf => ([encodeLength(buf.byteLength), buf]))\n      )\n\n      // encode, write\n      await bytes.write(list, options)\n    },\n    unwrap: () => {\n      return bytes.unwrap()\n    }\n  }\n\n  return W\n}\n", "/**\n * @packageDocumentation\n *\n * This module makes it easy to send and receive length-prefixed Protobuf encoded\n * messages over streams.\n *\n * @example\n *\n * ```typescript\n * import { pbStream } from 'it-protobuf-stream'\n * import { MessageType } from './src/my-message-type.js'\n *\n * // RequestType and ResponseType have been generate from `.proto` files and have\n * // `.encode` and `.decode` methods for serialization/deserialization\n *\n * const stream = pbStream(duplex)\n *\n * // write a message to the stream\n * stream.write({\n *   foo: 'bar'\n * }, MessageType)\n *\n * // read a message from the stream\n * const res = await stream.read(MessageType)\n * ```\n */\n\nimport { lpStream } from 'it-length-prefixed-stream'\nimport type { AbortOptions } from 'abort-error'\nimport type { LengthPrefixedStreamOpts } from 'it-length-prefixed-stream'\nimport type { Duplex } from 'it-stream-types'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\n/**\n * A protobuf decoder - takes a byte array and returns an object\n */\nexport interface Decoder<T> {\n  (data: Uint8Array | Uint8ArrayList): T\n}\n\n/**\n * A protobuf encoder - takes an object and returns a byte array\n */\nexport interface Encoder<T> {\n  (data: T): Uint8Array\n}\n\n/**\n * Convenience methods for working with protobuf streams\n */\nexport interface ProtobufStream <Stream = unknown> {\n  /**\n   * Read the next length-prefixed byte array from the stream and decode it as the passed protobuf format\n   */\n  read<T>(proto: { decode: Decoder<T> }, options?: AbortOptions): Promise<T>\n\n  /**\n   * Encode the passed object as a protobuf message and write it's length-prefixed bytes to the stream\n   */\n  write<T>(data: T, proto: { encode: Encoder<T> }, options?: AbortOptions): Promise<void>\n\n  /**\n   * Encode the passed objects as protobuf messages and write their length-prefixed bytes to the stream as a single write\n   */\n  writeV<T>(input: T[], proto: { encode: Encoder<T> }, options?: AbortOptions): Promise<void>\n\n  /**\n   * Returns an object with read/write methods for operating on one specific type of protobuf message\n   */\n  pb<T>(proto: { encode: Encoder<T>, decode: Decoder<T> }): MessageStream<T, Stream>\n\n  /**\n   * Returns the underlying stream\n   */\n  unwrap(): Stream\n}\n\n/**\n * A message reader/writer that only uses one type of message\n */\nexport interface MessageStream <T, S = unknown> {\n  /**\n   * Read a message from the stream\n   */\n  read(options?: AbortOptions): Promise<T>\n\n  /**\n   * Write a message to the stream\n   */\n  write(d: T, options?: AbortOptions): Promise<void>\n\n  /**\n   * Write several messages to the stream\n   */\n  writeV(d: T[], options?: AbortOptions): Promise<void>\n\n  /**\n   * Unwrap the underlying protobuf stream\n   */\n  unwrap(): ProtobufStream<S>\n}\n\nexport interface ProtobufStreamOpts extends LengthPrefixedStreamOpts {\n\n}\n\nexport function pbStream <Stream extends Duplex<any, any, any>> (duplex: Stream, opts?: Partial<ProtobufStreamOpts>): ProtobufStream<Stream> {\n  const lp = lpStream(duplex, opts)\n\n  const W: ProtobufStream<Stream> = {\n    read: async (proto, options?: AbortOptions) => {\n      // readLP, decode\n      const value = await lp.read(options)\n\n      return proto.decode(value)\n    },\n    write: async (message, proto, options?: AbortOptions) => {\n      // encode, writeLP\n      await lp.write(proto.encode(message), options)\n    },\n    writeV: async (messages, proto, options?: AbortOptions) => {\n      // encode, writeLP\n      await lp.writeV(messages.map(message => proto.encode(message)), options)\n    },\n    pb: (proto) => {\n      return {\n        read: async (options) => W.read(proto, options),\n        write: async (d, options) => W.write(d, proto, options),\n        writeV: async (d, options) => W.writeV(d, proto, options),\n        unwrap: () => W\n      }\n    },\n    unwrap: () => {\n      return lp.unwrap()\n    }\n  }\n\n  return W\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;AAGM,IAAO,4BAAP,cAAyC,MAAK;EAA9C;;AACJ,gCAAO;AACP,gCAAO;;;AAOH,IAAO,yBAAP,cAAsC,MAAK;EAA3C;;AACJ,gCAAO;AACP,gCAAO;;;AAOH,IAAO,+BAAP,cAA4C,MAAK;EAAjD;;AACJ,gCAAO;AACP,gCAAO;;;;;ACyCH,SAAU,SAAiD,QAAgB,OAA0C,CAAA,GAAE;AAC3H,QAAM,QAAQ,WAAW,QAAQ,IAAI;AAErC,MAAI,KAAK,iBAAiB,QAAQ,KAAK,mBAAmB,MAAM;AAG9D,SAAK,kBAAyB,eAAe,KAAK,aAAa;EACjE;AAEA,QAAM,gBAAe,6BAAM,kBAAwB;AACnD,QAAM,gBAAe,6BAAM,kBAAwB;AAEnD,QAAM,IAAkC;IACtC,MAAM,OAAO,YAA0B;AACrC,UAAI,aAAqB;AACzB,YAAM,eAAe,IAAI,eAAc;AAEvC,aAAO,MAAM;AAEX,qBAAa,OAAO,MAAM,MAAM,KAAK;UACnC,GAAG;UACH,OAAO;SACR,CAAC;AAEF,YAAI;AACF,uBAAa,aAAa,YAAY;QACxC,SAAS,KAAK;AACZ,cAAI,eAAe,YAAY;AAC7B;UACF;AAEA,gBAAM;QACR;AAEA,YAAI,aAAa,GAAG;AAClB,gBAAM,IAAI,0BAA0B,wBAAwB;QAC9D;AAEA,aAAI,6BAAM,oBAAmB,QAAQ,aAAa,aAAa,KAAK,iBAAiB;AACnF,gBAAM,IAAI,6BAA6B,gCAAgC;QACzE;AAEA,YAAI,aAAa,IAAI;AACnB;QACF;MACF;AAEA,WAAI,6BAAM,kBAAiB,QAAQ,aAAa,KAAK,eAAe;AAClE,cAAM,IAAI,uBAAuB,yBAAyB;MAC5D;AAEA,aAAO,MAAM,KAAK;QAChB,GAAG;QACH,OAAO;OACR;IACH;IACA,OAAO,OAAO,MAAM,YAA0B;AAE5C,YAAM,MAAM,MAAM,IAAI,eAAe,aAAa,KAAK,UAAU,GAAG,IAAI,GAAG,OAAO;IACpF;IACA,QAAQ,OAAO,MAAM,YAA0B;AAC7C,YAAM,OAAO,IAAI,eACf,GAAG,KAAK,QAAQ,SAAQ,CAAC,aAAa,IAAI,UAAU,GAAG,GAAG,CAAE,CAAC;AAI/D,YAAM,MAAM,MAAM,MAAM,OAAO;IACjC;IACA,QAAQ,MAAK;AACX,aAAO,MAAM,OAAM;IACrB;;AAGF,SAAO;AACT;;;AChCM,SAAU,SAAiD,QAAgB,MAAkC;AACjH,QAAM,KAAK,SAAS,QAAQ,IAAI;AAEhC,QAAM,IAA4B;IAChC,MAAM,OAAO,OAAO,YAA0B;AAE5C,YAAM,QAAQ,MAAM,GAAG,KAAK,OAAO;AAEnC,aAAO,MAAM,OAAO,KAAK;IAC3B;IACA,OAAO,OAAO,SAAS,OAAO,YAA0B;AAEtD,YAAM,GAAG,MAAM,MAAM,OAAO,OAAO,GAAG,OAAO;IAC/C;IACA,QAAQ,OAAO,UAAU,OAAO,YAA0B;AAExD,YAAM,GAAG,OAAO,SAAS,IAAI,aAAW,MAAM,OAAO,OAAO,CAAC,GAAG,OAAO;IACzE;IACA,IAAI,CAAC,UAAS;AACZ,aAAO;QACL,MAAM,OAAO,YAAY,EAAE,KAAK,OAAO,OAAO;QAC9C,OAAO,OAAO,GAAG,YAAY,EAAE,MAAM,GAAG,OAAO,OAAO;QACtD,QAAQ,OAAO,GAAG,YAAY,EAAE,OAAO,GAAG,OAAO,OAAO;QACxD,QAAQ,MAAM;;IAElB;IACA,QAAQ,MAAK;AACX,aAAO,GAAG,OAAM;IAClB;;AAGF,SAAO;AACT;",
  "names": []
}
