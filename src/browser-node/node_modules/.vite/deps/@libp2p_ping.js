import "./chunk-E7S26PXL.js";
import {
  ProtocolError,
  TimeoutError,
  byteStream,
  randomBytes,
  serviceCapabilities,
  setMaxListeners
} from "./chunk-RIK5ZR2K.js";
import "./chunk-GN2SHL2J.js";
import "./chunk-FILK5HTN.js";
import "./chunk-EZM3SP6L.js";
import {
  equals
} from "./chunk-PM7HCL6E.js";
import {
  __publicField
} from "./chunk-WOOG5QLI.js";

// node_modules/.pnpm/@libp2p+ping@2.0.28/node_modules/@libp2p/ping/dist/src/constants.js
var PING_PROTOCOL = "/ipfs/ping/1.0.0";
var PING_LENGTH = 32;
var PROTOCOL_VERSION = "1.0.0";
var PROTOCOL_NAME = "ping";
var PROTOCOL_PREFIX = "ipfs";
var TIMEOUT = 1e4;
var MAX_INBOUND_STREAMS = 2;
var MAX_OUTBOUND_STREAMS = 1;

// node_modules/.pnpm/@libp2p+ping@2.0.28/node_modules/@libp2p/ping/dist/src/ping.js
var _a, _b;
_b = Symbol.toStringTag, _a = serviceCapabilities;
var Ping = class {
  constructor(components, init = {}) {
    __publicField(this, "protocol");
    __publicField(this, "components");
    __publicField(this, "started");
    __publicField(this, "timeout");
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    __publicField(this, "runOnLimitedConnection");
    __publicField(this, "log");
    __publicField(this, _b, "@libp2p/ping");
    __publicField(this, _a, [
      "@libp2p/ping"
    ]);
    this.components = components;
    this.log = components.logger.forComponent("libp2p:ping");
    this.started = false;
    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
    this.timeout = init.timeout ?? TIMEOUT;
    this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS;
    this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS;
    this.runOnLimitedConnection = init.runOnLimitedConnection ?? true;
    this.handleMessage = this.handleMessage.bind(this);
  }
  async start() {
    await this.components.registrar.handle(this.protocol, this.handleMessage, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnLimitedConnection: this.runOnLimitedConnection
    });
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  /**
   * A handler to register with Libp2p to process ping messages
   */
  handleMessage(data) {
    this.log("incoming ping from %p", data.connection.remotePeer);
    const { stream } = data;
    const start = Date.now();
    const bytes = byteStream(stream);
    let pinged = false;
    Promise.resolve().then(async () => {
      while (true) {
        const signal = AbortSignal.timeout(this.timeout);
        setMaxListeners(Infinity, signal);
        signal.addEventListener("abort", () => {
          stream == null ? void 0 : stream.abort(new TimeoutError("ping timeout"));
        });
        const buf = await bytes.read({
          bytes: PING_LENGTH,
          signal
        });
        await bytes.write(buf, {
          signal
        });
        pinged = true;
      }
    }).catch((err) => {
      if (pinged && err.name === "UnexpectedEOFError" && stream.readStatus !== "ready") {
        return;
      }
      this.log.error("incoming ping from %p failed with error - %e", data.connection.remotePeer, err);
      stream == null ? void 0 : stream.abort(err);
    }).finally(() => {
      const ms = Date.now() - start;
      this.log("incoming ping from %p complete in %dms", data.connection.remotePeer, ms);
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners(Infinity, signal);
      stream.close({
        signal
      }).catch((err) => {
        this.log.error("error closing ping stream from %p - %e", data.connection.remotePeer, err);
        stream == null ? void 0 : stream.abort(err);
      });
    });
  }
  /**
   * Ping a given peer and wait for its response, getting the operation latency.
   */
  async ping(peer, options = {}) {
    this.log("pinging %p", peer);
    const start = Date.now();
    const data = randomBytes(PING_LENGTH);
    const connection = await this.components.connectionManager.openConnection(peer, options);
    let stream;
    if (options.signal == null) {
      const signal = AbortSignal.timeout(this.timeout);
      options = {
        ...options,
        signal
      };
    }
    try {
      stream = await connection.newStream(this.protocol, {
        ...options,
        runOnLimitedConnection: this.runOnLimitedConnection
      });
      const bytes = byteStream(stream);
      const [, result] = await Promise.all([
        bytes.write(data, options),
        bytes.read({
          ...options,
          bytes: PING_LENGTH
        })
      ]);
      const ms = Date.now() - start;
      if (!equals(data, result.subarray())) {
        throw new ProtocolError(`Received wrong ping ack after ${ms}ms`);
      }
      this.log("ping %p complete in %dms", connection.remotePeer, ms);
      return ms;
    } catch (err) {
      this.log.error("error while pinging %p", connection.remotePeer, err);
      stream == null ? void 0 : stream.abort(err);
      throw err;
    } finally {
      if (stream != null) {
        await stream.close(options);
      }
    }
  }
};

// node_modules/.pnpm/@libp2p+ping@2.0.28/node_modules/@libp2p/ping/dist/src/index.js
function ping(init = {}) {
  return (components) => new Ping(components, init);
}
export {
  PING_PROTOCOL,
  ping
};
//# sourceMappingURL=@libp2p_ping.js.map
