import {
  queuelessPushable
} from "./chunk-VLAMNGZA.js";
import {
  decodeMessage,
  ed25519,
  encodeMessage,
  enumeration,
  message,
  randomBytes,
  secp256k1,
  sha256 as sha2562
} from "./chunk-4WIHOBZE.js";
import {
  InvalidParametersError,
  InvalidPrivateKeyError,
  InvalidPublicKeyError,
  UnsupportedKeyTypeError
} from "./chunk-OB37O552.js";
import {
  pDefer,
  raceSignal
} from "./chunk-2B23ONA5.js";
import {
  Uint8ArrayList
} from "./chunk-BYS5BAPP.js";
import {
  CID,
  base58btc,
  create,
  decode2 as decode,
  encode,
  encodingLength,
  fromString,
  identity,
  sha256,
  toString
} from "./chunk-AV7VJIQH.js";
import {
  allocUnsafe,
  equals
} from "./chunk-PM7HCL6E.js";
import {
  __export,
  __publicField
} from "./chunk-WOOG5QLI.js";

// node_modules/.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/dist/src/keys/ed25519/index.browser.js
var PUBLIC_KEY_BYTE_LENGTH = 32;
var PRIVATE_KEY_BYTE_LENGTH = 64;
var KEYS_BYTE_LENGTH = 32;
function generateKey() {
  const privateKeyRaw = ed25519.utils.randomPrivateKey();
  const publicKey = ed25519.getPublicKey(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
function hashAndSign(privateKey, msg) {
  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);
  return ed25519.sign(msg instanceof Uint8Array ? msg : msg.subarray(), privateKeyRaw);
}
function hashAndVerify(publicKey, sig, msg) {
  return ed25519.verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey);
}
function concatKeys(privateKeyRaw, publicKey) {
  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);
  for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {
    privateKey[i] = privateKeyRaw[i];
    privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i];
  }
  return privateKey;
}

// node_modules/.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/dist/src/keys/ed25519/ed25519.js
var Ed25519PublicKey = class {
  constructor(key) {
    __publicField(this, "type", "Ed25519");
    __publicField(this, "raw");
    this.raw = ensureEd25519Key(key, PUBLIC_KEY_BYTE_LENGTH);
  }
  toMultihash() {
    return identity.digest(publicKeyToProtobuf(this));
  }
  toCID() {
    return CID.createV1(114, this.toMultihash());
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key.raw);
  }
  verify(data, sig) {
    return hashAndVerify(this.raw, sig, data);
  }
};
var Ed25519PrivateKey = class {
  // key       - 64 byte Uint8Array containing private key
  // publicKey - 32 byte Uint8Array containing public key
  constructor(key, publicKey) {
    __publicField(this, "type", "Ed25519");
    __publicField(this, "raw");
    __publicField(this, "publicKey");
    this.raw = ensureEd25519Key(key, PRIVATE_KEY_BYTE_LENGTH);
    this.publicKey = new Ed25519PublicKey(publicKey);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key.raw);
  }
  sign(message2) {
    return hashAndSign(this.raw, message2);
  }
};

// node_modules/.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/dist/src/keys/ed25519/utils.js
function unmarshalEd25519PublicKey(bytes) {
  bytes = ensureEd25519Key(bytes, PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PublicKey(bytes);
}
async function generateEd25519KeyPair() {
  const { privateKey, publicKey } = generateKey();
  return new Ed25519PrivateKey(privateKey, publicKey);
}
function ensureEd25519Key(key, length) {
  key = Uint8Array.from(key ?? []);
  if (key.length !== length) {
    throw new InvalidParametersError(`Key must be a Uint8Array of length ${length}, got ${key.length}`);
  }
  return key;
}

// node_modules/.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/dist/src/keys/keys.js
var KeyType;
(function(KeyType2) {
  KeyType2["RSA"] = "RSA";
  KeyType2["Ed25519"] = "Ed25519";
  KeyType2["secp256k1"] = "secp256k1";
})(KeyType || (KeyType = {}));
var __KeyTypeValues;
(function(__KeyTypeValues2) {
  __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
  __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
  __KeyTypeValues2[__KeyTypeValues2["secp256k1"] = 2] = "secp256k1";
})(__KeyTypeValues || (__KeyTypeValues = {}));
(function(KeyType2) {
  KeyType2.codec = () => {
    return enumeration(__KeyTypeValues);
  };
})(KeyType || (KeyType = {}));
var PublicKey;
(function(PublicKey2) {
  let _codec;
  PublicKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {};
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.Type = KeyType.codec().decode(reader);
              break;
            }
            case 2: {
              obj.Data = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PublicKey2.encode = (obj) => {
    return encodeMessage(obj, PublicKey2.codec());
  };
  PublicKey2.decode = (buf, opts) => {
    return decodeMessage(buf, PublicKey2.codec(), opts);
  };
})(PublicKey || (PublicKey = {}));
var PrivateKey;
(function(PrivateKey2) {
  let _codec;
  PrivateKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {};
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.Type = KeyType.codec().decode(reader);
              break;
            }
            case 2: {
              obj.Data = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PrivateKey2.encode = (obj) => {
    return encodeMessage(obj, PrivateKey2.codec());
  };
  PrivateKey2.decode = (buf, opts) => {
    return decodeMessage(buf, PrivateKey2.codec(), opts);
  };
})(PrivateKey || (PrivateKey = {}));

// node_modules/.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/dist/src/keys/rsa/utils.js
var utils_exports = {};
__export(utils_exports, {
  MAX_RSA_KEY_SIZE: () => MAX_RSA_KEY_SIZE,
  generateRSAKeyPair: () => generateRSAKeyPair,
  jwkToJWKKeyPair: () => jwkToJWKKeyPair,
  jwkToPkcs1: () => jwkToPkcs1,
  jwkToPkix: () => jwkToPkix,
  jwkToRSAPrivateKey: () => jwkToRSAPrivateKey,
  pkcs1ToJwk: () => pkcs1ToJwk,
  pkcs1ToRSAPrivateKey: () => pkcs1ToRSAPrivateKey,
  pkixToJwk: () => pkixToJwk,
  pkixToRSAPublicKey: () => pkixToRSAPublicKey
});

// node_modules/.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/dist/src/keys/rsa/der.js
var TAG_MASK = parseInt("11111", 2);
var LONG_LENGTH_MASK = parseInt("10000000", 2);
var LONG_LENGTH_BYTES_MASK = parseInt("01111111", 2);
var decoders = {
  2: readInteger,
  3: readBitString,
  5: readNull,
  6: readObjectIdentifier,
  16: readSequence,
  22: readSequence,
  48: readSequence
};
function decodeDer(buf, context = { offset: 0 }) {
  const tag = buf[context.offset] & TAG_MASK;
  context.offset++;
  if (decoders[tag] != null) {
    return decoders[tag](buf, context);
  }
  throw new Error("No decoder for tag " + tag);
}
function readLength(buf, context) {
  let length = 0;
  if ((buf[context.offset] & LONG_LENGTH_MASK) === LONG_LENGTH_MASK) {
    const count = buf[context.offset] & LONG_LENGTH_BYTES_MASK;
    let str = "0x";
    context.offset++;
    for (let i = 0; i < count; i++, context.offset++) {
      str += buf[context.offset].toString(16).padStart(2, "0");
    }
    length = parseInt(str, 16);
  } else {
    length = buf[context.offset];
    context.offset++;
  }
  return length;
}
function readSequence(buf, context) {
  readLength(buf, context);
  const entries = [];
  while (true) {
    if (context.offset >= buf.byteLength) {
      break;
    }
    const result = decodeDer(buf, context);
    if (result === null) {
      break;
    }
    entries.push(result);
  }
  return entries;
}
function readInteger(buf, context) {
  const length = readLength(buf, context);
  const start = context.offset;
  const end = context.offset + length;
  const vals = [];
  for (let i = start; i < end; i++) {
    if (i === start && buf[i] === 0) {
      continue;
    }
    vals.push(buf[i]);
  }
  context.offset += length;
  return Uint8Array.from(vals);
}
function readObjectIdentifier(buf, context) {
  const count = readLength(buf, context);
  context.offset += count;
  return ["oid-unimplemented"];
}
function readNull(buf, context) {
  context.offset++;
  return null;
}
function readBitString(buf, context) {
  const length = readLength(buf, context);
  const unusedBits = buf[context.offset];
  context.offset++;
  const bytes = buf.subarray(context.offset, context.offset + length);
  context.offset += length;
  if (unusedBits !== 0) {
    throw new Error("Unused bits in bit string is unimplemented");
  }
  return decodeDer(bytes, {
    offset: 0
  });
}
function encodeNumber(value) {
  let number = value.toString(16);
  if (number.length % 2 === 1) {
    number = "0" + number;
  }
  const array = new Uint8ArrayList();
  for (let i = 0; i < number.length; i += 2) {
    array.append(Uint8Array.from([parseInt(`${number[i]}${number[i + 1]}`, 16)]));
  }
  return array;
}
function encodeLength(bytes) {
  if (bytes.byteLength < 128) {
    return Uint8Array.from([bytes.byteLength]);
  }
  const length = encodeNumber(bytes.byteLength);
  return new Uint8ArrayList(Uint8Array.from([
    length.byteLength | LONG_LENGTH_MASK
  ]), length);
}
function encodeInteger(value) {
  const contents = new Uint8ArrayList();
  const mask = parseInt("10000000", 2);
  const positive = (value.subarray()[0] & mask) === mask;
  if (positive) {
    contents.append(Uint8Array.from([0]));
  }
  contents.append(value);
  return new Uint8ArrayList(Uint8Array.from([2]), encodeLength(contents), contents);
}
function encodeBitString(value) {
  const unusedBits = Uint8Array.from([0]);
  const contents = new Uint8ArrayList(unusedBits, value);
  return new Uint8ArrayList(Uint8Array.from([3]), encodeLength(contents), contents);
}
function encodeSequence(values) {
  const output = new Uint8ArrayList();
  for (const buf of values) {
    output.append(buf);
  }
  return new Uint8ArrayList(Uint8Array.from([48]), encodeLength(output), output);
}

// node_modules/.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/dist/src/random-bytes.js
function randomBytes2(length) {
  if (isNaN(length) || length <= 0) {
    throw new InvalidParametersError("random bytes length must be a Number bigger than 0");
  }
  return randomBytes(length);
}

// node_modules/.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/dist/src/errors.js
var SigningError = class extends Error {
  constructor(message2 = "An error occurred while signing a message") {
    super(message2);
    this.name = "SigningError";
  }
};
var VerificationError = class extends Error {
  constructor(message2 = "An error occurred while verifying a message") {
    super(message2);
    this.name = "VerificationError";
  }
};
var WebCryptoMissingError = class extends Error {
  constructor(message2 = "Missing Web Crypto API") {
    super(message2);
    this.name = "WebCryptoMissingError";
  }
};

// node_modules/.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/dist/src/webcrypto/webcrypto.browser.js
var webcrypto_browser_default = {
  get(win = globalThis) {
    const nativeCrypto = win.crypto;
    if ((nativeCrypto == null ? void 0 : nativeCrypto.subtle) == null) {
      throw new WebCryptoMissingError("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");
    }
    return nativeCrypto;
  }
};

// node_modules/.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/dist/src/webcrypto/index.js
var webcrypto_default = webcrypto_browser_default;

// node_modules/.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/dist/src/keys/rsa/index.browser.js
async function generateRSAKey(bits) {
  const pair = await webcrypto_default.get().subtle.generateKey({
    name: "RSASSA-PKCS1-v1_5",
    modulusLength: bits,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash: { name: "SHA-256" }
  }, true, ["sign", "verify"]);
  const keys = await exportKey(pair);
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
async function hashAndSign2(key, msg) {
  const privateKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["sign"]);
  const sig = await webcrypto_default.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, msg instanceof Uint8Array ? msg : msg.subarray());
  return new Uint8Array(sig, 0, sig.byteLength);
}
async function hashAndVerify2(key, sig, msg) {
  const publicKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["verify"]);
  return webcrypto_default.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg instanceof Uint8Array ? msg : msg.subarray());
}
async function exportKey(pair) {
  if (pair.privateKey == null || pair.publicKey == null) {
    throw new InvalidParametersError("Private and public key are required");
  }
  return Promise.all([
    webcrypto_default.get().subtle.exportKey("jwk", pair.privateKey),
    webcrypto_default.get().subtle.exportKey("jwk", pair.publicKey)
  ]);
}
function rsaKeySize(jwk) {
  if (jwk.kty !== "RSA") {
    throw new InvalidParametersError("invalid key type");
  } else if (jwk.n == null) {
    throw new InvalidParametersError("invalid key modulus");
  }
  const bytes = fromString(jwk.n, "base64url");
  return bytes.length * 8;
}

// node_modules/.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/dist/src/keys/rsa/rsa.js
var RSAPublicKey = class {
  constructor(key, digest) {
    __publicField(this, "type", "RSA");
    __publicField(this, "_key");
    __publicField(this, "_raw");
    __publicField(this, "_multihash");
    this._key = key;
    this._multihash = digest;
  }
  get raw() {
    if (this._raw == null) {
      this._raw = utils_exports.jwkToPkix(this._key);
    }
    return this._raw;
  }
  toMultihash() {
    return this._multihash;
  }
  toCID() {
    return CID.createV1(114, this._multihash);
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key.raw);
  }
  verify(data, sig) {
    return hashAndVerify2(this._key, sig, data);
  }
};
var RSAPrivateKey = class {
  constructor(key, publicKey) {
    __publicField(this, "type", "RSA");
    __publicField(this, "_key");
    __publicField(this, "_raw");
    __publicField(this, "publicKey");
    this._key = key;
    this.publicKey = publicKey;
  }
  get raw() {
    if (this._raw == null) {
      this._raw = utils_exports.jwkToPkcs1(this._key);
    }
    return this._raw;
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key.raw);
  }
  sign(message2) {
    return hashAndSign2(this._key, message2);
  }
};

// node_modules/.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/dist/src/keys/rsa/utils.js
var MAX_RSA_KEY_SIZE = 8192;
var SHA2_256_CODE = 18;
var MAX_RSA_JWK_SIZE = 1062;
var RSA_ALGORITHM_IDENTIFIER = Uint8Array.from([
  48,
  13,
  6,
  9,
  42,
  134,
  72,
  134,
  247,
  13,
  1,
  1,
  1,
  5,
  0
]);
function pkcs1ToJwk(bytes) {
  const values = decodeDer(bytes);
  return {
    n: toString(values[1], "base64url"),
    e: toString(values[2], "base64url"),
    d: toString(values[3], "base64url"),
    p: toString(values[4], "base64url"),
    q: toString(values[5], "base64url"),
    dp: toString(values[6], "base64url"),
    dq: toString(values[7], "base64url"),
    qi: toString(values[8], "base64url"),
    kty: "RSA"
  };
}
function jwkToPkcs1(jwk) {
  if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
    throw new InvalidParametersError("JWK was missing components");
  }
  return encodeSequence([
    encodeInteger(Uint8Array.from([0])),
    encodeInteger(fromString(jwk.n, "base64url")),
    encodeInteger(fromString(jwk.e, "base64url")),
    encodeInteger(fromString(jwk.d, "base64url")),
    encodeInteger(fromString(jwk.p, "base64url")),
    encodeInteger(fromString(jwk.q, "base64url")),
    encodeInteger(fromString(jwk.dp, "base64url")),
    encodeInteger(fromString(jwk.dq, "base64url")),
    encodeInteger(fromString(jwk.qi, "base64url"))
  ]).subarray();
}
function pkixToJwk(bytes) {
  const decoded = decodeDer(bytes, {
    offset: 0
  });
  return {
    kty: "RSA",
    n: toString(decoded[1][0], "base64url"),
    e: toString(decoded[1][1], "base64url")
  };
}
function jwkToPkix(jwk) {
  if (jwk.n == null || jwk.e == null) {
    throw new InvalidParametersError("JWK was missing components");
  }
  const subjectPublicKeyInfo = encodeSequence([
    RSA_ALGORITHM_IDENTIFIER,
    encodeBitString(encodeSequence([
      encodeInteger(fromString(jwk.n, "base64url")),
      encodeInteger(fromString(jwk.e, "base64url"))
    ]))
  ]);
  return subjectPublicKeyInfo.subarray();
}
function pkcs1ToRSAPrivateKey(bytes) {
  const jwk = pkcs1ToJwk(bytes);
  return jwkToRSAPrivateKey(jwk);
}
function pkixToRSAPublicKey(bytes, digest) {
  if (bytes.byteLength >= MAX_RSA_JWK_SIZE) {
    throw new InvalidPublicKeyError("Key size is too large");
  }
  const jwk = pkixToJwk(bytes);
  if (digest == null) {
    const hash = sha2562(PublicKey.encode({
      Type: KeyType.RSA,
      Data: bytes
    }));
    digest = create(SHA2_256_CODE, hash);
  }
  return new RSAPublicKey(jwk, digest);
}
function jwkToRSAPrivateKey(jwk) {
  if (rsaKeySize(jwk) > MAX_RSA_KEY_SIZE) {
    throw new InvalidParametersError("Key size is too large");
  }
  const keys = jwkToJWKKeyPair(jwk);
  const hash = sha2562(PublicKey.encode({
    Type: KeyType.RSA,
    Data: jwkToPkix(keys.publicKey)
  }));
  const digest = create(SHA2_256_CODE, hash);
  return new RSAPrivateKey(keys.privateKey, new RSAPublicKey(keys.publicKey, digest));
}
async function generateRSAKeyPair(bits) {
  if (bits > MAX_RSA_KEY_SIZE) {
    throw new InvalidParametersError("Key size is too large");
  }
  const keys = await generateRSAKey(bits);
  const hash = sha2562(PublicKey.encode({
    Type: KeyType.RSA,
    Data: jwkToPkix(keys.publicKey)
  }));
  const digest = create(SHA2_256_CODE, hash);
  return new RSAPrivateKey(keys.privateKey, new RSAPublicKey(keys.publicKey, digest));
}
function jwkToJWKKeyPair(key) {
  if (key == null) {
    throw new InvalidParametersError("Missing key parameter");
  }
  return {
    privateKey: key,
    publicKey: {
      kty: key.kty,
      n: key.n,
      e: key.e
    }
  };
}

// node_modules/.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/dist/src/util.js
function isPromise(thing) {
  if (thing == null) {
    return false;
  }
  return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}

// node_modules/.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/dist/src/keys/secp256k1/index.browser.js
function hashAndSign3(key, msg) {
  const p = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray());
  if (isPromise(p)) {
    return p.then(({ digest }) => secp256k1.sign(digest, key).toDERRawBytes()).catch((err) => {
      throw new SigningError(String(err));
    });
  }
  try {
    return secp256k1.sign(p.digest, key).toDERRawBytes();
  } catch (err) {
    throw new SigningError(String(err));
  }
}
function hashAndVerify3(key, sig, msg) {
  const p = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray());
  if (isPromise(p)) {
    return p.then(({ digest }) => secp256k1.verify(sig, digest, key)).catch((err) => {
      throw new VerificationError(String(err));
    });
  }
  try {
    return secp256k1.verify(sig, p.digest, key);
  } catch (err) {
    throw new VerificationError(String(err));
  }
}

// node_modules/.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/dist/src/keys/secp256k1/secp256k1.js
var Secp256k1PublicKey = class {
  constructor(key) {
    __publicField(this, "type", "secp256k1");
    __publicField(this, "raw");
    __publicField(this, "_key");
    this._key = validateSecp256k1PublicKey(key);
    this.raw = compressSecp256k1PublicKey(this._key);
  }
  toMultihash() {
    return identity.digest(publicKeyToProtobuf(this));
  }
  toCID() {
    return CID.createV1(114, this.toMultihash());
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key.raw);
  }
  verify(data, sig) {
    return hashAndVerify3(this._key, sig, data);
  }
};
var Secp256k1PrivateKey = class {
  constructor(key, publicKey) {
    __publicField(this, "type", "secp256k1");
    __publicField(this, "raw");
    __publicField(this, "publicKey");
    this.raw = validateSecp256k1PrivateKey(key);
    this.publicKey = new Secp256k1PublicKey(publicKey ?? computeSecp256k1PublicKey(key));
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key.raw);
  }
  sign(message2) {
    return hashAndSign3(this.raw, message2);
  }
};

// node_modules/.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/dist/src/keys/secp256k1/utils.js
function unmarshalSecp256k1PublicKey(bytes) {
  return new Secp256k1PublicKey(bytes);
}
async function generateSecp256k1KeyPair() {
  const privateKeyBytes = generateSecp256k1PrivateKey();
  return new Secp256k1PrivateKey(privateKeyBytes);
}
function compressSecp256k1PublicKey(key) {
  const point = secp256k1.ProjectivePoint.fromHex(key).toRawBytes(true);
  return point;
}
function validateSecp256k1PrivateKey(key) {
  try {
    secp256k1.getPublicKey(key, true);
    return key;
  } catch (err) {
    throw new InvalidPrivateKeyError(String(err));
  }
}
function validateSecp256k1PublicKey(key) {
  try {
    secp256k1.ProjectivePoint.fromHex(key);
    return key;
  } catch (err) {
    throw new InvalidPublicKeyError(String(err));
  }
}
function computeSecp256k1PublicKey(privateKey) {
  try {
    return secp256k1.getPublicKey(privateKey, true);
  } catch (err) {
    throw new InvalidPrivateKeyError(String(err));
  }
}
function generateSecp256k1PrivateKey() {
  return secp256k1.utils.randomPrivateKey();
}

// node_modules/.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/dist/src/keys/ecdh/index.browser.js
var curveLengths = {
  "P-256": 32,
  "P-384": 48,
  "P-521": 66
};
var curveTypes = Object.keys(curveLengths);
var names = curveTypes.join(" / ");

// node_modules/.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/dist/src/keys/index.js
async function generateKeyPair(type, bits) {
  if (type === "Ed25519") {
    return generateEd25519KeyPair();
  }
  if (type === "secp256k1") {
    return generateSecp256k1KeyPair();
  }
  if (type === "RSA") {
    return generateRSAKeyPair(bits ?? 2048);
  }
  throw new UnsupportedKeyTypeError();
}
function publicKeyFromProtobuf(buf, digest) {
  const { Type, Data } = PublicKey.decode(buf);
  const data = Data ?? new Uint8Array();
  switch (Type) {
    case KeyType.RSA:
      return pkixToRSAPublicKey(data, digest);
    case KeyType.Ed25519:
      return unmarshalEd25519PublicKey(data);
    case KeyType.secp256k1:
      return unmarshalSecp256k1PublicKey(data);
    default:
      throw new UnsupportedKeyTypeError();
  }
}
function publicKeyToProtobuf(key) {
  return PublicKey.encode({
    Type: KeyType[key.type],
    Data: key.raw
  });
}

// node_modules/.pnpm/it-length-prefixed@10.0.1/node_modules/it-length-prefixed/dist/src/constants.js
var MAX_LENGTH_LENGTH = 8;
var MAX_DATA_LENGTH = 1024 * 1024 * 4;

// node_modules/.pnpm/it-length-prefixed@10.0.1/node_modules/it-length-prefixed/dist/src/errors.js
var InvalidMessageLengthError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidMessageLengthError");
    __publicField(this, "code", "ERR_INVALID_MSG_LENGTH");
  }
};
var InvalidDataLengthError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthError");
    __publicField(this, "code", "ERR_MSG_DATA_TOO_LONG");
  }
};
var InvalidDataLengthLengthError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthLengthError");
    __publicField(this, "code", "ERR_MSG_LENGTH_TOO_LONG");
  }
};
var UnexpectedEOFError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UnexpectedEOFError");
    __publicField(this, "code", "ERR_UNEXPECTED_EOF");
  }
};

// node_modules/.pnpm/it-length-prefixed@10.0.1/node_modules/it-length-prefixed/dist/src/utils.js
function isAsyncIterable(thing) {
  return thing[Symbol.asyncIterator] != null;
}

// node_modules/.pnpm/it-length-prefixed@10.0.1/node_modules/it-length-prefixed/dist/src/decode.js
var ReadMode;
(function(ReadMode2) {
  ReadMode2[ReadMode2["LENGTH"] = 0] = "LENGTH";
  ReadMode2[ReadMode2["DATA"] = 1] = "DATA";
})(ReadMode || (ReadMode = {}));
var defaultDecoder = (buf) => {
  const length = decode(buf);
  defaultDecoder.bytes = encodingLength(length);
  return length;
};
defaultDecoder.bytes = 0;
function decode2(source, options) {
  const buffer = new Uint8ArrayList();
  let mode = ReadMode.LENGTH;
  let dataLength = -1;
  const lengthDecoder = (options == null ? void 0 : options.lengthDecoder) ?? defaultDecoder;
  const maxLengthLength = (options == null ? void 0 : options.maxLengthLength) ?? MAX_LENGTH_LENGTH;
  const maxDataLength = (options == null ? void 0 : options.maxDataLength) ?? MAX_DATA_LENGTH;
  function* maybeYield() {
    while (buffer.byteLength > 0) {
      if (mode === ReadMode.LENGTH) {
        try {
          dataLength = lengthDecoder(buffer);
          if (dataLength < 0) {
            throw new InvalidMessageLengthError("Invalid message length");
          }
          if (dataLength > maxDataLength) {
            throw new InvalidDataLengthError("Message length too long");
          }
          const dataLengthLength = lengthDecoder.bytes;
          buffer.consume(dataLengthLength);
          if ((options == null ? void 0 : options.onLength) != null) {
            options.onLength(dataLength);
          }
          mode = ReadMode.DATA;
        } catch (err) {
          if (err instanceof RangeError) {
            if (buffer.byteLength > maxLengthLength) {
              throw new InvalidDataLengthLengthError("Message length length too long");
            }
            break;
          }
          throw err;
        }
      }
      if (mode === ReadMode.DATA) {
        if (buffer.byteLength < dataLength) {
          break;
        }
        const data = buffer.sublist(0, dataLength);
        buffer.consume(dataLength);
        if ((options == null ? void 0 : options.onData) != null) {
          options.onData(data);
        }
        yield data;
        mode = ReadMode.LENGTH;
      }
    }
  }
  if (isAsyncIterable(source)) {
    return async function* () {
      for await (const buf of source) {
        buffer.append(buf);
        yield* maybeYield();
      }
      if (buffer.byteLength > 0) {
        throw new UnexpectedEOFError("Unexpected end of input");
      }
    }();
  }
  return function* () {
    for (const buf of source) {
      buffer.append(buf);
      yield* maybeYield();
    }
    if (buffer.byteLength > 0) {
      throw new UnexpectedEOFError("Unexpected end of input");
    }
  }();
}
decode2.fromReader = (reader, options) => {
  let byteLength = 1;
  const varByteSource = async function* () {
    while (true) {
      try {
        const { done, value } = await reader.next(byteLength);
        if (done === true) {
          return;
        }
        if (value != null) {
          yield value;
        }
      } catch (err) {
        if (err.code === "ERR_UNDER_READ") {
          return { done: true, value: null };
        }
        throw err;
      } finally {
        byteLength = 1;
      }
    }
  }();
  const onLength = (l) => {
    byteLength = l;
  };
  return decode2(varByteSource, {
    ...options ?? {},
    onLength
  });
};

// node_modules/.pnpm/it-length-prefixed@10.0.1/node_modules/it-length-prefixed/dist/src/encode.js
function validateMaxDataLength(chunk, maxDataLength) {
  if (chunk.byteLength > maxDataLength) {
    throw new InvalidDataLengthError("Message length too long");
  }
}
var defaultEncoder = (length) => {
  const lengthLength = encodingLength(length);
  const lengthBuf = allocUnsafe(lengthLength);
  encode(length, lengthBuf);
  defaultEncoder.bytes = lengthLength;
  return lengthBuf;
};
defaultEncoder.bytes = 0;
function encode2(source, options) {
  options = options ?? {};
  const encodeLength2 = options.lengthEncoder ?? defaultEncoder;
  const maxDataLength = (options == null ? void 0 : options.maxDataLength) ?? MAX_DATA_LENGTH;
  function* maybeYield(chunk) {
    validateMaxDataLength(chunk, maxDataLength);
    const length = encodeLength2(chunk.byteLength);
    if (length instanceof Uint8Array) {
      yield length;
    } else {
      yield* length;
    }
    if (chunk instanceof Uint8Array) {
      yield chunk;
    } else {
      yield* chunk;
    }
  }
  if (isAsyncIterable(source)) {
    return async function* () {
      for await (const chunk of source) {
        yield* maybeYield(chunk);
      }
    }();
  }
  return function* () {
    for (const chunk of source) {
      yield* maybeYield(chunk);
    }
  }();
}
encode2.single = (chunk, options) => {
  options = options ?? {};
  const encodeLength2 = options.lengthEncoder ?? defaultEncoder;
  const maxDataLength = (options == null ? void 0 : options.maxDataLength) ?? MAX_DATA_LENGTH;
  validateMaxDataLength(chunk, maxDataLength);
  return new Uint8ArrayList(encodeLength2(chunk.byteLength), chunk);
};

// node_modules/.pnpm/it-queueless-pushable@1.0.2/node_modules/it-queueless-pushable/dist/src/index.js
var QueuelessPushable = class {
  constructor() {
    __publicField(this, "readNext");
    __publicField(this, "haveNext");
    __publicField(this, "ended");
    __publicField(this, "nextResult");
    this.ended = false;
    this.readNext = pDefer();
    this.haveNext = pDefer();
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async next() {
    if (this.nextResult == null) {
      await this.haveNext.promise;
    }
    if (this.nextResult == null) {
      throw new Error("HaveNext promise resolved but nextResult was undefined");
    }
    const nextResult = this.nextResult;
    this.nextResult = void 0;
    this.readNext.resolve();
    this.readNext = pDefer();
    return nextResult;
  }
  async throw(err) {
    this.ended = true;
    if (err != null) {
      this.haveNext.promise.catch(() => {
      });
      this.haveNext.reject(err);
    }
    const result = {
      done: true,
      value: void 0
    };
    return result;
  }
  async return() {
    const result = {
      done: true,
      value: void 0
    };
    this.ended = true;
    this.nextResult = result;
    this.haveNext.resolve();
    return result;
  }
  async push(value, options) {
    await this._push(value, options);
  }
  async end(err, options) {
    if (err != null) {
      await this.throw(err);
    } else {
      await this._push(void 0, options);
    }
  }
  async _push(value, options) {
    if (value != null && this.ended) {
      throw new Error("Cannot push value onto an ended pushable");
    }
    while (this.nextResult != null) {
      await this.readNext.promise;
    }
    if (value != null) {
      this.nextResult = { done: false, value };
    } else {
      this.ended = true;
      this.nextResult = { done: true, value: void 0 };
    }
    this.haveNext.resolve();
    this.haveNext = pDefer();
    await raceSignal(this.readNext.promise, options == null ? void 0 : options.signal, options);
  }
};
function queuelessPushable2() {
  return new QueuelessPushable();
}

// node_modules/.pnpm/it-byte-stream@1.1.1/node_modules/it-byte-stream/dist/src/errors.js
var UnexpectedEOFError2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UnexpectedEOFError");
    __publicField(this, "code", "ERR_UNEXPECTED_EOF");
  }
};

// node_modules/.pnpm/it-byte-stream@1.1.1/node_modules/it-byte-stream/dist/src/index.js
var CodeError = class extends Error {
  constructor(message2, code) {
    super(message2);
    __publicField(this, "code");
    this.code = code;
  }
};
var AbortError = class extends CodeError {
  constructor(message2) {
    super(message2, "ABORT_ERR");
    __publicField(this, "type");
    this.type = "aborted";
    this.name = "AbortError";
  }
};
function byteStream(duplex, opts) {
  const write = queuelessPushable2();
  duplex.sink(write).catch(async (err) => {
    await write.end(err);
  });
  duplex.sink = async (source2) => {
    for await (const buf of source2) {
      await write.push(buf);
    }
    await write.end();
  };
  let source = duplex.source;
  if (duplex.source[Symbol.iterator] != null) {
    source = duplex.source[Symbol.iterator]();
  } else if (duplex.source[Symbol.asyncIterator] != null) {
    source = duplex.source[Symbol.asyncIterator]();
  }
  const readBuffer = new Uint8ArrayList();
  const W = {
    read: async (bytes, options) => {
      var _a, _b;
      (_a = options == null ? void 0 : options.signal) == null ? void 0 : _a.throwIfAborted();
      let listener;
      const abortPromise = new Promise((resolve, reject) => {
        var _a2;
        listener = () => {
          reject(new AbortError("Read aborted"));
        };
        (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.addEventListener("abort", listener);
      });
      try {
        if (bytes == null) {
          const { done, value } = await Promise.race([
            source.next(),
            abortPromise
          ]);
          if (done === true) {
            return new Uint8ArrayList();
          }
          return value;
        }
        while (readBuffer.byteLength < bytes) {
          const { value, done } = await Promise.race([
            source.next(),
            abortPromise
          ]);
          if (done === true) {
            throw new UnexpectedEOFError2("unexpected end of input");
          }
          readBuffer.append(value);
        }
        const buf = readBuffer.sublist(0, bytes);
        readBuffer.consume(bytes);
        return buf;
      } finally {
        if (listener != null) {
          (_b = options == null ? void 0 : options.signal) == null ? void 0 : _b.removeEventListener("abort", listener);
        }
      }
    },
    write: async (data, options) => {
      var _a;
      (_a = options == null ? void 0 : options.signal) == null ? void 0 : _a.throwIfAborted();
      if (data instanceof Uint8Array) {
        await write.push(data, options);
      } else {
        await write.push(data.subarray(), options);
      }
    },
    unwrap: () => {
      if (readBuffer.byteLength > 0) {
        const originalStream = duplex.source;
        duplex.source = async function* () {
          if ((opts == null ? void 0 : opts.yieldBytes) === false) {
            yield readBuffer;
          } else {
            yield* readBuffer;
          }
          yield* originalStream;
        }();
      }
      return duplex;
    }
  };
  return W;
}

// node_modules/.pnpm/it-length-prefixed-stream@1.2.1/node_modules/it-length-prefixed-stream/dist/src/errors.js
var InvalidMessageLengthError2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidMessageLengthError");
    __publicField(this, "code", "ERR_INVALID_MSG_LENGTH");
  }
};
var InvalidDataLengthError2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthError");
    __publicField(this, "code", "ERR_MSG_DATA_TOO_LONG");
  }
};
var InvalidDataLengthLengthError2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthLengthError");
    __publicField(this, "code", "ERR_MSG_LENGTH_TOO_LONG");
  }
};

// node_modules/.pnpm/it-length-prefixed-stream@1.2.1/node_modules/it-length-prefixed-stream/dist/src/index.js
function lpStream(duplex, opts = {}) {
  const bytes = byteStream(duplex, opts);
  if (opts.maxDataLength != null && opts.maxLengthLength == null) {
    opts.maxLengthLength = encodingLength(opts.maxDataLength);
  }
  const decodeLength = (opts == null ? void 0 : opts.lengthDecoder) ?? decode;
  const encodeLength2 = (opts == null ? void 0 : opts.lengthEncoder) ?? encode;
  const W = {
    read: async (options) => {
      let dataLength = -1;
      const lengthBuffer = new Uint8ArrayList();
      while (true) {
        lengthBuffer.append(await bytes.read(1, options));
        try {
          dataLength = decodeLength(lengthBuffer);
        } catch (err) {
          if (err instanceof RangeError) {
            continue;
          }
          throw err;
        }
        if (dataLength < 0) {
          throw new InvalidMessageLengthError2("Invalid message length");
        }
        if ((opts == null ? void 0 : opts.maxLengthLength) != null && lengthBuffer.byteLength > opts.maxLengthLength) {
          throw new InvalidDataLengthLengthError2("message length length too long");
        }
        if (dataLength > -1) {
          break;
        }
      }
      if ((opts == null ? void 0 : opts.maxDataLength) != null && dataLength > opts.maxDataLength) {
        throw new InvalidDataLengthError2("message length too long");
      }
      return bytes.read(dataLength, options);
    },
    write: async (data, options) => {
      await bytes.write(new Uint8ArrayList(encodeLength2(data.byteLength), data), options);
    },
    writeV: async (data, options) => {
      const list = new Uint8ArrayList(...data.flatMap((buf) => [encodeLength2(buf.byteLength), buf]));
      await bytes.write(list, options);
    },
    unwrap: () => {
      return bytes.unwrap();
    }
  };
  return W;
}

// node_modules/.pnpm/it-merge@3.0.9/node_modules/it-merge/dist/src/index.js
function isAsyncIterable2(thing) {
  return thing[Symbol.asyncIterator] != null;
}
async function addAllToPushable(sources, output) {
  try {
    await Promise.all(sources.map(async (source) => {
      for await (const item of source) {
        await output.push(item);
      }
    }));
    await output.end();
  } catch (err) {
    await output.end(err).catch(() => {
    });
  }
}
async function* mergeSources(sources) {
  const output = queuelessPushable();
  addAllToPushable(sources, output).catch(() => {
  });
  yield* output;
}
function* mergeSyncSources(syncSources) {
  for (const source of syncSources) {
    yield* source;
  }
}
function merge(...sources) {
  const syncSources = [];
  for (const source of sources) {
    if (!isAsyncIterable2(source)) {
      syncSources.push(source);
    }
  }
  if (syncSources.length === sources.length) {
    return mergeSyncSources(syncSources);
  }
  return mergeSources(sources);
}
var src_default = merge;

export {
  randomBytes2 as randomBytes,
  generateKeyPair,
  publicKeyFromProtobuf,
  publicKeyToProtobuf,
  encode2 as encode,
  decode2 as decode,
  byteStream,
  lpStream,
  src_default
};
//# sourceMappingURL=chunk-73FYJK3H.js.map
