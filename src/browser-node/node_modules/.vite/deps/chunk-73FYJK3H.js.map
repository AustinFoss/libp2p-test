{
  "version": 3,
  "sources": ["../../.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/src/keys/ed25519/index.browser.ts", "../../.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/src/keys/ed25519/ed25519.ts", "../../.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/src/keys/ed25519/utils.ts", "../../.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/src/keys/keys.ts", "../../.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/src/keys/rsa/utils.ts", "../../.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/src/keys/rsa/der.ts", "../../.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/src/random-bytes.ts", "../../.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/src/errors.ts", "../../.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/src/webcrypto/webcrypto.browser.ts", "../../.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/src/webcrypto/index.ts", "../../.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/src/keys/rsa/index.browser.ts", "../../.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/src/keys/rsa/rsa.ts", "../../.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/src/util.ts", "../../.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/src/keys/secp256k1/index.browser.ts", "../../.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/src/keys/secp256k1/secp256k1.ts", "../../.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/src/keys/secp256k1/utils.ts", "../../.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/src/keys/ecdh/index.browser.ts", "../../.pnpm/@libp2p+crypto@5.0.15/node_modules/@libp2p/crypto/src/keys/index.ts", "../../.pnpm/it-length-prefixed@10.0.1/node_modules/it-length-prefixed/src/constants.ts", "../../.pnpm/it-length-prefixed@10.0.1/node_modules/it-length-prefixed/src/errors.ts", "../../.pnpm/it-length-prefixed@10.0.1/node_modules/it-length-prefixed/src/utils.ts", "../../.pnpm/it-length-prefixed@10.0.1/node_modules/it-length-prefixed/src/decode.ts", "../../.pnpm/it-length-prefixed@10.0.1/node_modules/it-length-prefixed/src/encode.ts", "../../.pnpm/it-queueless-pushable@1.0.2/node_modules/it-queueless-pushable/src/index.ts", "../../.pnpm/it-byte-stream@1.1.1/node_modules/it-byte-stream/src/errors.ts", "../../.pnpm/it-byte-stream@1.1.1/node_modules/it-byte-stream/src/index.ts", "../../.pnpm/it-length-prefixed-stream@1.2.1/node_modules/it-length-prefixed-stream/src/errors.ts", "../../.pnpm/it-length-prefixed-stream@1.2.1/node_modules/it-length-prefixed-stream/src/index.ts", "../../.pnpm/it-merge@3.0.9/node_modules/it-merge/src/index.ts"],
  "sourcesContent": ["import { ed25519 as ed } from '@noble/curves/ed25519'\nimport type { Uint8ArrayKeyPair } from '../interface.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst PUBLIC_KEY_BYTE_LENGTH = 32\nconst PRIVATE_KEY_BYTE_LENGTH = 64 // private key is actually 32 bytes but for historical reasons we concat private and public keys\nconst KEYS_BYTE_LENGTH = 32\n\nexport { PUBLIC_KEY_BYTE_LENGTH as publicKeyLength }\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength }\n\nexport function generateKey (): Uint8ArrayKeyPair {\n  // the actual private key (32 bytes)\n  const privateKeyRaw = ed.utils.randomPrivateKey()\n  const publicKey = ed.getPublicKey(privateKeyRaw)\n\n  // concatenated the public key to the private key\n  const privateKey = concatKeys(privateKeyRaw, publicKey)\n\n  return {\n    privateKey,\n    publicKey\n  }\n}\n\n/**\n * Generate keypair from a 32 byte uint8array\n */\nexport function generateKeyFromSeed (seed: Uint8Array): Uint8ArrayKeyPair {\n  if (seed.length !== KEYS_BYTE_LENGTH) {\n    throw new TypeError('\"seed\" must be 32 bytes in length.')\n  } else if (!(seed instanceof Uint8Array)) {\n    throw new TypeError('\"seed\" must be a node.js Buffer, or Uint8Array.')\n  }\n\n  // based on node forges algorithm, the seed is used directly as private key\n  const privateKeyRaw = seed\n  const publicKey = ed.getPublicKey(privateKeyRaw)\n\n  const privateKey = concatKeys(privateKeyRaw, publicKey)\n\n  return {\n    privateKey,\n    publicKey\n  }\n}\n\nexport function hashAndSign (privateKey: Uint8Array, msg: Uint8Array | Uint8ArrayList): Uint8Array {\n  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH)\n\n  return ed.sign(msg instanceof Uint8Array ? msg : msg.subarray(), privateKeyRaw)\n}\n\nexport function hashAndVerify (publicKey: Uint8Array, sig: Uint8Array, msg: Uint8Array | Uint8ArrayList): boolean {\n  return ed.verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey)\n}\n\nfunction concatKeys (privateKeyRaw: Uint8Array, publicKey: Uint8Array): Uint8Array {\n  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH)\n  for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {\n    privateKey[i] = privateKeyRaw[i]\n    privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i]\n  }\n  return privateKey\n}\n", "import { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { type Digest } from 'multiformats/hashes/digest'\nimport { identity } from 'multiformats/hashes/identity'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { publicKeyToProtobuf } from '../index.js'\nimport { ensureEd25519Key } from './utils.js'\nimport * as crypto from './index.js'\nimport type { Ed25519PublicKey as Ed25519PublicKeyInterface, Ed25519PrivateKey as Ed25519PrivateKeyInterface } from '@libp2p/interface'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport class Ed25519PublicKey implements Ed25519PublicKeyInterface {\n  public readonly type = 'Ed25519'\n  public readonly raw: Uint8Array\n\n  constructor (key: Uint8Array) {\n    this.raw = ensureEd25519Key(key, crypto.publicKeyLength)\n  }\n\n  toMultihash (): Digest<0x0, number> {\n    return identity.digest(publicKeyToProtobuf(this))\n  }\n\n  toCID (): CID<unknown, 114, 0x0, 1> {\n    return CID.createV1(114, this.toMultihash())\n  }\n\n  toString (): string {\n    return base58btc.encode(this.toMultihash().bytes).substring(1)\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  verify (data: Uint8Array | Uint8ArrayList, sig: Uint8Array): boolean {\n    return crypto.hashAndVerify(this.raw, sig, data)\n  }\n}\n\nexport class Ed25519PrivateKey implements Ed25519PrivateKeyInterface {\n  public readonly type = 'Ed25519'\n  public readonly raw: Uint8Array\n  public readonly publicKey: Ed25519PublicKey\n\n  // key       - 64 byte Uint8Array containing private key\n  // publicKey - 32 byte Uint8Array containing public key\n  constructor (key: Uint8Array, publicKey: Uint8Array) {\n    this.raw = ensureEd25519Key(key, crypto.privateKeyLength)\n    this.publicKey = new Ed25519PublicKey(publicKey)\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  sign (message: Uint8Array | Uint8ArrayList): Uint8Array {\n    return crypto.hashAndSign(this.raw, message)\n  }\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { Ed25519PublicKey as Ed25519PublicKeyClass, Ed25519PrivateKey as Ed25519PrivateKeyClass } from './ed25519.js'\nimport * as crypto from './index.js'\nimport type { Ed25519PublicKey, Ed25519PrivateKey } from '@libp2p/interface'\n\nexport function unmarshalEd25519PrivateKey (bytes: Uint8Array): Ed25519PrivateKey {\n  // Try the old, redundant public key version\n  if (bytes.length > crypto.privateKeyLength) {\n    bytes = ensureEd25519Key(bytes, crypto.privateKeyLength + crypto.publicKeyLength)\n    const privateKeyBytes = bytes.subarray(0, crypto.privateKeyLength)\n    const publicKeyBytes = bytes.subarray(crypto.privateKeyLength, bytes.length)\n    return new Ed25519PrivateKeyClass(privateKeyBytes, publicKeyBytes)\n  }\n\n  bytes = ensureEd25519Key(bytes, crypto.privateKeyLength)\n  const privateKeyBytes = bytes.subarray(0, crypto.privateKeyLength)\n  const publicKeyBytes = bytes.subarray(crypto.publicKeyLength)\n  return new Ed25519PrivateKeyClass(privateKeyBytes, publicKeyBytes)\n}\n\nexport function unmarshalEd25519PublicKey (bytes: Uint8Array): Ed25519PublicKey {\n  bytes = ensureEd25519Key(bytes, crypto.publicKeyLength)\n  return new Ed25519PublicKeyClass(bytes)\n}\n\nexport async function generateEd25519KeyPair (): Promise<Ed25519PrivateKey> {\n  const { privateKey, publicKey } = crypto.generateKey()\n  return new Ed25519PrivateKeyClass(privateKey, publicKey)\n}\n\nexport async function generateEd25519KeyPairFromSeed (seed: Uint8Array): Promise<Ed25519PrivateKey> {\n  const { privateKey, publicKey } = crypto.generateKeyFromSeed(seed)\n  return new Ed25519PrivateKeyClass(privateKey, publicKey)\n}\n\nexport function ensureEd25519Key (key: Uint8Array, length: number): Uint8Array {\n  key = Uint8Array.from(key ?? [])\n  if (key.length !== length) {\n    throw new InvalidParametersError(`Key must be a Uint8Array of length ${length}, got ${key.length}`)\n  }\n  return key\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { type Codec, decodeMessage, type DecodeOptions, encodeMessage, enumeration, message } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport enum KeyType {\n  RSA = 'RSA',\n  Ed25519 = 'Ed25519',\n  secp256k1 = 'secp256k1'\n}\n\nenum __KeyTypeValues {\n  RSA = 0,\n  Ed25519 = 1,\n  secp256k1 = 2\n}\n\nexport namespace KeyType {\n  export const codec = (): Codec<KeyType> => {\n    return enumeration<KeyType>(__KeyTypeValues)\n  }\n}\nexport interface PublicKey {\n  Type?: KeyType\n  Data?: Uint8Array\n}\n\nexport namespace PublicKey {\n  let _codec: Codec<PublicKey>\n\n  export const codec = (): Codec<PublicKey> => {\n    if (_codec == null) {\n      _codec = message<PublicKey>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8)\n          KeyType.codec().encode(obj.Type, w)\n        }\n\n        if (obj.Data != null) {\n          w.uint32(18)\n          w.bytes(obj.Data)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.Type = KeyType.codec().decode(reader)\n              break\n            }\n            case 2: {\n              obj.Data = reader.bytes()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PublicKey>): Uint8Array => {\n    return encodeMessage(obj, PublicKey.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<PublicKey>): PublicKey => {\n    return decodeMessage(buf, PublicKey.codec(), opts)\n  }\n}\n\nexport interface PrivateKey {\n  Type?: KeyType\n  Data?: Uint8Array\n}\n\nexport namespace PrivateKey {\n  let _codec: Codec<PrivateKey>\n\n  export const codec = (): Codec<PrivateKey> => {\n    if (_codec == null) {\n      _codec = message<PrivateKey>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8)\n          KeyType.codec().encode(obj.Type, w)\n        }\n\n        if (obj.Data != null) {\n          w.uint32(18)\n          w.bytes(obj.Data)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.Type = KeyType.codec().decode(reader)\n              break\n            }\n            case 2: {\n              obj.Data = reader.bytes()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PrivateKey>): Uint8Array => {\n    return encodeMessage(obj, PrivateKey.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<PrivateKey>): PrivateKey => {\n    return decodeMessage(buf, PrivateKey.codec(), opts)\n  }\n}\n", "import { InvalidParametersError, InvalidPublicKeyError } from '@libp2p/interface'\nimport { sha256 } from '@noble/hashes/sha256'\nimport { create } from 'multiformats/hashes/digest'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport * as pb from '../keys.js'\nimport { decodeDer, encodeBitString, encodeInteger, encodeSequence } from './der.js'\nimport { RSAPrivateKey as RSAPrivateKeyClass, RSAPublicKey as RSAPublicKeyClass } from './rsa.js'\nimport { generateRSAKey, rsaKeySize } from './index.js'\nimport type { JWKKeyPair } from '../interface.js'\nimport type { RSAPrivateKey, RSAPublicKey } from '@libp2p/interface'\nimport type { Digest } from 'multiformats/hashes/digest'\n\nexport const MAX_RSA_KEY_SIZE = 8192\nconst SHA2_256_CODE = 0x12\nconst MAX_RSA_JWK_SIZE = 1062\n\nconst RSA_ALGORITHM_IDENTIFIER = Uint8Array.from([\n  0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00\n])\n\n/**\n * Convert a PKCS#1 in ASN1 DER format to a JWK private key\n */\nexport function pkcs1ToJwk (bytes: Uint8Array): JsonWebKey {\n  const values = decodeDer(bytes)\n\n  return {\n    n: uint8ArrayToString(values[1], 'base64url'),\n    e: uint8ArrayToString(values[2], 'base64url'),\n    d: uint8ArrayToString(values[3], 'base64url'),\n    p: uint8ArrayToString(values[4], 'base64url'),\n    q: uint8ArrayToString(values[5], 'base64url'),\n    dp: uint8ArrayToString(values[6], 'base64url'),\n    dq: uint8ArrayToString(values[7], 'base64url'),\n    qi: uint8ArrayToString(values[8], 'base64url'),\n    kty: 'RSA'\n  }\n}\n\n/**\n * Convert a JWK private key into PKCS#1 in ASN1 DER format\n */\nexport function jwkToPkcs1 (jwk: JsonWebKey): Uint8Array {\n  if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {\n    throw new InvalidParametersError('JWK was missing components')\n  }\n\n  return encodeSequence([\n    encodeInteger(Uint8Array.from([0])),\n    encodeInteger(uint8ArrayFromString(jwk.n, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.e, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.d, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.p, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.q, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.dp, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.dq, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.qi, 'base64url'))\n  ]).subarray()\n}\n\n/**\n * Convert a PKIX in ASN1 DER format to a JWK public key\n */\nexport function pkixToJwk (bytes: Uint8Array): JsonWebKey {\n  const decoded = decodeDer(bytes, {\n    offset: 0\n  })\n\n  // this looks fragile but DER is a canonical format so we are safe to have\n  // deeply property chains like this\n  return {\n    kty: 'RSA',\n    n: uint8ArrayToString(\n      decoded[1][0],\n      'base64url'\n    ),\n    e: uint8ArrayToString(\n      decoded[1][1],\n      'base64url'\n    )\n  }\n}\n\n/**\n * Convert a JWK public key to PKIX in ASN1 DER format\n */\nexport function jwkToPkix (jwk: JsonWebKey): Uint8Array {\n  if (jwk.n == null || jwk.e == null) {\n    throw new InvalidParametersError('JWK was missing components')\n  }\n\n  const subjectPublicKeyInfo = encodeSequence([\n    RSA_ALGORITHM_IDENTIFIER,\n    encodeBitString(\n      encodeSequence([\n        encodeInteger(uint8ArrayFromString(jwk.n, 'base64url')),\n        encodeInteger(uint8ArrayFromString(jwk.e, 'base64url'))\n      ])\n    )\n  ])\n\n  return subjectPublicKeyInfo.subarray()\n}\n\n/**\n * Turn PKCS#1 DER bytes to a PrivateKey\n */\nexport function pkcs1ToRSAPrivateKey (bytes: Uint8Array): RSAPrivateKey {\n  const jwk = pkcs1ToJwk(bytes)\n\n  return jwkToRSAPrivateKey(jwk)\n}\n\n/**\n * Turn PKIX bytes to a PublicKey\n */\nexport function pkixToRSAPublicKey (bytes: Uint8Array, digest?: Digest<18, number>): RSAPublicKey {\n  if (bytes.byteLength >= MAX_RSA_JWK_SIZE) {\n    throw new InvalidPublicKeyError('Key size is too large')\n  }\n\n  const jwk = pkixToJwk(bytes)\n\n  if (digest == null) {\n    const hash = sha256(pb.PublicKey.encode({\n      Type: pb.KeyType.RSA,\n      Data: bytes\n    }))\n    digest = create(SHA2_256_CODE, hash)\n  }\n\n  return new RSAPublicKeyClass(jwk, digest)\n}\n\nexport function jwkToRSAPrivateKey (jwk: JsonWebKey): RSAPrivateKey {\n  if (rsaKeySize(jwk) > MAX_RSA_KEY_SIZE) {\n    throw new InvalidParametersError('Key size is too large')\n  }\n\n  const keys = jwkToJWKKeyPair(jwk)\n  const hash = sha256(pb.PublicKey.encode({\n    Type: pb.KeyType.RSA,\n    Data: jwkToPkix(keys.publicKey)\n  }))\n  const digest = create(SHA2_256_CODE, hash)\n\n  return new RSAPrivateKeyClass(keys.privateKey, new RSAPublicKeyClass(keys.publicKey, digest))\n}\n\nexport async function generateRSAKeyPair (bits: number): Promise<RSAPrivateKey> {\n  if (bits > MAX_RSA_KEY_SIZE) {\n    throw new InvalidParametersError('Key size is too large')\n  }\n\n  const keys = await generateRSAKey(bits)\n  const hash = sha256(pb.PublicKey.encode({\n    Type: pb.KeyType.RSA,\n    Data: jwkToPkix(keys.publicKey)\n  }))\n  const digest = create(SHA2_256_CODE, hash)\n\n  return new RSAPrivateKeyClass(keys.privateKey, new RSAPublicKeyClass(keys.publicKey, digest))\n}\n\n/**\n * Takes a jwk key and returns a JWK KeyPair\n */\nexport function jwkToJWKKeyPair (key: JsonWebKey): JWKKeyPair {\n  if (key == null) {\n    throw new InvalidParametersError('Missing key parameter')\n  }\n\n  return {\n    privateKey: key,\n    publicKey: {\n      kty: key.kty,\n      n: key.n,\n      e: key.e\n    }\n  }\n}\n", "import { Uint8ArrayList } from 'uint8arraylist'\n\ninterface Context {\n  offset: number\n}\n\nconst TAG_MASK = parseInt('11111', 2)\nconst LONG_LENGTH_MASK = parseInt('10000000', 2)\nconst LONG_LENGTH_BYTES_MASK = parseInt('01111111', 2)\n\ninterface Decoder {\n  (buf: Uint8Array, context: Context): any\n}\n\nconst decoders: Record<number, Decoder> = {\n  0x2: readInteger,\n  0x3: readBitString,\n  0x5: readNull,\n  0x6: readObjectIdentifier,\n  0x10: readSequence,\n  0x16: readSequence,\n  0x30: readSequence\n}\n\nexport function decodeDer (buf: Uint8Array, context: Context = { offset: 0 }): any {\n  const tag = buf[context.offset] & TAG_MASK\n  context.offset++\n\n  if (decoders[tag] != null) {\n    return decoders[tag](buf, context)\n  }\n\n  throw new Error('No decoder for tag ' + tag)\n}\n\nfunction readLength (buf: Uint8Array, context: Context): number {\n  let length = 0\n\n  if ((buf[context.offset] & LONG_LENGTH_MASK) === LONG_LENGTH_MASK) {\n    // long length\n    const count = buf[context.offset] & LONG_LENGTH_BYTES_MASK\n    let str = '0x'\n    context.offset++\n\n    for (let i = 0; i < count; i++, context.offset++) {\n      str += buf[context.offset].toString(16).padStart(2, '0')\n    }\n\n    length = parseInt(str, 16)\n  } else {\n    length = buf[context.offset]\n    context.offset++\n  }\n\n  return length\n}\n\nfunction readSequence (buf: Uint8Array, context: Context): any[] {\n  readLength(buf, context)\n  const entries: any[] = []\n\n  while (true) {\n    if (context.offset >= buf.byteLength) {\n      break\n    }\n\n    const result = decodeDer(buf, context)\n\n    if (result === null) {\n      break\n    }\n\n    entries.push(result)\n  }\n\n  return entries\n}\n\nfunction readInteger (buf: Uint8Array, context: Context): Uint8Array {\n  const length = readLength(buf, context)\n  const start = context.offset\n  const end = context.offset + length\n\n  const vals: number[] = []\n\n  for (let i = start; i < end; i++) {\n    if (i === start && buf[i] === 0) {\n      continue\n    }\n\n    vals.push(buf[i])\n  }\n\n  context.offset += length\n\n  return Uint8Array.from(vals)\n}\n\nfunction readObjectIdentifier (buf: Uint8Array, context: Context): string[] {\n  const count = readLength(buf, context)\n\n  // skip OID\n  context.offset += count\n\n  return ['oid-unimplemented']\n}\n\nfunction readNull (buf: Uint8Array, context: Context): null {\n  context.offset++\n\n  return null\n}\n\nfunction readBitString (buf: Uint8Array, context: Context): any {\n  const length = readLength(buf, context)\n  const unusedBits = buf[context.offset]\n  context.offset++\n  const bytes = buf.subarray(context.offset, context.offset + length)\n  context.offset += length\n\n  if (unusedBits !== 0) {\n    // need to shift all bytes along by this many bits\n    throw new Error('Unused bits in bit string is unimplemented')\n  }\n\n  return decodeDer(bytes, {\n    offset: 0\n  })\n}\n\nfunction encodeNumber (value: number): Uint8ArrayList {\n  let number = value.toString(16)\n\n  if (number.length % 2 === 1) {\n    number = '0' + number\n  }\n\n  const array = new Uint8ArrayList()\n\n  for (let i = 0; i < number.length; i += 2) {\n    array.append(Uint8Array.from([parseInt(`${number[i]}${number[i + 1]}`, 16)]))\n  }\n\n  return array\n}\n\nfunction encodeLength (bytes: { byteLength: number }): Uint8Array | Uint8ArrayList {\n  if (bytes.byteLength < 128) {\n    return Uint8Array.from([bytes.byteLength])\n  }\n\n  // long length\n  const length = encodeNumber(bytes.byteLength)\n\n  return new Uint8ArrayList(\n    Uint8Array.from([\n      length.byteLength | LONG_LENGTH_MASK\n    ]),\n    length\n  )\n}\n\nexport function encodeInteger (value: Uint8Array | Uint8ArrayList): Uint8ArrayList {\n  const contents = new Uint8ArrayList()\n\n  const mask = parseInt('10000000', 2)\n  const positive = (value.subarray()[0] & mask) === mask\n\n  if (positive) {\n    contents.append(Uint8Array.from([0]))\n  }\n\n  contents.append(value)\n\n  return new Uint8ArrayList(\n    Uint8Array.from([0x02]),\n    encodeLength(contents),\n    contents\n  )\n}\n\nexport function encodeBitString (value: Uint8Array | Uint8ArrayList): Uint8ArrayList {\n  // unused bits is always 0 with full-byte-only values\n  const unusedBits = Uint8Array.from([0])\n\n  const contents = new Uint8ArrayList(\n    unusedBits,\n    value\n  )\n\n  return new Uint8ArrayList(\n    Uint8Array.from([0x03]),\n    encodeLength(contents),\n    contents\n  )\n}\n\nexport function encodeSequence (values: Array<Uint8Array | Uint8ArrayList>): Uint8ArrayList {\n  const output = new Uint8ArrayList()\n\n  for (const buf of values) {\n    output.append(\n      buf\n    )\n  }\n\n  return new Uint8ArrayList(\n    Uint8Array.from([0x30]),\n    encodeLength(output),\n    output\n  )\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { randomBytes as randB } from '@noble/hashes/utils'\n\n/**\n * Generates a Uint8Array with length `number` populated by random bytes\n */\nexport default function randomBytes (length: number): Uint8Array {\n  if (isNaN(length) || length <= 0) {\n    throw new InvalidParametersError('random bytes length must be a Number bigger than 0')\n  }\n  return randB(length)\n}\n", "/**\n * Signing a message failed\n */\nexport class SigningError extends Error {\n  constructor (message = 'An error occurred while signing a message') {\n    super(message)\n    this.name = 'SigningError'\n  }\n}\n\n/**\n * Verifying a message signature failed\n */\nexport class VerificationError extends Error {\n  constructor (message = 'An error occurred while verifying a message') {\n    super(message)\n    this.name = 'VerificationError'\n  }\n}\n\n/**\n * WebCrypto was not available in the current context\n */\nexport class WebCryptoMissingError extends Error {\n  constructor (message = 'Missing Web Crypto API') {\n    super(message)\n    this.name = 'WebCryptoMissingError'\n  }\n}\n", "/* eslint-env browser */\n\nimport { WebCryptoMissingError } from '../errors.js'\n\n// Check native crypto exists and is enabled (In insecure context `self.crypto`\n// exists but `self.crypto.subtle` does not).\nexport default {\n  get (win = globalThis) {\n    const nativeCrypto = win.crypto\n\n    if (nativeCrypto?.subtle == null) {\n      throw new WebCryptoMissingError(\n        'Missing Web Crypto API. ' +\n        'The most likely cause of this error is that this page is being accessed ' +\n        'from an insecure context (i.e. not HTTPS). For more information and ' +\n        'possible resolutions see ' +\n        'https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api'\n      )\n    }\n\n    return nativeCrypto\n  }\n}\n", "import webcrypto from './webcrypto.js'\n\nexport default webcrypto\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport randomBytes from '../../random-bytes.js'\nimport webcrypto from '../../webcrypto/index.js'\nimport * as utils from './utils.js'\nimport type { JWKKeyPair } from '../interface.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport { utils }\n\nexport async function generateRSAKey (bits: number): Promise<JWKKeyPair> {\n  const pair = await webcrypto.get().subtle.generateKey(\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      modulusLength: bits,\n      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n      hash: { name: 'SHA-256' }\n    },\n    true,\n    ['sign', 'verify']\n  )\n\n  const keys = await exportKey(pair)\n\n  return {\n    privateKey: keys[0],\n    publicKey: keys[1]\n  }\n}\n\nexport { randomBytes as getRandomValues }\n\nexport async function hashAndSign (key: JsonWebKey, msg: Uint8Array | Uint8ArrayList): Promise<Uint8Array> {\n  const privateKey = await webcrypto.get().subtle.importKey(\n    'jwk',\n    key,\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: { name: 'SHA-256' }\n    },\n    false,\n    ['sign']\n  )\n\n  const sig = await webcrypto.get().subtle.sign(\n    { name: 'RSASSA-PKCS1-v1_5' },\n    privateKey,\n    msg instanceof Uint8Array ? msg : msg.subarray()\n  )\n\n  return new Uint8Array(sig, 0, sig.byteLength)\n}\n\nexport async function hashAndVerify (key: JsonWebKey, sig: Uint8Array, msg: Uint8Array | Uint8ArrayList): Promise<boolean> {\n  const publicKey = await webcrypto.get().subtle.importKey(\n    'jwk',\n    key,\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: { name: 'SHA-256' }\n    },\n    false,\n    ['verify']\n  )\n\n  return webcrypto.get().subtle.verify(\n    { name: 'RSASSA-PKCS1-v1_5' },\n    publicKey,\n    sig,\n    msg instanceof Uint8Array ? msg : msg.subarray()\n  )\n}\n\nasync function exportKey (pair: CryptoKeyPair): Promise<[JsonWebKey, JsonWebKey]> {\n  if (pair.privateKey == null || pair.publicKey == null) {\n    throw new InvalidParametersError('Private and public key are required')\n  }\n\n  return Promise.all([\n    webcrypto.get().subtle.exportKey('jwk', pair.privateKey),\n    webcrypto.get().subtle.exportKey('jwk', pair.publicKey)\n  ])\n}\n\nexport function rsaKeySize (jwk: JsonWebKey): number {\n  if (jwk.kty !== 'RSA') {\n    throw new InvalidParametersError('invalid key type')\n  } else if (jwk.n == null) {\n    throw new InvalidParametersError('invalid key modulus')\n  }\n  const bytes = uint8ArrayFromString(jwk.n, 'base64url')\n  return bytes.length * 8\n}\n", "import { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { type Digest } from 'multiformats/hashes/digest'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { hashAndSign, utils, hashAndVerify } from './index.js'\nimport type { RSAPublicKey as RSAPublicKeyInterface, RSAPrivateKey as RSAPrivateKeyInterface } from '@libp2p/interface'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport class RSAPublicKey implements RSAPublicKeyInterface {\n  public readonly type = 'RSA'\n  private readonly _key: JsonWebKey\n  private _raw?: Uint8Array\n  private readonly _multihash: Digest<18, number>\n\n  constructor (key: JsonWebKey, digest: Digest<18, number>) {\n    this._key = key\n    this._multihash = digest\n  }\n\n  get raw (): Uint8Array {\n    if (this._raw == null) {\n      this._raw = utils.jwkToPkix(this._key)\n    }\n\n    return this._raw\n  }\n\n  toMultihash (): Digest<18, number> {\n    return this._multihash\n  }\n\n  toCID (): CID<unknown, 114, 18, 1> {\n    return CID.createV1(114, this._multihash)\n  }\n\n  toString (): string {\n    return base58btc.encode(this.toMultihash().bytes).substring(1)\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  verify (data: Uint8Array | Uint8ArrayList, sig: Uint8Array): boolean | Promise<boolean> {\n    return hashAndVerify(this._key, sig, data)\n  }\n}\n\nexport class RSAPrivateKey implements RSAPrivateKeyInterface {\n  public readonly type = 'RSA'\n  private readonly _key: JsonWebKey\n  private _raw?: Uint8Array\n  public readonly publicKey: RSAPublicKey\n\n  constructor (key: JsonWebKey, publicKey: RSAPublicKey) {\n    this._key = key\n    this.publicKey = publicKey\n  }\n\n  get raw (): Uint8Array {\n    if (this._raw == null) {\n      this._raw = utils.jwkToPkcs1(this._key)\n    }\n\n    return this._raw\n  }\n\n  equals (key: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  sign (message: Uint8Array | Uint8ArrayList): Uint8Array | Promise<Uint8Array> {\n    return hashAndSign(this._key, message)\n  }\n}\n", "import { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\n\nexport function base64urlToBuffer (str: string, len?: number): Uint8Array {\n  let buf = uint8ArrayFromString(str, 'base64urlpad')\n\n  if (len != null) {\n    if (buf.length > len) throw new Error('byte array longer than desired length')\n    buf = uint8ArrayConcat([new Uint8Array(len - buf.length), buf])\n  }\n\n  return buf\n}\n\nexport function isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  if (thing == null) {\n    return false\n  }\n\n  return typeof thing.then === 'function' &&\n    typeof thing.catch === 'function' &&\n    typeof thing.finally === 'function'\n}\n", "import { secp256k1 as secp } from '@noble/curves/secp256k1'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { SigningError, VerificationError } from '../../errors.js'\nimport { isPromise } from '../../util.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\n/**\n * Hash and sign message with private key\n */\nexport function hashAndSign (key: Uint8Array, msg: Uint8Array | Uint8ArrayList): Uint8Array | Promise<Uint8Array> {\n  const p = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray())\n\n  if (isPromise(p)) {\n    return p.then(({ digest }) => secp.sign(digest, key).toDERRawBytes())\n      .catch(err => {\n        throw new SigningError(String(err))\n      })\n  }\n\n  try {\n    return secp.sign(p.digest, key).toDERRawBytes()\n  } catch (err) {\n    throw new SigningError(String(err))\n  }\n}\n\n/**\n * Hash message and verify signature with public key\n */\nexport function hashAndVerify (key: Uint8Array, sig: Uint8Array, msg: Uint8Array | Uint8ArrayList): boolean | Promise<boolean> {\n  const p = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray())\n\n  if (isPromise(p)) {\n    return p.then(({ digest }) => secp.verify(sig, digest, key))\n      .catch(err => {\n        throw new VerificationError(String(err))\n      })\n  }\n\n  try {\n    return secp.verify(sig, p.digest, key)\n  } catch (err) {\n    throw new VerificationError(String(err))\n  }\n}\n", "import { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { identity } from 'multiformats/hashes/identity'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { publicKeyToProtobuf } from '../index.js'\nimport { validateSecp256k1PublicKey, compressSecp256k1PublicKey, computeSecp256k1PublicKey, validateSecp256k1PrivateKey } from './utils.js'\nimport { hashAndVerify, hashAndSign } from './index.js'\nimport type { Secp256k1PublicKey as Secp256k1PublicKeyInterface, Secp256k1PrivateKey as Secp256k1PrivateKeyInterface } from '@libp2p/interface'\nimport type { Digest } from 'multiformats/hashes/digest'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport class Secp256k1PublicKey implements Secp256k1PublicKeyInterface {\n  public readonly type = 'secp256k1'\n  public readonly raw: Uint8Array\n  public readonly _key: Uint8Array\n\n  constructor (key: Uint8Array) {\n    this._key = validateSecp256k1PublicKey(key)\n    this.raw = compressSecp256k1PublicKey(this._key)\n  }\n\n  toMultihash (): Digest<0x0, number> {\n    return identity.digest(publicKeyToProtobuf(this))\n  }\n\n  toCID (): CID<unknown, 114, 0x0, 1> {\n    return CID.createV1(114, this.toMultihash())\n  }\n\n  toString (): string {\n    return base58btc.encode(this.toMultihash().bytes).substring(1)\n  }\n\n  equals (key: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  verify (data: Uint8Array | Uint8ArrayList, sig: Uint8Array): boolean {\n    return hashAndVerify(this._key, sig, data)\n  }\n}\n\nexport class Secp256k1PrivateKey implements Secp256k1PrivateKeyInterface {\n  public readonly type = 'secp256k1'\n  public readonly raw: Uint8Array\n  public readonly publicKey: Secp256k1PublicKey\n\n  constructor (key: Uint8Array, publicKey?: Uint8Array) {\n    this.raw = validateSecp256k1PrivateKey(key)\n    this.publicKey = new Secp256k1PublicKey(publicKey ?? computeSecp256k1PublicKey(key))\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  sign (message: Uint8Array | Uint8ArrayList): Uint8Array | Promise<Uint8Array> {\n    return hashAndSign(this.raw, message)\n  }\n}\n", "import { InvalidPrivateKeyError, InvalidPublicKeyError } from '@libp2p/interface'\nimport { secp256k1 as secp } from '@noble/curves/secp256k1'\nimport { Secp256k1PublicKey as Secp256k1PublicKeyClass, Secp256k1PrivateKey as Secp256k1PrivateKeyClass } from './secp256k1.js'\nimport type { Secp256k1PublicKey, Secp256k1PrivateKey } from '@libp2p/interface'\n\nconst PRIVATE_KEY_BYTE_LENGTH = 32\n\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength }\n\nexport function unmarshalSecp256k1PrivateKey (bytes: Uint8Array): Secp256k1PrivateKey {\n  return new Secp256k1PrivateKeyClass(bytes)\n}\n\nexport function unmarshalSecp256k1PublicKey (bytes: Uint8Array): Secp256k1PublicKey {\n  return new Secp256k1PublicKeyClass(bytes)\n}\n\nexport async function generateSecp256k1KeyPair (): Promise<Secp256k1PrivateKey> {\n  const privateKeyBytes = generateSecp256k1PrivateKey()\n  return new Secp256k1PrivateKeyClass(privateKeyBytes)\n}\n\nexport function compressSecp256k1PublicKey (key: Uint8Array): Uint8Array {\n  const point = secp.ProjectivePoint.fromHex(key).toRawBytes(true)\n  return point\n}\n\nexport function decompressSecp256k1PublicKey (key: Uint8Array): Uint8Array {\n  const point = secp.ProjectivePoint.fromHex(key).toRawBytes(false)\n  return point\n}\n\nexport function validateSecp256k1PrivateKey (key: Uint8Array): Uint8Array {\n  try {\n    secp.getPublicKey(key, true)\n\n    return key\n  } catch (err) {\n    throw new InvalidPrivateKeyError(String(err))\n  }\n}\n\nexport function validateSecp256k1PublicKey (key: Uint8Array): Uint8Array {\n  try {\n    secp.ProjectivePoint.fromHex(key)\n\n    return key\n  } catch (err) {\n    throw new InvalidPublicKeyError(String(err))\n  }\n}\n\nexport function computeSecp256k1PublicKey (privateKey: Uint8Array): Uint8Array {\n  try {\n    return secp.getPublicKey(privateKey, true)\n  } catch (err) {\n    throw new InvalidPrivateKeyError(String(err))\n  }\n}\n\nexport function generateSecp256k1PrivateKey (): Uint8Array {\n  return secp.utils.randomPrivateKey()\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { base64urlToBuffer } from '../../util.js'\nimport webcrypto from '../../webcrypto/index.js'\nimport type { Curve } from './index.js'\nimport type { ECDHKey, ECDHKeyPair, JWKEncodedPrivateKey, JWKEncodedPublicKey } from '../interface.js'\n\nconst curveLengths = {\n  'P-256': 32,\n  'P-384': 48,\n  'P-521': 66\n}\n\nconst curveTypes = Object.keys(curveLengths)\nconst names = curveTypes.join(' / ')\n\nexport async function generateEphemeralKeyPair (curve: Curve): Promise<ECDHKey> {\n  if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n    throw new InvalidParametersError(`Unknown curve: ${curve}. Must be ${names}`)\n  }\n\n  const pair = await webcrypto.get().subtle.generateKey(\n    {\n      name: 'ECDH',\n      namedCurve: curve\n    },\n    true,\n    ['deriveBits']\n  )\n\n  // forcePrivate is used for testing only\n  const genSharedKey = async (theirPub: Uint8Array, forcePrivate?: ECDHKeyPair): Promise<Uint8Array> => {\n    let privateKey\n\n    if (forcePrivate != null) {\n      privateKey = await webcrypto.get().subtle.importKey(\n        'jwk',\n        unmarshalPrivateKey(curve, forcePrivate),\n        {\n          name: 'ECDH',\n          namedCurve: curve\n        },\n        false,\n        ['deriveBits']\n      )\n    } else {\n      privateKey = pair.privateKey\n    }\n\n    const key = await webcrypto.get().subtle.importKey(\n      'jwk',\n      unmarshalPublicKey(curve, theirPub),\n      {\n        name: 'ECDH',\n        namedCurve: curve\n      },\n      false,\n      []\n    )\n\n    const buffer = await webcrypto.get().subtle.deriveBits(\n      {\n        name: 'ECDH',\n        public: key\n      },\n      privateKey,\n      curveLengths[curve] * 8\n    )\n\n    return new Uint8Array(buffer, 0, buffer.byteLength)\n  }\n\n  const publicKey = await webcrypto.get().subtle.exportKey('jwk', pair.publicKey)\n\n  const ecdhKey: ECDHKey = {\n    key: marshalPublicKey(publicKey),\n    genSharedKey\n  }\n\n  return ecdhKey\n}\n\n// Marshal converts a jwk encoded ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\nfunction marshalPublicKey (jwk: JsonWebKey): Uint8Array {\n  if (jwk.crv == null || jwk.x == null || jwk.y == null) {\n    throw new InvalidParametersError('JWK was missing components')\n  }\n\n  if (jwk.crv !== 'P-256' && jwk.crv !== 'P-384' && jwk.crv !== 'P-521') {\n    throw new InvalidParametersError(`Unknown curve: ${jwk.crv}. Must be ${names}`)\n  }\n\n  const byteLen = curveLengths[jwk.crv]\n\n  return uint8ArrayConcat([\n    Uint8Array.from([4]), // uncompressed point\n    base64urlToBuffer(jwk.x, byteLen),\n    base64urlToBuffer(jwk.y, byteLen)\n  ], 1 + byteLen * 2)\n}\n\n/**\n * Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\n */\nfunction unmarshalPublicKey (curve: Curve, key: Uint8Array): JWKEncodedPublicKey {\n  if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n    throw new InvalidParametersError(`Unknown curve: ${curve}. Must be ${names}`)\n  }\n\n  const byteLen = curveLengths[curve]\n\n  if (!uint8ArrayEquals(key.subarray(0, 1), Uint8Array.from([4]))) {\n    throw new InvalidParametersError('Cannot unmarshal public key - invalid key format')\n  }\n\n  return {\n    kty: 'EC',\n    crv: curve,\n    x: uint8ArrayToString(key.subarray(1, byteLen + 1), 'base64url'),\n    y: uint8ArrayToString(key.subarray(1 + byteLen), 'base64url'),\n    ext: true\n  }\n}\n\nconst unmarshalPrivateKey = (curve: Curve, key: ECDHKeyPair): JWKEncodedPrivateKey => ({\n  ...unmarshalPublicKey(curve, key.public),\n  d: uint8ArrayToString(key.private, 'base64url')\n})\n", "/**\n * @packageDocumentation\n *\n * ## Supported Key Types\n *\n * Currently the `'RSA'`, `'ed25519'`, and `secp256k1` types are supported, although ed25519 and secp256k1 keys support only signing and verification of messages.\n *\n * For encryption / decryption support, RSA keys should be used.\n */\n\nimport { UnsupportedKeyTypeError } from '@libp2p/interface'\nimport { generateEd25519KeyPair, generateEd25519KeyPairFromSeed, unmarshalEd25519PrivateKey, unmarshalEd25519PublicKey } from './ed25519/utils.js'\nimport * as pb from './keys.js'\nimport { pkcs1ToRSAPrivateKey, pkixToRSAPublicKey, generateRSAKeyPair } from './rsa/utils.js'\nimport { generateSecp256k1KeyPair, unmarshalSecp256k1PrivateKey, unmarshalSecp256k1PublicKey } from './secp256k1/utils.js'\nimport type { PrivateKey, PublicKey, KeyType, RSAPrivateKey, Secp256k1PrivateKey, Ed25519PrivateKey, Secp256k1PublicKey, Ed25519PublicKey } from '@libp2p/interface'\nimport type { MultihashDigest } from 'multiformats'\nimport type { Digest } from 'multiformats/hashes/digest'\n\nexport { generateEphemeralKeyPair } from './ecdh/index.js'\nexport type { Curve } from './ecdh/index.js'\nexport type { ECDHKey, EnhancedKey, EnhancedKeyPair, ECDHKeyPair } from './interface.js'\nexport { keyStretcher } from './key-stretcher.js'\n\n/**\n * Generates a keypair of the given type and bitsize\n */\nexport async function generateKeyPair (type: 'Ed25519'): Promise<Ed25519PrivateKey>\nexport async function generateKeyPair (type: 'secp256k1'): Promise<Secp256k1PrivateKey>\nexport async function generateKeyPair (type: 'RSA', bits?: number): Promise<RSAPrivateKey>\nexport async function generateKeyPair (type: KeyType, bits?: number): Promise<PrivateKey>\nexport async function generateKeyPair (type: KeyType, bits?: number): Promise<unknown> {\n  if (type === 'Ed25519') {\n    return generateEd25519KeyPair()\n  }\n\n  if (type === 'secp256k1') {\n    return generateSecp256k1KeyPair()\n  }\n\n  if (type === 'RSA') {\n    return generateRSAKeyPair(bits ?? 2048)\n  }\n\n  throw new UnsupportedKeyTypeError()\n}\n\n/**\n * Generates a keypair of the given type from the passed seed.  Currently only\n * supports Ed25519 keys.\n *\n * Seed is a 32 byte uint8array\n */\nexport async function generateKeyPairFromSeed (type: 'Ed25519', seed: Uint8Array): Promise<Ed25519PrivateKey>\nexport async function generateKeyPairFromSeed <T extends KeyType> (type: T, seed: Uint8Array, bits?: number): Promise<never>\nexport async function generateKeyPairFromSeed (type: string, seed: Uint8Array): Promise<unknown> {\n  if (type !== 'Ed25519') {\n    throw new UnsupportedKeyTypeError('Seed key derivation only supported for Ed25519 keys')\n  }\n\n  return generateEd25519KeyPairFromSeed(seed)\n}\n\n/**\n * Converts a protobuf serialized public key into its representative object.\n *\n * For RSA public keys optionally pass the multihash digest of the public key if\n * it is known. If the digest is omitted it will be calculated which can be\n * expensive.\n *\n * For other key types the digest option is ignored.\n */\nexport function publicKeyFromProtobuf (buf: Uint8Array, digest?: Digest<18, number>): PublicKey {\n  const { Type, Data } = pb.PublicKey.decode(buf)\n  const data = Data ?? new Uint8Array()\n\n  switch (Type) {\n    case pb.KeyType.RSA:\n      return pkixToRSAPublicKey(data, digest)\n    case pb.KeyType.Ed25519:\n      return unmarshalEd25519PublicKey(data)\n    case pb.KeyType.secp256k1:\n      return unmarshalSecp256k1PublicKey(data)\n    default:\n      throw new UnsupportedKeyTypeError()\n  }\n}\n\n/**\n * Creates a public key from the raw key bytes\n */\nexport function publicKeyFromRaw (buf: Uint8Array): PublicKey {\n  if (buf.byteLength === 32) {\n    return unmarshalEd25519PublicKey(buf)\n  } else if (buf.byteLength === 33) {\n    return unmarshalSecp256k1PublicKey(buf)\n  } else {\n    return pkixToRSAPublicKey(buf)\n  }\n}\n\n/**\n * Creates a public key from an identity multihash which contains a protobuf\n * encoded Ed25519 or secp256k1 public key.\n *\n * RSA keys are not supported as in practice we they are not stored in identity\n * multihash since the hash would be very large.\n */\nexport function publicKeyFromMultihash (digest: MultihashDigest<0x0>): Ed25519PublicKey | Secp256k1PublicKey {\n  const { Type, Data } = pb.PublicKey.decode(digest.digest)\n  const data = Data ?? new Uint8Array()\n\n  switch (Type) {\n    case pb.KeyType.Ed25519:\n      return unmarshalEd25519PublicKey(data)\n    case pb.KeyType.secp256k1:\n      return unmarshalSecp256k1PublicKey(data)\n    default:\n      throw new UnsupportedKeyTypeError()\n  }\n}\n\n/**\n * Converts a public key object into a protobuf serialized public key\n */\nexport function publicKeyToProtobuf (key: PublicKey): Uint8Array {\n  return pb.PublicKey.encode({\n    Type: pb.KeyType[key.type],\n    Data: key.raw\n  })\n}\n\n/**\n * Converts a protobuf serialized private key into its representative object\n */\nexport function privateKeyFromProtobuf (buf: Uint8Array): Ed25519PrivateKey | Secp256k1PrivateKey | RSAPrivateKey {\n  const decoded = pb.PrivateKey.decode(buf)\n  const data = decoded.Data ?? new Uint8Array()\n\n  switch (decoded.Type) {\n    case pb.KeyType.RSA:\n      return pkcs1ToRSAPrivateKey(data)\n    case pb.KeyType.Ed25519:\n      return unmarshalEd25519PrivateKey(data)\n    case pb.KeyType.secp256k1:\n      return unmarshalSecp256k1PrivateKey(data)\n    default:\n      throw new UnsupportedKeyTypeError()\n  }\n}\n\n/**\n * Creates a private key from the raw key bytes. For Ed25519 keys this requires\n * the public key to be appended to the private key otherwise we can't\n * differentiate between Ed25519 and secp256k1 keys as they are the same length.\n */\nexport function privateKeyFromRaw (buf: Uint8Array): PrivateKey {\n  if (buf.byteLength === 64) {\n    return unmarshalEd25519PrivateKey(buf)\n  } else if (buf.byteLength === 32) {\n    return unmarshalSecp256k1PrivateKey(buf)\n  } else {\n    return pkcs1ToRSAPrivateKey(buf)\n  }\n}\n\n/**\n * Converts a private key object into a protobuf serialized private key\n */\nexport function privateKeyToProtobuf (key: PrivateKey): Uint8Array {\n  return pb.PrivateKey.encode({\n    Type: pb.KeyType[key.type],\n    Data: key.raw\n  })\n}\n", "// Maximum length of the length section of the message\nexport const MAX_LENGTH_LENGTH = 8 // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\nexport const MAX_DATA_LENGTH = 1024 * 1024 * 4\n", "/**\n * The reported length of the next data message was not a positive integer\n */\nexport class InvalidMessageLengthError extends Error {\n  name = 'InvalidMessageLengthError'\n  code = 'ERR_INVALID_MSG_LENGTH'\n}\n\n/**\n * The reported length of the next data message was larger than the configured\n * max allowable value\n */\nexport class InvalidDataLengthError extends Error {\n  name = 'InvalidDataLengthError'\n  code = 'ERR_MSG_DATA_TOO_LONG'\n}\n\n/**\n * The varint used to specify the length of the next data message contained more\n * bytes than the configured max allowable value\n */\nexport class InvalidDataLengthLengthError extends Error {\n  name = 'InvalidDataLengthLengthError'\n  code = 'ERR_MSG_LENGTH_TOO_LONG'\n}\n\n/**\n * The incoming stream ended before the expected number of bytes were read\n */\nexport class UnexpectedEOFError extends Error {\n  name = 'UnexpectedEOFError'\n  code = 'ERR_UNEXPECTED_EOF'\n}\n", "export function isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n", "/* eslint max-depth: [\"error\", 6] */\n\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { MAX_DATA_LENGTH, MAX_LENGTH_LENGTH } from './constants.js'\nimport { InvalidDataLengthError, InvalidDataLengthLengthError, InvalidMessageLengthError, UnexpectedEOFError } from './errors.js'\nimport { isAsyncIterable } from './utils.js'\nimport type { DecoderOptions, LengthDecoderFunction } from './index.js'\nimport type { Reader } from 'it-reader'\nimport type { Source } from 'it-stream-types'\n\nenum ReadMode {\n  LENGTH,\n  DATA\n}\n\nconst defaultDecoder: LengthDecoderFunction = (buf) => {\n  const length = varint.decode(buf)\n  defaultDecoder.bytes = varint.encodingLength(length)\n\n  return length\n}\ndefaultDecoder.bytes = 0\n\nexport function decode (source: Iterable<Uint8ArrayList | Uint8Array>, options?: DecoderOptions): Generator<Uint8ArrayList, void, unknown>\nexport function decode (source: Source<Uint8ArrayList | Uint8Array>, options?: DecoderOptions): AsyncGenerator<Uint8ArrayList, void, unknown>\nexport function decode (source: Source<Uint8ArrayList | Uint8Array>, options?: DecoderOptions): Generator<Uint8ArrayList, void, unknown> | AsyncGenerator<Uint8ArrayList, void, unknown> {\n  const buffer = new Uint8ArrayList()\n  let mode = ReadMode.LENGTH\n  let dataLength = -1\n\n  const lengthDecoder = options?.lengthDecoder ?? defaultDecoder\n  const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH\n  const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH\n\n  function * maybeYield (): Generator<Uint8ArrayList> {\n    while (buffer.byteLength > 0) {\n      if (mode === ReadMode.LENGTH) {\n        // read length, ignore errors for short reads\n        try {\n          dataLength = lengthDecoder(buffer)\n\n          if (dataLength < 0) {\n            throw new InvalidMessageLengthError('Invalid message length')\n          }\n\n          if (dataLength > maxDataLength) {\n            throw new InvalidDataLengthError('Message length too long')\n          }\n\n          const dataLengthLength = lengthDecoder.bytes\n          buffer.consume(dataLengthLength)\n\n          if (options?.onLength != null) {\n            options.onLength(dataLength)\n          }\n\n          mode = ReadMode.DATA\n        } catch (err: any) {\n          if (err instanceof RangeError) {\n            if (buffer.byteLength > maxLengthLength) {\n              throw new InvalidDataLengthLengthError('Message length length too long')\n            }\n\n            break\n          }\n\n          throw err\n        }\n      }\n\n      if (mode === ReadMode.DATA) {\n        if (buffer.byteLength < dataLength) {\n          // not enough data, wait for more\n          break\n        }\n\n        const data = buffer.sublist(0, dataLength)\n        buffer.consume(dataLength)\n\n        if (options?.onData != null) {\n          options.onData(data)\n        }\n\n        yield data\n\n        mode = ReadMode.LENGTH\n      }\n    }\n  }\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const buf of source) {\n        buffer.append(buf)\n\n        yield * maybeYield()\n      }\n\n      if (buffer.byteLength > 0) {\n        throw new UnexpectedEOFError('Unexpected end of input')\n      }\n    })()\n  }\n\n  return (function * () {\n    for (const buf of source) {\n      buffer.append(buf)\n\n      yield * maybeYield()\n    }\n\n    if (buffer.byteLength > 0) {\n      throw new UnexpectedEOFError('Unexpected end of input')\n    }\n  })()\n}\n\ndecode.fromReader = (reader: Reader, options?: DecoderOptions) => {\n  let byteLength = 1 // Read single byte chunks until the length is known\n\n  const varByteSource = (async function * () {\n    while (true) {\n      try {\n        const { done, value } = await reader.next(byteLength)\n\n        if (done === true) {\n          return\n        }\n\n        if (value != null) {\n          yield value\n        }\n      } catch (err: any) {\n        if (err.code === 'ERR_UNDER_READ') {\n          return { done: true, value: null }\n        }\n        throw err\n      } finally {\n        // Reset the byteLength so we continue to check for varints\n        byteLength = 1\n      }\n    }\n  }())\n\n  /**\n   * Once the length has been parsed, read chunk for that length\n   */\n  const onLength = (l: number): void => { byteLength = l }\n  return decode(varByteSource, {\n    ...(options ?? {}),\n    onLength\n  })\n}\n", "import * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { allocUnsafe } from 'uint8arrays/alloc'\nimport { MAX_DATA_LENGTH } from './constants.js'\nimport { InvalidDataLengthError } from './errors.js'\nimport { isAsyncIterable } from './utils.js'\nimport type { EncoderOptions, LengthEncoderFunction } from './index.js'\nimport type { Source } from 'it-stream-types'\n\n// Helper function to validate the chunk size against maxDataLength\nfunction validateMaxDataLength (chunk: Uint8Array | Uint8ArrayList, maxDataLength: number): void {\n  if (chunk.byteLength > maxDataLength) {\n    throw new InvalidDataLengthError('Message length too long')\n  }\n}\n\nconst defaultEncoder: LengthEncoderFunction = (length) => {\n  const lengthLength = varint.encodingLength(length)\n  const lengthBuf = allocUnsafe(lengthLength)\n\n  varint.encode(length, lengthBuf)\n\n  defaultEncoder.bytes = lengthLength\n\n  return lengthBuf\n}\ndefaultEncoder.bytes = 0\n\nexport function encode (source: Iterable<Uint8ArrayList | Uint8Array>, options?: EncoderOptions): Generator<Uint8Array, void, undefined>\nexport function encode (source: Source<Uint8ArrayList | Uint8Array>, options?: EncoderOptions): AsyncGenerator<Uint8Array, void, undefined>\nexport function encode (source: Source<Uint8ArrayList | Uint8Array>, options?: EncoderOptions): Generator<Uint8Array, void, undefined> | AsyncGenerator<Uint8Array, void, undefined> {\n  options = options ?? {}\n\n  const encodeLength = options.lengthEncoder ?? defaultEncoder\n  const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH\n\n  function * maybeYield (chunk: Uint8Array | Uint8ArrayList): Generator<Uint8Array, void, undefined> {\n    validateMaxDataLength(chunk, maxDataLength)\n\n    // length + data\n    const length = encodeLength(chunk.byteLength)\n\n    // yield only Uint8Arrays\n    if (length instanceof Uint8Array) {\n      yield length\n    } else {\n      yield * length\n    }\n\n    // yield only Uint8Arrays\n    if (chunk instanceof Uint8Array) {\n      yield chunk\n    } else {\n      yield * chunk\n    }\n  }\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const chunk of source) {\n        yield * maybeYield(chunk)\n      }\n    })()\n  }\n\n  return (function * () {\n    for (const chunk of source) {\n      yield * maybeYield(chunk)\n    }\n  })()\n}\n\nencode.single = (chunk: Uint8ArrayList | Uint8Array, options?: EncoderOptions) => {\n  options = options ?? {}\n  const encodeLength = options.lengthEncoder ?? defaultEncoder\n  const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH\n\n  validateMaxDataLength(chunk, maxDataLength)\n\n  return new Uint8ArrayList(\n    encodeLength(chunk.byteLength),\n    chunk\n  )\n}\n", "/**\n * @packageDocumentation\n *\n * A pushable async generator that waits until the current value is consumed\n * before allowing a new value to be pushed.\n *\n * Useful for when you don't want to keep memory usage under control and/or\n * allow a downstream consumer to dictate how fast data flows through a pipe,\n * but you want to be able to apply a transform to that data.\n *\n * @example\n *\n * ```typescript\n * import { queuelessPushable } from 'it-queueless-pushable'\n *\n * const pushable = queuelessPushable<string>()\n *\n * // run asynchronously\n * Promise.resolve().then(async () => {\n *   // push a value - the returned promise will not resolve until the value is\n *   // read from the pushable\n *   await pushable.push('hello')\n * })\n *\n * // read a value\n * const result = await pushable.next()\n * console.info(result) // { done: false, value: 'hello' }\n * ```\n */\n\nimport deferred, { type DeferredPromise } from 'p-defer'\nimport { raceSignal, type RaceSignalOptions } from 'race-signal'\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\nexport interface Pushable<T> extends AsyncGenerator<T, void, unknown> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error, options?: AbortOptions & RaceSignalOptions): Promise<void>\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T, options?: AbortOptions & RaceSignalOptions): Promise<void>\n}\n\nclass QueuelessPushable <T> implements Pushable<T> {\n  private readNext: DeferredPromise<void>\n  private haveNext: DeferredPromise<void>\n  private ended: boolean\n  private nextResult: IteratorResult<T> | undefined\n\n  constructor () {\n    this.ended = false\n\n    this.readNext = deferred()\n    this.haveNext = deferred()\n  }\n\n  [Symbol.asyncIterator] (): AsyncGenerator<T, void, unknown> {\n    return this\n  }\n\n  async next (): Promise<IteratorResult<T, void>> {\n    if (this.nextResult == null) {\n      // wait for the supplier to push a value\n      await this.haveNext.promise\n    }\n\n    if (this.nextResult == null) {\n      throw new Error('HaveNext promise resolved but nextResult was undefined')\n    }\n\n    const nextResult = this.nextResult\n    this.nextResult = undefined\n\n    // signal to the supplier that we read the value\n    this.readNext.resolve()\n    this.readNext = deferred()\n\n    return nextResult\n  }\n\n  async throw (err?: Error): Promise<IteratorReturnResult<undefined>> {\n    this.ended = true\n\n    if (err != null) {\n      // this can cause unhandled promise rejections if nothing is awaiting the\n      // next value so attach a dummy catch listener to the promise\n      this.haveNext.promise.catch(() => {})\n      this.haveNext.reject(err)\n    }\n\n    const result: IteratorReturnResult<undefined> = {\n      done: true,\n      value: undefined\n    }\n\n    return result\n  }\n\n  async return (): Promise<IteratorResult<T>> {\n    const result: IteratorReturnResult<undefined> = {\n      done: true,\n      value: undefined\n    }\n\n    this.ended = true\n    this.nextResult = result\n\n    // let the consumer know we have a new value\n    this.haveNext.resolve()\n\n    return result\n  }\n\n  async push (value: T, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    await this._push(value, options)\n  }\n\n  async end (err?: Error, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    if (err != null) {\n      await this.throw(err)\n    } else {\n      // abortable return\n      await this._push(undefined, options)\n    }\n  }\n\n  private async _push (value?: T, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    if (value != null && this.ended) {\n      throw new Error('Cannot push value onto an ended pushable')\n    }\n\n    // wait for all values to be read\n    while (this.nextResult != null) {\n      await this.readNext.promise\n    }\n\n    if (value != null) {\n      this.nextResult = { done: false, value }\n    } else {\n      this.ended = true\n      this.nextResult = { done: true, value: undefined }\n    }\n\n    // let the consumer know we have a new value\n    this.haveNext.resolve()\n    this.haveNext = deferred()\n\n    // wait for the consumer to have finished processing the value and requested\n    // the next one or for the passed signal to abort the waiting\n    await raceSignal(\n      this.readNext.promise,\n      options?.signal,\n      options\n    )\n  }\n}\n\nexport function queuelessPushable <T> (): Pushable<T> {\n  return new QueuelessPushable<T>()\n}\n", "/**\n * The incoming stream ended before the expected number of bytes were read\n */\nexport class UnexpectedEOFError extends Error {\n  name = 'UnexpectedEOFError'\n  code = 'ERR_UNEXPECTED_EOF'\n}\n", "/**\n * @packageDocumentation\n *\n * This module makes it easy to send and receive bytes over streams.\n *\n * @example\n *\n * ```typescript\n * import { byteStream } from 'it-byte-stream'\n *\n * const stream = byteStream(duplex)\n *\n * // read the next chunk\n * const bytes = await stream.read()\n *\n * // read the next five bytes\n * const fiveBytes = await stream.read(5)\n *\n * // write bytes into the stream\n * await stream.write(Uint8Array.from([0, 1, 2, 3, 4]))\n * ```\n */\n\nimport { queuelessPushable } from 'it-queueless-pushable'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { UnexpectedEOFError } from './errors.js'\nimport type { Duplex } from 'it-stream-types'\n\n/**\n * @deprecated This will not be exported in a future release\n */\nexport class CodeError extends Error {\n  public readonly code: string\n\n  constructor (message: string, code: string) {\n    super(message)\n    this.code = code\n  }\n}\n\n/**\n * @deprecated This will not be exported in a future release\n */\nexport class AbortError extends CodeError {\n  public readonly type: string\n\n  constructor (message: string) {\n    super(message, 'ABORT_ERR')\n    this.type = 'aborted'\n    this.name = 'AbortError'\n  }\n}\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\nexport interface ByteStream <Stream = unknown> {\n  /**\n   * Read a set number of bytes from the stream\n   */\n  read(bytes?: number, options?: AbortOptions): Promise<Uint8ArrayList>\n\n  /**\n   * Write the passed bytes to the stream\n   */\n  write(input: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<void>\n\n  /**\n   * Returns the underlying stream\n   */\n  unwrap(): Stream\n}\n\nexport interface ByteStreamOpts {\n  /**\n   * After the stream is unwrapped, any bytes that have been read from the\n   * incoming stream will be yielded in-order as `Uint8Array`(s).\n   *\n   * To yield a single `Uint8ArrayList` with all unread bytes instead, pass\n   * `false` here.\n   */\n  yieldBytes?: boolean\n}\n\nexport function byteStream <Stream extends Duplex<any, any, any>> (duplex: Stream, opts?: ByteStreamOpts): ByteStream<Stream> {\n  const write = queuelessPushable()\n\n  duplex.sink(write).catch(async (err: Error) => {\n    await write.end(err)\n  })\n\n  duplex.sink = async (source: any) => {\n    for await (const buf of source) {\n      await write.push(buf)\n    }\n\n    await write.end()\n  }\n\n  let source = duplex.source\n\n  if (duplex.source[Symbol.iterator] != null) {\n    source = duplex.source[Symbol.iterator]()\n  } else if (duplex.source[Symbol.asyncIterator] != null) {\n    source = duplex.source[Symbol.asyncIterator]()\n  }\n\n  const readBuffer = new Uint8ArrayList()\n\n  const W: ByteStream<Stream> = {\n    read: async (bytes?: number, options?: AbortOptions) => {\n      options?.signal?.throwIfAborted()\n\n      let listener: EventListener | undefined\n\n      const abortPromise = new Promise((resolve, reject) => {\n        listener = () => {\n          reject(new AbortError('Read aborted'))\n        }\n\n        options?.signal?.addEventListener('abort', listener)\n      })\n\n      try {\n        if (bytes == null) {\n          // just read whatever arrives\n          const { done, value } = await Promise.race([\n            source.next(),\n            abortPromise\n          ])\n\n          if (done === true) {\n            return new Uint8ArrayList()\n          }\n\n          return value\n        }\n\n        while (readBuffer.byteLength < bytes) {\n          const { value, done } = await Promise.race([\n            source.next(),\n            abortPromise\n          ])\n\n          if (done === true) {\n            throw new UnexpectedEOFError('unexpected end of input')\n          }\n\n          readBuffer.append(value)\n        }\n\n        const buf = readBuffer.sublist(0, bytes)\n        readBuffer.consume(bytes)\n\n        return buf\n      } finally {\n        if (listener != null) {\n          options?.signal?.removeEventListener('abort', listener)\n        }\n      }\n    },\n    write: async (data, options?: AbortOptions) => {\n      options?.signal?.throwIfAborted()\n\n      // just write\n      if (data instanceof Uint8Array) {\n        await write.push(data, options)\n      } else {\n        await write.push(data.subarray(), options)\n      }\n    },\n    unwrap: () => {\n      if (readBuffer.byteLength > 0) {\n        const originalStream = duplex.source\n        duplex.source = (async function * () {\n          if (opts?.yieldBytes === false) {\n            yield readBuffer\n          } else {\n            yield * readBuffer\n          }\n\n          yield * originalStream\n        }())\n      }\n\n      return duplex\n    }\n  }\n\n  return W\n}\n", "/**\n * The reported length of the next data message was not a positive integer\n */\nexport class InvalidMessageLengthError extends Error {\n  name = 'InvalidMessageLengthError'\n  code = 'ERR_INVALID_MSG_LENGTH'\n}\n\n/**\n * The reported length of the next data message was larger than the configured\n * max allowable value\n */\nexport class InvalidDataLengthError extends Error {\n  name = 'InvalidDataLengthError'\n  code = 'ERR_MSG_DATA_TOO_LONG'\n}\n\n/**\n * The varint used to specify the length of the next data message contained more\n * bytes than the configured max allowable value\n */\nexport class InvalidDataLengthLengthError extends Error {\n  name = 'InvalidDataLengthLengthError'\n  code = 'ERR_MSG_LENGTH_TOO_LONG'\n}\n", "/**\n * @packageDocumentation\n *\n * This module makes it easy to send and receive length-prefixed byte arrays over streams.\n *\n * @example\n *\n * ```typescript\n * import { lpStream } from 'it-length-prefixed-stream'\n *\n * const stream = lpStream(duplex)\n *\n * // read the next length-prefixed chunk\n * const bytes = await stream.read()\n *\n * // write a length-prefixed chunk\n * await stream.write(Uint8Array.from([0, 1, 2, 3, 4]))\n *\n * // write several chunks, all individually length-prefixed\n * await stream.writeV([\n *   Uint8Array.from([0, 1, 2, 3, 4]),\n *   Uint8Array.from([5, 6, 7, 8, 9])\n * ])\n * ```\n */\nimport { byteStream, type ByteStreamOpts } from 'it-byte-stream'\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { InvalidDataLengthError, InvalidDataLengthLengthError, InvalidMessageLengthError } from './errors.js'\nimport type { Duplex } from 'it-stream-types'\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\nexport interface LengthPrefixedStream <Stream = unknown> {\n  /**\n   * Read the next length-prefixed number of bytes from the stream\n   */\n  read(options?: AbortOptions): Promise<Uint8ArrayList>\n\n  /**\n   * Write the passed bytes to the stream prefixed by their length\n   */\n  write(input: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<void>\n\n  /**\n   * Write passed list of bytes, prefix by their individual lengths to the stream as a single write\n   */\n  writeV(input: Array<Uint8Array | Uint8ArrayList>, options?: AbortOptions): Promise<void>\n\n  /**\n   * Returns the underlying stream\n   */\n  unwrap(): Stream\n}\n\nexport interface LengthPrefixedStreamOpts extends ByteStreamOpts {\n  // encoding opts\n  lengthEncoder (value: number): Uint8ArrayList | Uint8Array\n\n  // decoding opts\n  lengthDecoder (data: Uint8ArrayList): number\n  maxLengthLength: number\n  maxDataLength: number\n}\n\nexport function lpStream <Stream extends Duplex<any, any, any>> (duplex: Stream, opts: Partial<LengthPrefixedStreamOpts> = {}): LengthPrefixedStream<Stream> {\n  const bytes = byteStream(duplex, opts)\n\n  if (opts.maxDataLength != null && opts.maxLengthLength == null) {\n    // if max data length is set but max length length is not, calculate the\n    // max length length needed to encode max data length\n    opts.maxLengthLength = varint.encodingLength(opts.maxDataLength)\n  }\n\n  const decodeLength = opts?.lengthDecoder ?? varint.decode\n  const encodeLength = opts?.lengthEncoder ?? varint.encode\n\n  const W: LengthPrefixedStream<Stream> = {\n    read: async (options?: AbortOptions) => {\n      let dataLength: number = -1\n      const lengthBuffer = new Uint8ArrayList()\n\n      while (true) {\n        // read one byte at a time until we can decode a varint\n        lengthBuffer.append(await bytes.read(1, options))\n\n        try {\n          dataLength = decodeLength(lengthBuffer)\n        } catch (err) {\n          if (err instanceof RangeError) {\n            continue\n          }\n\n          throw err\n        }\n\n        if (dataLength < 0) {\n          throw new InvalidMessageLengthError('Invalid message length')\n        }\n\n        if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {\n          throw new InvalidDataLengthLengthError('message length length too long')\n        }\n\n        if (dataLength > -1) {\n          break\n        }\n      }\n\n      if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {\n        throw new InvalidDataLengthError('message length too long')\n      }\n\n      return bytes.read(dataLength, options)\n    },\n    write: async (data, options?: AbortOptions) => {\n      // encode, write\n      await bytes.write(new Uint8ArrayList(encodeLength(data.byteLength), data), options)\n    },\n    writeV: async (data, options?: AbortOptions) => {\n      const list = new Uint8ArrayList(\n        ...data.flatMap(buf => ([encodeLength(buf.byteLength), buf]))\n      )\n\n      // encode, write\n      await bytes.write(list, options)\n    },\n    unwrap: () => {\n      return bytes.unwrap()\n    }\n  }\n\n  return W\n}\n", "/**\n * @packageDocumentation\n *\n * Merge several (async)iterables into one, yield values as they arrive.\n *\n * Nb. sources are iterated over in parallel so the order of emitted items is not guaranteed.\n *\n * @example\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values1 = [0, 1, 2, 3, 4]\n * const values2 = [5, 6, 7, 8, 9]\n *\n * const arr = all(merge(values1, values2))\n *\n * console.info(arr) // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const values1 = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n * const values2 = async function * () {\n *   yield * [5, 6, 7, 8, 9]\n * }\n *\n * const arr = await all(merge(values1(), values2()))\n *\n * console.info(arr) // 0, 1, 5, 6, 2, 3, 4, 7, 8, 9  <- nb. order is not guaranteed\n * ```\n */\n\nimport { queuelessPushable } from 'it-queueless-pushable'\nimport type { Pushable } from 'it-queueless-pushable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\nasync function addAllToPushable <T> (sources: Array<AsyncIterable<T> | Iterable<T>>, output: Pushable<T>): Promise<void> {\n  try {\n    await Promise.all(\n      sources.map(async (source) => {\n        for await (const item of source) {\n          await output.push(item)\n        }\n      })\n    )\n\n    await output.end()\n  } catch (err: any) {\n    await output.end(err)\n      .catch(() => {})\n  }\n}\n\nasync function * mergeSources <T> (sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined> {\n  const output = queuelessPushable<T>()\n\n  addAllToPushable(sources, output)\n    .catch(() => {})\n\n  yield * output\n}\n\nfunction * mergeSyncSources <T> (syncSources: Array<Iterable<T>>): Generator<T, void, undefined> {\n  for (const source of syncSources) {\n    yield * source\n  }\n}\n\n/**\n * Treat one or more iterables as a single iterable.\n *\n * Nb. sources are iterated over in parallel so the\n * order of emitted items is not guaranteed.\n */\nfunction merge <T> (...sources: Array<Iterable<T>>): Generator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  const syncSources: Array<Iterable<T>> = []\n\n  for (const source of sources) {\n    if (!isAsyncIterable(source)) {\n      syncSources.push(source)\n    }\n  }\n\n  if (syncSources.length === sources.length) {\n    // all sources are synchronous\n    return mergeSyncSources(syncSources)\n  }\n\n  return mergeSources(sources)\n}\n\nexport default merge\n"],
  "mappings": "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",
  "names": ["message", "KeyType", "__KeyTypeValues", "PublicKey", "PrivateKey", "randomBytes", "message", "hashAndSign", "hashAndVerify", "hashAndVerify", "message", "hashAndSign", "sha256", "hashAndSign", "hashAndVerify", "hashAndVerify", "message", "hashAndSign", "ReadMode", "decode", "encode", "encodeLength", "queuelessPushable", "UnexpectedEOFError", "message", "queuelessPushable", "source", "_a", "UnexpectedEOFError", "InvalidMessageLengthError", "InvalidDataLengthError", "InvalidDataLengthLengthError", "encodeLength", "InvalidMessageLengthError", "InvalidDataLengthLengthError", "InvalidDataLengthError", "isAsyncIterable"]
}
