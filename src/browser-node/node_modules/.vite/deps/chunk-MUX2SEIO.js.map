{
  "version": 3,
  "sources": ["../../.pnpm/@libp2p+peer-id@5.1.1/node_modules/@libp2p/peer-id/src/peer-id.ts", "../../.pnpm/@libp2p+peer-id@5.1.1/node_modules/@libp2p/peer-id/src/index.ts", "../../.pnpm/it-length-prefixed-stream@2.0.1/node_modules/it-length-prefixed-stream/src/errors.ts", "../../.pnpm/it-length-prefixed-stream@2.0.1/node_modules/it-length-prefixed-stream/src/index.ts", "../../.pnpm/it-protobuf-stream@2.0.1/node_modules/it-protobuf-stream/src/index.ts"],
  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * An implementation of a peer id\n *\n * @example\n *\n * ```TypeScript\n * import { peerIdFromString } from '@libp2p/peer-id'\n * const peer = peerIdFromString('k51qzi5uqu5dkwkqm42v9j9kqcam2jiuvloi16g72i4i4amoo2m8u3ol3mqu6s')\n *\n * console.log(peer.toCID()) // CID(bafzaa...)\n * console.log(peer.toString()) // \"12D3K...\"\n * ```\n */\n\nimport { peerIdSymbol } from '@libp2p/interface'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { identity } from 'multiformats/hashes/identity'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport type { Ed25519PeerId as Ed25519PeerIdInterface, PeerIdType, RSAPeerId as RSAPeerIdInterface, URLPeerId as URLPeerIdInterface, Secp256k1PeerId as Secp256k1PeerIdInterface, PeerId, PublicKey, Ed25519PublicKey, Secp256k1PublicKey, RSAPublicKey } from '@libp2p/interface'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\n\nconst inspect = Symbol.for('nodejs.util.inspect.custom')\n\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72\n\ninterface PeerIdInit <DigestCode extends number> {\n  type: PeerIdType\n  multihash: MultihashDigest<DigestCode>\n}\n\ninterface RSAPeerIdInit {\n  multihash: MultihashDigest<0x12>\n  publicKey?: RSAPublicKey\n}\n\ninterface Ed25519PeerIdInit {\n  multihash: MultihashDigest<0x0>\n  publicKey: Ed25519PublicKey\n}\n\ninterface Secp256k1PeerIdInit {\n  multihash: MultihashDigest<0x0>\n  publicKey: Secp256k1PublicKey\n}\n\nclass PeerIdImpl <DigestCode extends number> {\n  public type: PeerIdType\n  private readonly multihash: MultihashDigest<DigestCode>\n  public readonly publicKey?: PublicKey\n  private string?: string\n\n  constructor (init: PeerIdInit<DigestCode>) {\n    this.type = init.type\n    this.multihash = init.multihash\n\n    // mark string cache as non-enumerable\n    Object.defineProperty(this, 'string', {\n      enumerable: false,\n      writable: true\n    })\n  }\n\n  get [Symbol.toStringTag] (): string {\n    return `PeerId(${this.toString()})`\n  }\n\n  readonly [peerIdSymbol] = true\n\n  toString (): string {\n    if (this.string == null) {\n      this.string = base58btc.encode(this.multihash.bytes).slice(1)\n    }\n\n    return this.string\n  }\n\n  toMultihash (): MultihashDigest<DigestCode> {\n    return this.multihash\n  }\n\n  // return self-describing String representation\n  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n  toCID (): CID<Uint8Array, 0x72, DigestCode, 1> {\n    return CID.createV1(LIBP2P_KEY_CODE, this.multihash)\n  }\n\n  toJSON (): string {\n    return this.toString()\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given PeerId\n   */\n  equals (id?: PeerId | Uint8Array | string): boolean {\n    if (id == null) {\n      return false\n    }\n\n    if (id instanceof Uint8Array) {\n      return uint8ArrayEquals(this.multihash.bytes, id)\n    } else if (typeof id === 'string') {\n      return this.toString() === id\n    } else if (id?.toMultihash()?.bytes != null) {\n      return uint8ArrayEquals(this.multihash.bytes, id.toMultihash().bytes)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /**\n   * Returns PeerId as a human-readable string\n   * https://nodejs.org/api/util.html#utilinspectcustom\n   *\n   * @example\n   * ```TypeScript\n   * import { peerIdFromString } from '@libp2p/peer-id'\n   *\n   * console.info(peerIdFromString('QmFoo'))\n   * // 'PeerId(QmFoo)'\n   * ```\n   */\n  [inspect] (): string {\n    return `PeerId(${this.toString()})`\n  }\n}\n\nexport class RSAPeerId extends PeerIdImpl<0x12> implements RSAPeerIdInterface {\n  public readonly type = 'RSA'\n  public readonly publicKey?: RSAPublicKey\n\n  constructor (init: RSAPeerIdInit) {\n    super({ ...init, type: 'RSA' })\n\n    this.publicKey = init.publicKey\n  }\n}\n\nexport class Ed25519PeerId extends PeerIdImpl<0x0> implements Ed25519PeerIdInterface {\n  public readonly type = 'Ed25519'\n  public readonly publicKey: Ed25519PublicKey\n\n  constructor (init: Ed25519PeerIdInit) {\n    super({ ...init, type: 'Ed25519' })\n\n    this.publicKey = init.publicKey\n  }\n}\n\nexport class Secp256k1PeerId extends PeerIdImpl<0x0> implements Secp256k1PeerIdInterface {\n  public readonly type = 'secp256k1'\n  public readonly publicKey: Secp256k1PublicKey\n\n  constructor (init: Secp256k1PeerIdInit) {\n    super({ ...init, type: 'secp256k1' })\n\n    this.publicKey = init.publicKey\n  }\n}\n\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst TRANSPORT_IPFS_GATEWAY_HTTP_CODE = 0x0920\n\nexport class URLPeerId implements URLPeerIdInterface {\n  readonly type = 'url'\n  readonly multihash: MultihashDigest<0x0>\n  readonly publicKey: undefined\n  readonly url: string\n\n  constructor (url: URL) {\n    this.url = url.toString()\n    this.multihash = identity.digest(uint8ArrayFromString(this.url))\n  }\n\n  [inspect] (): string {\n    return `PeerId(${this.url})`\n  }\n\n  readonly [peerIdSymbol] = true\n\n  toString (): string {\n    return this.toCID().toString()\n  }\n\n  toMultihash (): MultihashDigest<0x0> {\n    return this.multihash\n  }\n\n  toCID (): CID<Uint8Array, 0x0920, 0x0, 1> {\n    return CID.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE, this.toMultihash())\n  }\n\n  toJSON (): string {\n    return this.toString()\n  }\n\n  equals (other?: PeerId | Uint8Array | string): boolean {\n    if (other == null) {\n      return false\n    }\n\n    if (other instanceof Uint8Array) {\n      other = uint8ArrayToString(other)\n    }\n\n    return other.toString() === this.toString()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * An implementation of a peer id\n *\n * @example\n *\n * ```TypeScript\n * import { peerIdFromString } from '@libp2p/peer-id'\n * const peer = peerIdFromString('12D3KooWKnDdG3iXw9eTFijk3EWSunZcFi54Zka4wmtqtt6rPxc8')\n *\n * console.log(peer.toCID()) // CID(bafzaa...)\n * console.log(peer.toString()) // \"12D3K...\"\n * ```\n */\n\nimport { publicKeyFromMultihash } from '@libp2p/crypto/keys'\nimport { InvalidCIDError, InvalidMultihashError, InvalidParametersError, UnsupportedKeyTypeError } from '@libp2p/interface'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { CID, type MultibaseDecoder } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { identity } from 'multiformats/hashes/identity'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { RSAPeerId as RSAPeerIdClass, Ed25519PeerId as Ed25519PeerIdClass, Secp256k1PeerId as Secp256k1PeerIdClass, URLPeerId as URLPeerIdClass } from './peer-id.js'\nimport type { Ed25519PeerId, RSAPeerId, URLPeerId, Secp256k1PeerId, PeerId, PublicKey, Ed25519PublicKey, Secp256k1PublicKey, RSAPublicKey, Ed25519PrivateKey, Secp256k1PrivateKey, RSAPrivateKey, PrivateKey } from '@libp2p/interface'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\n\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72\nconst TRANSPORT_IPFS_GATEWAY_HTTP_CODE = 0x0920\n\nexport function peerIdFromString (str: string, decoder?: MultibaseDecoder<any>): Ed25519PeerId | Secp256k1PeerId | RSAPeerId | URLPeerId {\n  let multihash: MultihashDigest\n\n  if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n    // identity hash ed25519/secp256k1 key or sha2-256 hash of\n    // rsa public key - base58btc encoded either way\n    multihash = Digest.decode(base58btc.decode(`z${str}`))\n  } else if (str.startsWith('k51qzi5uqu5') || str.startsWith('kzwfwjn5ji4') || str.startsWith('k2k4r8') || str.startsWith('bafz')) {\n    // base36 encoded CIDv1 with libp2p-key and identity hash (for ed25519/secp256k1/rsa) or base32 encoded CIDv1 with libp2p-key and identity hash (for ed25519/secp256k1/rsa)\n    return peerIdFromCID(CID.parse(str))\n  } else {\n    if (decoder == null) {\n      throw new InvalidParametersError('Please pass a multibase decoder for strings that do not start with \"1\" or \"Q\"')\n    }\n\n    multihash = Digest.decode(decoder.decode(str))\n  }\n\n  return peerIdFromMultihash(multihash)\n}\n\nexport function peerIdFromPublicKey (publicKey: Ed25519PublicKey): Ed25519PeerId\nexport function peerIdFromPublicKey (publicKey: Secp256k1PublicKey): Secp256k1PeerId\nexport function peerIdFromPublicKey (publicKey: RSAPublicKey): RSAPeerId\nexport function peerIdFromPublicKey (publicKey: PublicKey): PeerId\nexport function peerIdFromPublicKey (publicKey: PublicKey): PeerId {\n  if (publicKey.type === 'Ed25519') {\n    return new Ed25519PeerIdClass({\n      multihash: publicKey.toCID().multihash,\n      publicKey\n    })\n  } else if (publicKey.type === 'secp256k1') {\n    return new Secp256k1PeerIdClass({\n      multihash: publicKey.toCID().multihash,\n      publicKey\n    })\n  } else if (publicKey.type === 'RSA') {\n    return new RSAPeerIdClass({\n      multihash: publicKey.toCID().multihash,\n      publicKey\n    })\n  }\n\n  throw new UnsupportedKeyTypeError()\n}\n\nexport function peerIdFromPrivateKey (privateKey: Ed25519PrivateKey): Ed25519PeerId\nexport function peerIdFromPrivateKey (privateKey: Secp256k1PrivateKey): Secp256k1PeerId\nexport function peerIdFromPrivateKey (privateKey: RSAPrivateKey): RSAPeerId\nexport function peerIdFromPrivateKey (privateKey: PrivateKey): PeerId\nexport function peerIdFromPrivateKey (privateKey: PrivateKey): PeerId {\n  return peerIdFromPublicKey(privateKey.publicKey)\n}\n\nexport function peerIdFromMultihash (multihash: MultihashDigest): PeerId {\n  if (isSha256Multihash(multihash)) {\n    return new RSAPeerIdClass({ multihash })\n  } else if (isIdentityMultihash(multihash)) {\n    try {\n      const publicKey = publicKeyFromMultihash(multihash)\n\n      if (publicKey.type === 'Ed25519') {\n        return new Ed25519PeerIdClass({ multihash, publicKey })\n      } else if (publicKey.type === 'secp256k1') {\n        return new Secp256k1PeerIdClass({ multihash, publicKey })\n      }\n    } catch (err) {\n      // was not Ed or secp key, try URL\n      const url = uint8ArrayToString(multihash.digest)\n\n      return new URLPeerIdClass(new URL(url))\n    }\n  }\n\n  throw new InvalidMultihashError('Supplied PeerID Multihash is invalid')\n}\n\nexport function peerIdFromCID (cid: CID): Ed25519PeerId | Secp256k1PeerId | RSAPeerId | URLPeerId {\n  if (cid?.multihash == null || cid.version == null || (cid.version === 1 && (cid.code !== LIBP2P_KEY_CODE) && cid.code !== TRANSPORT_IPFS_GATEWAY_HTTP_CODE)) {\n    throw new InvalidCIDError('Supplied PeerID CID is invalid')\n  }\n\n  if (cid.code === TRANSPORT_IPFS_GATEWAY_HTTP_CODE) {\n    const url = uint8ArrayToString(cid.multihash.digest)\n\n    return new URLPeerIdClass(new URL(url))\n  }\n\n  return peerIdFromMultihash(cid.multihash)\n}\n\nfunction isIdentityMultihash (multihash: MultihashDigest): multihash is MultihashDigest<0x0> {\n  return multihash.code === identity.code\n}\n\nfunction isSha256Multihash (multihash: MultihashDigest): multihash is MultihashDigest<0x12> {\n  return multihash.code === sha256.code\n}\n", "/**\n * The reported length of the next data message was not a positive integer\n */\nexport class InvalidMessageLengthError extends Error {\n  name = 'InvalidMessageLengthError'\n  code = 'ERR_INVALID_MSG_LENGTH'\n}\n\n/**\n * The reported length of the next data message was larger than the configured\n * max allowable value\n */\nexport class InvalidDataLengthError extends Error {\n  name = 'InvalidDataLengthError'\n  code = 'ERR_MSG_DATA_TOO_LONG'\n}\n\n/**\n * The varint used to specify the length of the next data message contained more\n * bytes than the configured max allowable value\n */\nexport class InvalidDataLengthLengthError extends Error {\n  name = 'InvalidDataLengthLengthError'\n  code = 'ERR_MSG_LENGTH_TOO_LONG'\n}\n", "/**\n * @packageDocumentation\n *\n * This module makes it easy to send and receive length-prefixed byte arrays over streams.\n *\n * @example\n *\n * ```typescript\n * import { lpStream } from 'it-length-prefixed-stream'\n *\n * const stream = lpStream(duplex)\n *\n * // read the next length-prefixed chunk\n * const bytes = await stream.read()\n *\n * // write a length-prefixed chunk\n * await stream.write(Uint8Array.from([0, 1, 2, 3, 4]))\n *\n * // write several chunks, all individually length-prefixed\n * await stream.writeV([\n *   Uint8Array.from([0, 1, 2, 3, 4]),\n *   Uint8Array.from([5, 6, 7, 8, 9])\n * ])\n * ```\n */\nimport { byteStream, type ByteStreamOpts } from 'it-byte-stream'\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { InvalidDataLengthError, InvalidDataLengthLengthError, InvalidMessageLengthError } from './errors.js'\nimport type { AbortOptions } from 'abort-error'\nimport type { Duplex } from 'it-stream-types'\n\nexport interface LengthPrefixedStream <Stream = unknown> {\n  /**\n   * Read the next length-prefixed number of bytes from the stream\n   */\n  read(options?: AbortOptions): Promise<Uint8ArrayList>\n\n  /**\n   * Write the passed bytes to the stream prefixed by their length\n   */\n  write(input: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<void>\n\n  /**\n   * Write passed list of bytes, prefix by their individual lengths to the stream as a single write\n   */\n  writeV(input: Array<Uint8Array | Uint8ArrayList>, options?: AbortOptions): Promise<void>\n\n  /**\n   * Returns the underlying stream\n   */\n  unwrap(): Stream\n}\n\nexport interface LengthPrefixedStreamOpts extends ByteStreamOpts {\n  // encoding opts\n  lengthEncoder (value: number): Uint8ArrayList | Uint8Array\n\n  // decoding opts\n  lengthDecoder (data: Uint8ArrayList): number\n  maxLengthLength: number\n  maxDataLength: number\n}\n\nexport function lpStream <Stream extends Duplex<any, any, any>> (duplex: Stream, opts: Partial<LengthPrefixedStreamOpts> = {}): LengthPrefixedStream<Stream> {\n  const bytes = byteStream(duplex, opts)\n\n  if (opts.maxDataLength != null && opts.maxLengthLength == null) {\n    // if max data length is set but max length length is not, calculate the\n    // max length length needed to encode max data length\n    opts.maxLengthLength = varint.encodingLength(opts.maxDataLength)\n  }\n\n  const decodeLength = opts?.lengthDecoder ?? varint.decode\n  const encodeLength = opts?.lengthEncoder ?? varint.encode\n\n  const W: LengthPrefixedStream<Stream> = {\n    read: async (options?: AbortOptions) => {\n      let dataLength: number = -1\n      const lengthBuffer = new Uint8ArrayList()\n\n      while (true) {\n        // read one byte at a time until we can decode a varint\n        lengthBuffer.append(await bytes.read({\n          ...options,\n          bytes: 1\n        }))\n\n        try {\n          dataLength = decodeLength(lengthBuffer)\n        } catch (err) {\n          if (err instanceof RangeError) {\n            continue\n          }\n\n          throw err\n        }\n\n        if (dataLength < 0) {\n          throw new InvalidMessageLengthError('Invalid message length')\n        }\n\n        if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {\n          throw new InvalidDataLengthLengthError('message length length too long')\n        }\n\n        if (dataLength > -1) {\n          break\n        }\n      }\n\n      if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {\n        throw new InvalidDataLengthError('message length too long')\n      }\n\n      return bytes.read({\n        ...options,\n        bytes: dataLength\n      })\n    },\n    write: async (data, options?: AbortOptions) => {\n      // encode, write\n      await bytes.write(new Uint8ArrayList(encodeLength(data.byteLength), data), options)\n    },\n    writeV: async (data, options?: AbortOptions) => {\n      const list = new Uint8ArrayList(\n        ...data.flatMap(buf => ([encodeLength(buf.byteLength), buf]))\n      )\n\n      // encode, write\n      await bytes.write(list, options)\n    },\n    unwrap: () => {\n      return bytes.unwrap()\n    }\n  }\n\n  return W\n}\n", "/**\n * @packageDocumentation\n *\n * This module makes it easy to send and receive length-prefixed Protobuf encoded\n * messages over streams.\n *\n * @example\n *\n * ```typescript\n * import { pbStream } from 'it-protobuf-stream'\n * import { MessageType } from './src/my-message-type.js'\n *\n * // RequestType and ResponseType have been generate from `.proto` files and have\n * // `.encode` and `.decode` methods for serialization/deserialization\n *\n * const stream = pbStream(duplex)\n *\n * // write a message to the stream\n * stream.write({\n *   foo: 'bar'\n * }, MessageType)\n *\n * // read a message from the stream\n * const res = await stream.read(MessageType)\n * ```\n */\n\nimport { lpStream } from 'it-length-prefixed-stream'\nimport type { AbortOptions } from 'abort-error'\nimport type { LengthPrefixedStreamOpts } from 'it-length-prefixed-stream'\nimport type { Duplex } from 'it-stream-types'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\n/**\n * A protobuf decoder - takes a byte array and returns an object\n */\nexport interface Decoder<T> {\n  (data: Uint8Array | Uint8ArrayList): T\n}\n\n/**\n * A protobuf encoder - takes an object and returns a byte array\n */\nexport interface Encoder<T> {\n  (data: T): Uint8Array\n}\n\n/**\n * Convenience methods for working with protobuf streams\n */\nexport interface ProtobufStream <Stream = unknown> {\n  /**\n   * Read the next length-prefixed byte array from the stream and decode it as the passed protobuf format\n   */\n  read<T>(proto: { decode: Decoder<T> }, options?: AbortOptions): Promise<T>\n\n  /**\n   * Encode the passed object as a protobuf message and write it's length-prefixed bytes to the stream\n   */\n  write<T>(data: T, proto: { encode: Encoder<T> }, options?: AbortOptions): Promise<void>\n\n  /**\n   * Encode the passed objects as protobuf messages and write their length-prefixed bytes to the stream as a single write\n   */\n  writeV<T>(input: T[], proto: { encode: Encoder<T> }, options?: AbortOptions): Promise<void>\n\n  /**\n   * Returns an object with read/write methods for operating on one specific type of protobuf message\n   */\n  pb<T>(proto: { encode: Encoder<T>, decode: Decoder<T> }): MessageStream<T, Stream>\n\n  /**\n   * Returns the underlying stream\n   */\n  unwrap(): Stream\n}\n\n/**\n * A message reader/writer that only uses one type of message\n */\nexport interface MessageStream <T, S = unknown> {\n  /**\n   * Read a message from the stream\n   */\n  read(options?: AbortOptions): Promise<T>\n\n  /**\n   * Write a message to the stream\n   */\n  write(d: T, options?: AbortOptions): Promise<void>\n\n  /**\n   * Write several messages to the stream\n   */\n  writeV(d: T[], options?: AbortOptions): Promise<void>\n\n  /**\n   * Unwrap the underlying protobuf stream\n   */\n  unwrap(): ProtobufStream<S>\n}\n\nexport interface ProtobufStreamOpts extends LengthPrefixedStreamOpts {\n\n}\n\nexport function pbStream <Stream extends Duplex<any, any, any>> (duplex: Stream, opts?: Partial<ProtobufStreamOpts>): ProtobufStream<Stream> {\n  const lp = lpStream(duplex, opts)\n\n  const W: ProtobufStream<Stream> = {\n    read: async (proto, options?: AbortOptions) => {\n      // readLP, decode\n      const value = await lp.read(options)\n\n      return proto.decode(value)\n    },\n    write: async (message, proto, options?: AbortOptions) => {\n      // encode, writeLP\n      await lp.write(proto.encode(message), options)\n    },\n    writeV: async (messages, proto, options?: AbortOptions) => {\n      // encode, writeLP\n      await lp.writeV(messages.map(message => proto.encode(message)), options)\n    },\n    pb: (proto) => {\n      return {\n        read: async (options) => W.read(proto, options),\n        write: async (d, options) => W.write(d, proto, options),\n        writeV: async (d, options) => W.writeV(d, proto, options),\n        unwrap: () => W\n      }\n    },\n    unwrap: () => {\n      return lp.unwrap()\n    }\n  }\n\n  return W\n}\n"],
  "mappings": "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",
  "names": ["_a", "LIBP2P_KEY_CODE", "TRANSPORT_IPFS_GATEWAY_HTTP_CODE", "LIBP2P_KEY_CODE", "TRANSPORT_IPFS_GATEWAY_HTTP_CODE", "decode"]
}
