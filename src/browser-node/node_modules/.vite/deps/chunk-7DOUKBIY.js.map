{
  "version": 3,
  "sources": ["../../.pnpm/interface-datastore@8.3.1/node_modules/interface-datastore/src/key.ts", "../../.pnpm/p-timeout@6.1.4/node_modules/p-timeout/index.js", "../../.pnpm/any-signal@4.1.1/node_modules/any-signal/src/index.ts", "../../.pnpm/race-event@1.3.0/node_modules/race-event/src/index.ts"],
  "sourcesContent": ["import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { type SupportedEncodings, toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nconst pathSepS = '/'\nconst pathSepB = new TextEncoder().encode(pathSepS)\nconst pathSep = pathSepB[0]\n\n/**\n * A Key represents the unique identifier of an object.\n * Our Key scheme is inspired by file systems and Google App Engine key model.\n * Keys are meant to be unique across a system. Keys are hierarchical,\n * incorporating more and more specific namespaces. Thus keys can be deemed\n * 'children' or 'ancestors' of other keys:\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n * Also, every namespace can be parametrized to embed relevant object\n * information. For example, the Key `name` (most specific namespace) could\n * include the object type:\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n *\n */\nexport class Key {\n  private _buf: Uint8Array\n\n  /**\n   * @param {string | Uint8Array} s\n   * @param {boolean} [clean]\n   */\n  constructor (s: string | Uint8Array, clean?: boolean) {\n    if (typeof s === 'string') {\n      this._buf = uint8ArrayFromString(s)\n    } else if (s instanceof Uint8Array) {\n      this._buf = s\n    } else {\n      throw new Error('Invalid key, should be String of Uint8Array')\n    }\n\n    if (clean == null) {\n      clean = true\n    }\n\n    if (clean) {\n      this.clean()\n    }\n\n    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {\n      throw new Error('Invalid key')\n    }\n  }\n\n  /**\n   * Convert to the string representation\n   *\n   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.\n   * @returns {string}\n   */\n  toString (encoding: SupportedEncodings = 'utf8'): string {\n    return uint8ArrayToString(this._buf, encoding)\n  }\n\n  /**\n   * Return the Uint8Array representation of the key\n   *\n   * @returns {Uint8Array}\n   */\n  uint8Array (): Uint8Array {\n    return this._buf\n  }\n\n  /**\n   * Return string representation of the key\n   *\n   * @returns {string}\n   */\n  get [Symbol.toStringTag] (): string {\n    return `Key(${this.toString()})`\n  }\n\n  /**\n   * Constructs a key out of a namespace array.\n   *\n   * @param {Array<string>} list - The array of namespaces\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * Key.withNamespaces(['one', 'two'])\n   * // => Key('/one/two')\n   * ```\n   */\n  static withNamespaces (list: string[]): Key {\n    return new Key(list.join(pathSepS))\n  }\n\n  /**\n   * Returns a randomly (uuid) generated key.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * Key.random()\n   * // => Key('/344502982398')\n   * ```\n   */\n  static random (): Key {\n    return new Key(Math.random().toString().substring(2))\n  }\n\n  /**\n   * @param {*} other\n   */\n  static asKey (other: any): Key | null {\n    if (other instanceof Uint8Array || typeof other === 'string') {\n      // we can create a key from this\n      return new Key(other)\n    }\n\n    if (typeof other.uint8Array === 'function') {\n      // this is an older version or may have crossed the esm/cjs boundary\n      return new Key(other.uint8Array())\n    }\n\n    return null\n  }\n\n  /**\n   * Cleanup the current key\n   *\n   * @returns {void}\n   */\n  clean (): void {\n    if (this._buf == null || this._buf.byteLength === 0) {\n      this._buf = pathSepB\n    }\n\n    if (this._buf[0] !== pathSep) {\n      const bytes = new Uint8Array(this._buf.byteLength + 1)\n      bytes.fill(pathSep, 0, 1)\n      bytes.set(this._buf, 1)\n      this._buf = bytes\n    }\n\n    // normalize does not remove trailing slashes\n    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {\n      this._buf = this._buf.subarray(0, -1)\n    }\n  }\n\n  /**\n   * Check if the given key is sorted lower than ourself.\n   *\n   * @param {Key} key - The other Key to check against\n   * @returns {boolean}\n   */\n  less (key: Key): boolean {\n    const list1 = this.list()\n    const list2 = key.list()\n\n    for (let i = 0; i < list1.length; i++) {\n      if (list2.length < i + 1) {\n        return false\n      }\n\n      const c1 = list1[i]\n      const c2 = list2[i]\n\n      if (c1 < c2) {\n        return true\n      } else if (c1 > c2) {\n        return false\n      }\n    }\n\n    return list1.length < list2.length\n  }\n\n  /**\n   * Returns the key with all parts in reversed order.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()\n   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')\n   * ```\n   */\n  reverse (): Key {\n    return Key.withNamespaces(this.list().slice().reverse())\n  }\n\n  /**\n   * Returns the `namespaces` making up this Key.\n   *\n   * @returns {Array<string>}\n   */\n  namespaces (): string[] {\n    return this.list()\n  }\n\n  /** Returns the \"base\" namespace of this key.\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()\n   * // => 'Actor:JohnCleese'\n   * ```\n   */\n  baseNamespace (): string {\n    const ns = this.namespaces()\n    return ns[ns.length - 1]\n  }\n\n  /**\n   * Returns the `list` representation of this key.\n   *\n   * @returns {Array<string>}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()\n   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']\n   * ```\n   */\n  list (): string[] {\n    return this.toString().split(pathSepS).slice(1)\n  }\n\n  /**\n   * Returns the \"type\" of this key (value of last namespace).\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()\n   * // => 'Actor'\n   * ```\n   */\n  type (): string {\n    return namespaceType(this.baseNamespace())\n  }\n\n  /**\n   * Returns the \"name\" of this key (field of last namespace).\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()\n   * // => 'JohnCleese'\n   * ```\n   */\n  name (): string {\n    return namespaceValue(this.baseNamespace())\n  }\n\n  /**\n   * Returns an \"instance\" of this type key (appends value to namespace).\n   *\n   * @param {string} s - The string to append.\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')\n   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n   * ```\n   */\n  instance (s: string): Key {\n    return new Key(this.toString() + ':' + s)\n  }\n\n  /**\n   * Returns the \"path\" of this key (parent + type).\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()\n   * // => Key('/Comedy/MontyPython/Actor')\n   * ```\n   */\n  path (): Key {\n    let p = this.parent().toString()\n    if (!p.endsWith(pathSepS)) {\n      p += pathSepS\n    }\n    p += this.type()\n    return new Key(p)\n  }\n\n  /**\n   * Returns the `parent` Key of this Key.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key(\"/Comedy/MontyPython/Actor:JohnCleese\").parent()\n   * // => Key(\"/Comedy/MontyPython\")\n   * ```\n   */\n  parent (): Key {\n    const list = this.list()\n    if (list.length === 1) {\n      return new Key(pathSepS)\n    }\n\n    return new Key(list.slice(0, -1).join(pathSepS))\n  }\n\n  /**\n   * Returns the `child` Key of this Key.\n   *\n   * @param {Key} key - The child Key to add\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))\n   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n   * ```\n   */\n  child (key: Key): Key {\n    if (this.toString() === pathSepS) {\n      return key\n    } else if (key.toString() === pathSepS) {\n      return this\n    }\n\n    return new Key(this.toString() + key.toString(), false)\n  }\n\n  /**\n   * Returns whether this key is a prefix of `other`\n   *\n   * @param {Key} other - The other key to test against\n   * @returns {boolean}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')\n   * // => true\n   * ```\n   */\n  isAncestorOf (other: Key): boolean {\n    if (other.toString() === this.toString()) {\n      return false\n    }\n\n    return other.toString().startsWith(this.toString())\n  }\n\n  /**\n   * Returns whether this key is a contains another as prefix.\n   *\n   * @param {Key} other - The other Key to test against\n   * @returns {boolean}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')\n   * // => true\n   * ```\n   */\n  isDecendantOf (other: Key): boolean {\n    if (other.toString() === this.toString()) {\n      return false\n    }\n\n    return this.toString().startsWith(other.toString())\n  }\n\n  /**\n   * Checks if this key has only one namespace.\n   *\n   * @returns {boolean}\n   */\n  isTopLevel (): boolean {\n    return this.list().length === 1\n  }\n\n  /**\n   * Concats one or more Keys into one new Key.\n   *\n   * @param {Array<Key>} keys - The array of keys to concatenate\n   * @returns {Key}\n   */\n  concat (...keys: Key[]): Key {\n    return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map(key => key.namespaces()))])\n  }\n}\n\n/**\n * The first component of a namespace. `foo` in `foo:bar`\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceType (ns: string): string {\n  const parts = ns.split(':')\n  if (parts.length < 2) {\n    return ''\n  }\n  return parts.slice(0, -1).join(':')\n}\n\n/**\n * The last component of a namespace, `baz` in `foo:bar:baz`.\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceValue (ns: string): string {\n  const parts = ns.split(':')\n  return parts[parts.length - 1]\n}\n\n/**\n * Flatten array of arrays (only one level)\n *\n * @template T\n * @param {Array<any>} arr\n * @returns {T[]}\n */\nfunction flatten (arr: any[]): string[] {\n  return ([]).concat(...arr)\n}\n", "export class TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\n/**\nAn error to be thrown when the request is aborted by AbortController.\nDOMException is thrown instead of this Error when DOMException is available.\n*/\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\n/**\nTODO: Remove AbortError and just throw DOMException when targeting Node 18.\n*/\nconst getDOMException = errorMessage => globalThis.DOMException === undefined\n\t? new AbortError(errorMessage)\n\t: new DOMException(errorMessage);\n\n/**\nTODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n*/\nconst getAbortedReason = signal => {\n\tconst reason = signal.reason === undefined\n\t\t? getDOMException('This operation was aborted.')\n\t\t: signal.reason;\n\n\treturn reason instanceof Error ? reason : getDOMException(reason);\n};\n\nexport default function pTimeout(promise, options) {\n\tconst {\n\t\tmilliseconds,\n\t\tfallback,\n\t\tmessage,\n\t\tcustomTimers = {setTimeout, clearTimeout},\n\t} = options;\n\n\tlet timer;\n\tlet abortHandler;\n\n\tconst wrappedPromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``);\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\tconst {signal} = options;\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t}\n\n\t\t\tabortHandler = () => {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t};\n\n\t\t\tsignal.addEventListener('abort', abortHandler, {once: true});\n\t\t}\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\tpromise.then(resolve, reject);\n\t\t\treturn;\n\t\t}\n\n\t\t// We create the error outside of `setTimeout` to preserve the stack trace.\n\t\tconst timeoutError = new TimeoutError();\n\n\t\ttimer = customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (fallback) {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\tif (message === false) {\n\t\t\t\tresolve();\n\t\t\t} else if (message instanceof Error) {\n\t\t\t\treject(message);\n\t\t\t} else {\n\t\t\t\ttimeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\t\treject(timeoutError);\n\t\t\t}\n\t\t}, milliseconds);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tresolve(await promise);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t})();\n\t});\n\n\tconst cancelablePromise = wrappedPromise.finally(() => {\n\t\tcancelablePromise.clear();\n\t\tif (abortHandler && options.signal) {\n\t\t\toptions.signal.removeEventListener('abort', abortHandler);\n\t\t}\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\tcustomTimers.clearTimeout.call(undefined, timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n", "\nexport interface ClearableSignal extends AbortSignal {\n  clear: () => void\n}\n\n/**\n * Takes an array of AbortSignals and returns a single signal.\n * If any signals are aborted, the returned signal will be aborted.\n */\nexport function anySignal (signals: Array<AbortSignal | undefined | null>): ClearableSignal {\n  const controller = new globalThis.AbortController()\n\n  function onAbort (): void {\n    controller.abort()\n\n    for (const signal of signals) {\n      if (signal?.removeEventListener != null) {\n        signal.removeEventListener('abort', onAbort)\n      }\n    }\n  }\n\n  for (const signal of signals) {\n    if (signal?.aborted === true) {\n      onAbort()\n      break\n    }\n\n    if (signal?.addEventListener != null) {\n      signal.addEventListener('abort', onAbort)\n    }\n  }\n\n  function clear (): void {\n    for (const signal of signals) {\n      if (signal?.removeEventListener != null) {\n        signal.removeEventListener('abort', onAbort)\n      }\n    }\n  }\n\n  const signal = controller.signal as ClearableSignal\n  signal.clear = clear\n\n  return signal\n}\n", "/**\n * @packageDocumentation\n *\n * Race an event against an AbortSignal, taking care to remove any event\n * listeners that were added.\n *\n * @example Getting started\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * setTimeout(() => {\n *   // too late\n *   emitter.dispatchEvent(new CustomEvent('event'))\n * }, 1000)\n *\n * // throws an AbortError\n * const resolve = await raceEvent(emitter, 'event', controller.signal)\n * ```\n *\n * @example Aborting the promise with an error event\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   emitter.dispatchEvent(new CustomEvent('failure', {\n *     detail: new Error('Oh no!')\n *   }))\n * }, 1000)\n *\n * // throws 'Oh no!' error\n * const resolve = await raceEvent(emitter, 'success', AbortSignal.timeout(5000), {\n *   errorEvent: 'failure'\n * })\n * ```\n *\n * @example Customising the thrown AbortError\n *\n * The error message and `.code` property of the thrown `AbortError` can be\n * specified by passing options:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * // throws a Error: Oh no!\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   errorMessage: 'Oh no!',\n *   errorCode: 'ERR_OH_NO'\n * })\n * ```\n *\n * @example Only resolving on specific events\n *\n * Where multiple events with the same type are emitted, a `filter` function can\n * be passed to only resolve on one of them:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * // throws a Error: Oh no!\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   filter: (evt: Event) => {\n *     return evt.detail.foo === 'bar'\n *   }\n * })\n * ```\n *\n * @example Terminating early by throwing from the filter\n *\n * You can cause listening for the event to cease and all event listeners to be\n * removed by throwing from the filter:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * // throws Error: Cannot continue\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   filter: (evt) => {\n *     if (...reasons) {\n *       throw new Error('Cannot continue')\n *     }\n *\n *     return true\n *   }\n * })\n * ```\n */\n\n/**\n * An abort error class that extends error\n */\nexport class AbortError extends Error {\n  public type: string\n  public code: string | string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.name = 'AbortError'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface RaceEventOptions<T> {\n  /**\n   * The message for the error thrown if the signal aborts\n   */\n  errorMessage?: string\n\n  /**\n   * The code for the error thrown if the signal aborts\n   */\n  errorCode?: string\n\n  /**\n   * The name of an event emitted on the emitter that should cause the returned\n   * promise to reject. The rejection reason will be the `.detail` field of the\n   * event.\n   */\n  errorEvent?: string\n\n  /**\n   * When multiple events with the same name may be emitted, pass a filter\n   * function here to allow ignoring ones that should not cause the returned\n   * promise to resolve.\n   */\n  filter?(evt: T): boolean\n}\n\n/**\n * Race a promise against an abort signal\n */\nexport async function raceEvent <T> (emitter: EventTarget, eventName: string, signal?: AbortSignal, opts?: RaceEventOptions<T>): Promise<T> {\n  // create the error here so we have more context in the stack trace\n  const error = new AbortError(opts?.errorMessage, opts?.errorCode)\n\n  if (signal?.aborted === true) {\n    return Promise.reject(error)\n  }\n\n  return new Promise((resolve, reject) => {\n    function removeListeners (): void {\n      signal?.removeEventListener('abort', abortListener)\n      emitter.removeEventListener(eventName, eventListener)\n\n      if (opts?.errorEvent != null) {\n        emitter.removeEventListener(opts.errorEvent, errorEventListener)\n      }\n    }\n\n    const eventListener = (evt: any): void => {\n      try {\n        if (opts?.filter?.(evt) === false) {\n          return\n        }\n      } catch (err: any) {\n        removeListeners()\n        reject(err)\n        return\n      }\n\n      removeListeners()\n      resolve(evt)\n    }\n\n    const errorEventListener = (evt: any): void => {\n      removeListeners()\n      reject(evt.detail)\n    }\n\n    const abortListener = (): void => {\n      removeListeners()\n      reject(error)\n    }\n\n    signal?.addEventListener('abort', abortListener)\n    emitter.addEventListener(eventName, eventListener)\n\n    if (opts?.errorEvent != null) {\n      emitter.addEventListener(opts.errorEvent, errorEventListener)\n    }\n  })\n}\n"],
  "mappings": "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",
  "names": ["signal", "AbortError"]
}
