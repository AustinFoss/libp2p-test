import {
  CustomProgressEvent
} from "./chunk-KFVCPFUY.js";
import {
  WebTransport
} from "./chunk-M775XTRV.js";
import {
  noise
} from "./chunk-ZW47BPP2.js";
import "./chunk-73FYJK3H.js";
import {
  peerIdFromString
} from "./chunk-5LMJJA6Q.js";
import "./chunk-VLAMNGZA.js";
import "./chunk-4WIHOBZE.js";
import {
  AbstractStream
} from "./chunk-RLS4S253.js";
import "./chunk-RIADKXEZ.js";
import {
  InvalidCryptoExchangeError,
  InvalidMultiaddrError,
  InvalidParametersError,
  serviceCapabilities,
  transportSymbol
} from "./chunk-OB37O552.js";
import {
  raceSignal
} from "./chunk-2B23ONA5.js";
import {
  Uint8ArrayList
} from "./chunk-BYS5BAPP.js";
import {
  getProtocol
} from "./chunk-2ZAVKNE3.js";
import {
  bases,
  digest_exports
} from "./chunk-AV7VJIQH.js";
import {
  equals
} from "./chunk-PM7HCL6E.js";
import {
  __publicField
} from "./chunk-WOOG5QLI.js";

// node_modules/.pnpm/@libp2p+webtransport@5.0.37/node_modules/@libp2p/webtransport/dist/src/constants.js
var MAX_INBOUND_STREAMS = 1e3;

// node_modules/.pnpm/@libp2p+webtransport@5.0.37/node_modules/@libp2p/webtransport/dist/src/listener.browser.js
function createListener(options) {
  throw new Error("Not implemented");
}

// node_modules/.pnpm/@libp2p+webtransport@5.0.37/node_modules/@libp2p/webtransport/dist/src/stream.js
var WebTransportStream = class extends AbstractStream {
  constructor(init) {
    super(init);
    __publicField(this, "writer");
    __publicField(this, "reader");
    this.writer = init.bidiStream.writable.getWriter();
    this.reader = init.bidiStream.readable.getReader();
    Promise.resolve().then(async () => {
      while (true) {
        const result = await this.reader.read();
        if (result.done) {
          init.log("remote closed write");
          return;
        }
        if (result.value != null) {
          this.sourcePush(new Uint8ArrayList(result.value));
        }
      }
    }).catch((err) => {
      init.log.error("error reading from stream", err);
      this.abort(err);
    }).finally(() => {
      this.remoteCloseWrite();
    });
    void this.writer.closed.then(() => {
      init.log("writer closed");
    }).catch((err) => {
      init.log("writer close promise rejected", err);
    }).finally(() => {
      this.remoteCloseRead();
    });
  }
  sendNewStream(options) {
  }
  async sendData(buf, options) {
    for await (const chunk of buf) {
      this.log("sendData waiting for writer to be ready");
      await raceSignal(this.writer.ready, options == null ? void 0 : options.signal);
      this.writer.write(chunk).catch((err) => {
        this.log.error("error sending stream data", err);
      });
    }
  }
  async sendReset(options) {
    this.log("sendReset aborting writer");
    await raceSignal(this.writer.abort(), options == null ? void 0 : options.signal);
    this.log("sendReset aborted writer");
  }
  async sendCloseWrite(options) {
    this.log("sendCloseWrite closing writer");
    await raceSignal(this.writer.close(), options == null ? void 0 : options.signal);
    this.log("sendCloseWrite closed writer");
  }
  async sendCloseRead(options) {
    this.log("sendCloseRead cancelling reader");
    await raceSignal(this.reader.cancel(), options == null ? void 0 : options.signal);
    this.log("sendCloseRead cancelled reader");
  }
};
async function webtransportBiDiStreamToStream(bidiStream, streamId, direction, activeStreams, onStreamEnd, logger) {
  const log = logger.forComponent(`libp2p:webtransport:stream:${direction}:${streamId}`);
  const stream = new WebTransportStream({
    bidiStream,
    id: streamId,
    direction,
    log,
    onEnd: () => {
      const index = activeStreams.findIndex((s) => s === stream);
      if (index !== -1) {
        activeStreams.splice(index, 1);
      }
      onStreamEnd == null ? void 0 : onStreamEnd(stream);
    }
  });
  return stream;
}

// node_modules/.pnpm/@libp2p+webtransport@5.0.37/node_modules/@libp2p/webtransport/dist/src/utils/inert-duplex.js
function inertDuplex() {
  return {
    source: {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            return new Promise(() => {
            });
          }
        };
      }
    },
    sink: async (source) => {
      return new Promise(() => {
      });
    }
  };
}

// node_modules/.pnpm/@libp2p+webtransport@5.0.37/node_modules/@libp2p/webtransport/dist/src/muxer.js
function webtransportMuxer(wt, reader, logger, config) {
  let streamIDCounter = 0;
  const log = logger.forComponent("libp2p:webtransport:muxer");
  return {
    protocol: "webtransport",
    createStreamMuxer: (init) => {
      if (typeof init === "function") {
        init = { onIncomingStream: init };
      }
      const activeStreams = [];
      Promise.resolve().then(async () => {
        var _a2;
        while (true) {
          const { done, value: wtStream } = await reader.read();
          if (done) {
            break;
          }
          if (activeStreams.length >= config.maxInboundStreams) {
            log(`too many inbound streams open - ${activeStreams.length}/${config.maxInboundStreams}, closing new incoming stream`);
            wtStream.writable.close().catch((err) => {
              log.error(`failed to close inbound stream that crossed our maxInboundStream limit: ${err.message}`);
            });
            wtStream.readable.cancel().catch((err) => {
              log.error(`failed to close inbound stream that crossed our maxInboundStream limit: ${err.message}`);
            });
          } else {
            const stream = await webtransportBiDiStreamToStream(wtStream, String(streamIDCounter++), "inbound", activeStreams, init == null ? void 0 : init.onStreamEnd, logger);
            activeStreams.push(stream);
            (_a2 = init == null ? void 0 : init.onIncomingStream) == null ? void 0 : _a2.call(init, stream);
          }
        }
      }).catch((err) => {
        log.error("could not create a new stream", err);
      });
      const muxer = {
        protocol: "webtransport",
        streams: activeStreams,
        newStream: async (name) => {
          log("new outgoing stream", name);
          const wtStream = await wt.createBidirectionalStream();
          const stream = await webtransportBiDiStreamToStream(wtStream, String(streamIDCounter++), (init == null ? void 0 : init.direction) ?? "outbound", activeStreams, init == null ? void 0 : init.onStreamEnd, logger);
          activeStreams.push(stream);
          return stream;
        },
        /**
         * Close all tracked streams and stop the muxer
         */
        close: async () => {
          log("closing webtransport muxer gracefully");
          try {
            wt.close();
          } catch (err) {
            muxer.abort(err);
          }
        },
        /**
         * Abort all tracked streams and stop the muxer
         */
        abort: (err) => {
          log("closing webtransport muxer with err:", err);
          try {
            wt.close();
          } catch (err2) {
            log.error("webtransport session threw error during close", err2);
          }
        },
        // This stream muxer is webtransport native. Therefore it doesn't plug in with any other duplex.
        ...inertDuplex()
      };
      return muxer;
    }
  };
}

// node_modules/.pnpm/@libp2p+webtransport@5.0.37/node_modules/@libp2p/webtransport/dist/src/utils/is-subset.js
function isSubset(set, maybeSubset) {
  const intersection = maybeSubset.filter((byteArray) => {
    return Boolean(set.find((otherByteArray) => equals(byteArray, otherByteArray)));
  });
  return intersection.length === maybeSubset.length;
}

// node_modules/.pnpm/@libp2p+webtransport@5.0.37/node_modules/@libp2p/webtransport/dist/src/utils/parse-multiaddr.js
var multibaseDecoder = Object.values(bases).map((b) => b.decoder).reduce((d, b) => d.or(b));
function decodeCerthashStr(s) {
  return digest_exports.decode(multibaseDecoder.decode(s));
}
function parseMultiaddr(ma) {
  if (!WebTransport.matches(ma)) {
    throw new InvalidMultiaddrError("Invalid multiaddr, was not a WebTransport address");
  }
  const parts = ma.stringTuples();
  const certhashes = parts.filter(([name, _]) => name === getProtocol("certhash").code).map(([_, value]) => decodeCerthashStr(value ?? ""));
  const remotePeer = parts.filter(([name, _]) => name === getProtocol("p2p").code).map(([_, value]) => peerIdFromString(value ?? ""))[0];
  const opts = ma.toOptions();
  let host = opts.host;
  if (opts.family === 6 && (host == null ? void 0 : host.includes(":"))) {
    host = `[${host}]`;
  }
  return {
    // All webtransport urls are https
    url: `https://${host}:${opts.port}`,
    certhashes,
    remotePeer
  };
}

// node_modules/.pnpm/@libp2p+webtransport@5.0.37/node_modules/@libp2p/webtransport/dist/src/webtransport.browser.js
var webtransport_browser_default = globalThis.WebTransport;

// node_modules/.pnpm/@libp2p+webtransport@5.0.37/node_modules/@libp2p/webtransport/dist/src/index.js
var _a, _b, _c;
_c = Symbol.toStringTag, _b = transportSymbol, _a = serviceCapabilities;
var WebTransportTransport = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "components");
    __publicField(this, "config");
    __publicField(this, "metrics");
    __publicField(this, _c, "@libp2p/webtransport");
    __publicField(this, _b, true);
    __publicField(this, _a, [
      "@libp2p/transport"
    ]);
    this.log = components.logger.forComponent("libp2p:webtransport");
    this.components = components;
    this.config = {
      ...init,
      maxInboundStreams: init.maxInboundStreams ?? MAX_INBOUND_STREAMS,
      certificates: init.certificates ?? []
    };
    if (components.metrics != null) {
      this.metrics = {
        dialerEvents: components.metrics.registerCounterGroup("libp2p_webtransport_dialer_events_total", {
          label: "event",
          help: "Total count of WebTransport dialer events by type"
        })
      };
    }
  }
  async dial(ma, options) {
    var _a2, _b2, _c2, _d, _e;
    options.signal.throwIfAborted();
    this.log("dialing %s", ma);
    options = options ?? {};
    const { url, certhashes, remotePeer } = parseMultiaddr(ma);
    let abortListener;
    let maConn;
    let cleanUpWTSession = () => {
    };
    let closed = false;
    let ready = false;
    let authenticated = false;
    try {
      (_a2 = this.metrics) == null ? void 0 : _a2.dialerEvents.increment({ pending: true });
      const wt = new webtransport_browser_default(`${url}/.well-known/libp2p-webtransport?type=noise`, {
        serverCertificateHashes: certhashes.map((certhash) => ({
          algorithm: "sha-256",
          value: certhash.digest
        }))
      });
      cleanUpWTSession = (metric) => {
        var _a3;
        if (closed) {
          return;
        }
        try {
          (_a3 = this.metrics) == null ? void 0 : _a3.dialerEvents.increment({ [metric]: true });
          wt.close();
        } catch (err) {
          this.log.error("error closing wt session", err);
        } finally {
          if (maConn != null) {
            maConn.timeline.close = Date.now();
          }
          closed = true;
        }
      };
      abortListener = () => {
        if (ready) {
          cleanUpWTSession("noise_timeout");
        } else {
          cleanUpWTSession("ready_timeout");
        }
      };
      options.signal.addEventListener("abort", abortListener, {
        once: true
      });
      this.log("wait for session to be ready");
      (_b2 = options.onProgress) == null ? void 0 : _b2.call(options, new CustomProgressEvent("webtransport:wait-for-session"));
      await Promise.race([
        wt.closed,
        wt.ready
      ]);
      this.log("session became ready");
      ready = true;
      (_c2 = this.metrics) == null ? void 0 : _c2.dialerEvents.increment({ ready: true });
      wt.closed.catch((err) => {
        this.log.error("error on remote wt session close", err);
      }).finally(() => {
        cleanUpWTSession("remote_close");
      });
      authenticated = await raceSignal(this.authenticateWebTransport({ wt, remotePeer, certhashes, ...options }), options.signal);
      if (!authenticated) {
        throw new InvalidCryptoExchangeError("Failed to authenticate webtransport");
      }
      (_d = this.metrics) == null ? void 0 : _d.dialerEvents.increment({ open: true });
      maConn = {
        close: async () => {
          this.log("closing webtransport");
          cleanUpWTSession("close");
        },
        abort: (err) => {
          this.log("aborting webtransport due to passed err", err);
          cleanUpWTSession("abort");
        },
        remoteAddr: ma,
        timeline: {
          open: Date.now()
        },
        log: this.components.logger.forComponent("libp2p:webtransport:maconn"),
        // This connection is never used directly since webtransport supports native streams.
        ...inertDuplex()
      };
      return await options.upgrader.upgradeOutbound(maConn, {
        ...options,
        skipEncryption: true,
        muxerFactory: webtransportMuxer(wt, wt.incomingBidirectionalStreams.getReader(), this.components.logger, this.config),
        skipProtection: true
      });
    } catch (err) {
      this.log.error("caught wt session err", err);
      if (authenticated) {
        cleanUpWTSession("upgrade_error");
      } else if (ready) {
        cleanUpWTSession("noise_error");
      } else {
        cleanUpWTSession("ready_error");
      }
      throw err;
    } finally {
      if (abortListener != null) {
        (_e = options.signal) == null ? void 0 : _e.removeEventListener("abort", abortListener);
      }
    }
  }
  async authenticateWebTransport({ wt, remotePeer, certhashes, onProgress, signal }) {
    signal == null ? void 0 : signal.throwIfAborted();
    onProgress == null ? void 0 : onProgress(new CustomProgressEvent("webtransport:open-authentication-stream"));
    const stream = await wt.createBidirectionalStream();
    const writer = stream.writable.getWriter();
    const reader = stream.readable.getReader();
    const duplex = {
      source: async function* () {
        while (true) {
          const val = await reader.read();
          if (val.value != null) {
            yield val.value;
          }
          if (val.done) {
            break;
          }
        }
      }(),
      sink: async (source) => {
        for await (const chunk of source) {
          await raceSignal(writer.ready, signal);
          const buf = chunk instanceof Uint8Array ? chunk : chunk.subarray();
          writer.write(buf).catch((err) => {
            this.log.error("could not write chunk during authentication of WebTransport stream", err);
          });
        }
      }
    };
    const n = noise()(this.components);
    onProgress == null ? void 0 : onProgress(new CustomProgressEvent("webtransport:secure-outbound-connection"));
    const { remoteExtensions } = await n.secureOutbound(duplex, {
      signal,
      remotePeer
    });
    onProgress == null ? void 0 : onProgress(new CustomProgressEvent("webtransport:close-authentication-stream"));
    writer.close().catch((err) => {
      this.log.error(`Failed to close authentication stream writer: ${err.message}`);
    });
    reader.cancel().catch((err) => {
      this.log.error(`Failed to close authentication stream reader: ${err.message}`);
    });
    if (!isSubset((remoteExtensions == null ? void 0 : remoteExtensions.webtransportCerthashes) ?? [], certhashes.map((ch) => ch.bytes))) {
      throw new InvalidParametersError("Our certhashes are not a subset of the remote's reported certhashes");
    }
    return true;
  }
  createListener(options) {
    return createListener(this.components, {
      ...options,
      certificates: this.config.certificates,
      maxInboundStreams: this.config.maxInboundStreams
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can listen on
   */
  listenFilter() {
    return [];
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    if (globalThis.WebTransport == null) {
      return [];
    }
    return multiaddrs.filter((ma) => {
      if (!WebTransport.exactMatch(ma)) {
        return false;
      }
      const { url, certhashes } = parseMultiaddr(ma);
      return url != null && certhashes.length > 0;
    });
  }
};
function webTransport(init = {}) {
  return (components) => new WebTransportTransport(components, init);
}
export {
  webTransport
};
/*! Bundled license information:

@libp2p/webtransport/dist/src/muxer.js:
  (*! TODO unclear how to add backpressure here? *)
*/
//# sourceMappingURL=@libp2p_webtransport.js.map
