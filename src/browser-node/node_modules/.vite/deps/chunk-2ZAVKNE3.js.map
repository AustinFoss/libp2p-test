{
  "version": 3,
  "sources": ["../../.pnpm/@chainsafe+is-ip@2.1.0/node_modules/@chainsafe/is-ip/src/parser.ts", "../../.pnpm/@chainsafe+is-ip@2.1.0/node_modules/@chainsafe/is-ip/src/parse.ts", "../../.pnpm/@chainsafe+netmask@2.0.0/node_modules/@chainsafe/netmask/src/util.ts", "../../.pnpm/@chainsafe+netmask@2.0.0/node_modules/@chainsafe/netmask/src/ip.ts", "../../.pnpm/@chainsafe+netmask@2.0.0/node_modules/@chainsafe/netmask/src/cidr.ts", "../../.pnpm/@chainsafe+netmask@2.0.0/node_modules/@chainsafe/netmask/src/ipnet.ts", "../../.pnpm/@chainsafe+netmask@2.0.0/node_modules/@chainsafe/netmask/src/index.ts", "../../.pnpm/@chainsafe+is-ip@2.1.0/node_modules/@chainsafe/is-ip/src/is-ip.ts", "../../.pnpm/@multiformats+multiaddr@12.4.0/node_modules/@multiformats/multiaddr/src/ip.ts", "../../.pnpm/@multiformats+multiaddr@12.4.0/node_modules/@multiformats/multiaddr/src/protocols-table.ts", "../../.pnpm/@multiformats+multiaddr@12.4.0/node_modules/@multiformats/multiaddr/src/convert.ts", "../../.pnpm/@multiformats+multiaddr@12.4.0/node_modules/@multiformats/multiaddr/src/codec.ts", "../../.pnpm/@multiformats+multiaddr@12.4.0/node_modules/@multiformats/multiaddr/src/multiaddr.ts", "../../.pnpm/@multiformats+multiaddr@12.4.0/node_modules/@multiformats/multiaddr/src/filter/multiaddr-filter.ts", "../../.pnpm/@multiformats+multiaddr@12.4.0/node_modules/@multiformats/multiaddr/src/index.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/no-unsafe-return */\n\n// Heavily inspired by https://doc.rust-lang.org/src/std/net/parser.rs.html\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Fn = (...foo: any) => any;\n\nexport class Parser {\n  private index = 0;\n  private input = \"\";\n\n  new(input: string): this {\n    this.index = 0;\n    this.input = input;\n    return this;\n  }\n\n  /** Run a parser, and restore the pre-parse state if it fails. */\n  readAtomically<T extends Fn>(fn: T): ReturnType<T> {\n    const index = this.index;\n    const result = fn();\n    if (result === undefined) {\n      this.index = index;\n    }\n    return result;\n  }\n\n  /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */\n  parseWith<T extends Fn>(fn: T): ReturnType<T> | undefined {\n    const result = fn();\n    if (this.index !== this.input.length) {\n      return undefined;\n    }\n    return result;\n  }\n\n  /** Peek the next character from the input */\n  peekChar(): string | undefined {\n    if (this.index >= this.input.length) {\n      return undefined;\n    }\n    return this.input[this.index];\n  }\n\n  /** Read the next character from the input */\n  readChar(): string | undefined {\n    if (this.index >= this.input.length) {\n      return undefined;\n    }\n    return this.input[this.index++];\n  }\n\n  /** Read the next character from the input if it matches the target. */\n  readGivenChar(target: string): string | undefined {\n    return this.readAtomically(() => {\n      const char = this.readChar();\n      if (char !== target) {\n        return undefined;\n      }\n      return char;\n    });\n  }\n\n  /**\n   * Helper for reading separators in an indexed loop. Reads the separator\n   * character iff index > 0, then runs the parser. When used in a loop,\n   * the separator character will only be read on index > 0 (see\n   * readIPv4Addr for an example)\n   */\n  readSeparator<T extends Fn>(sep: string, index: number, inner: T): ReturnType<T> {\n    return this.readAtomically(() => {\n      if (index > 0) {\n        if (this.readGivenChar(sep) === undefined) {\n          return undefined;\n        }\n      }\n      return inner();\n    });\n  }\n\n  /**\n   * Read a number off the front of the input in the given radix, stopping\n   * at the first non-digit character or eof. Fails if the number has more\n   * digits than max_digits or if there is no number.\n   */\n  readNumber(\n    radix: number,\n    maxDigits: number | undefined,\n    allowZeroPrefix: boolean,\n    maxBytes: number\n  ): number | undefined {\n    return this.readAtomically(() => {\n      let result = 0;\n      let digitCount = 0;\n\n      const leadingChar = this.peekChar();\n      if (leadingChar === undefined) {\n        return undefined;\n      }\n      const hasLeadingZero = leadingChar === \"0\";\n      const maxValue = 2 ** (8 * maxBytes) - 1;\n\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const digit = this.readAtomically(() => {\n          const char = this.readChar();\n          if (char === undefined) {\n            return undefined;\n          }\n          const num = Number.parseInt(char, radix);\n          if (Number.isNaN(num)) {\n            return undefined;\n          }\n          return num;\n        });\n        if (digit === undefined) {\n          break;\n        }\n        result *= radix;\n        result += digit;\n        if (result > maxValue) {\n          return undefined;\n        }\n        digitCount += 1;\n        if (maxDigits !== undefined) {\n          if (digitCount > maxDigits) {\n            return undefined;\n          }\n        }\n      }\n\n      if (digitCount === 0) {\n        return undefined;\n      } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {\n        return undefined;\n      } else {\n        return result;\n      }\n    });\n  }\n\n  /** Read an IPv4 address. */\n  readIPv4Addr(): Uint8Array | undefined {\n    return this.readAtomically(() => {\n      const out = new Uint8Array(4);\n\n      for (let i = 0; i < out.length; i++) {\n        const ix = this.readSeparator(\".\", i, () => this.readNumber(10, 3, false, 1));\n        if (ix === undefined) {\n          return undefined;\n        }\n        out[i] = ix;\n      }\n\n      return out;\n    });\n  }\n\n  /** Read an IPv6 Address. */\n  readIPv6Addr(): Uint8Array | undefined {\n    /**\n     * Read a chunk of an IPv6 address into `groups`. Returns the number\n     * of groups read, along with a bool indicating if an embedded\n     * trailing IPv4 address was read. Specifically, read a series of\n     * colon-separated IPv6 groups (0x0000 - 0xFFFF), with an optional\n     * trailing embedded IPv4 address.\n     */\n    const readGroups = (groups: Uint8Array): [number, boolean] => {\n      for (let i = 0; i < groups.length / 2; i++) {\n        const ix = i * 2;\n        // Try to read a trailing embedded IPv4 address. There must be at least 4 groups left.\n        if (i < groups.length - 3) {\n          const ipv4 = this.readSeparator(\":\", i, () => this.readIPv4Addr());\n          if (ipv4 !== undefined) {\n            groups[ix] = ipv4[0];\n            groups[ix + 1] = ipv4[1];\n            groups[ix + 2] = ipv4[2];\n            groups[ix + 3] = ipv4[3];\n\n            return [ix + 4, true];\n          }\n        }\n\n        const group = this.readSeparator(\":\", i, () => this.readNumber(16, 4, true, 2));\n        if (group === undefined) {\n          return [ix, false];\n        }\n        groups[ix] = group >> 8;\n        groups[ix + 1] = group & 255;\n      }\n      return [groups.length, false];\n    };\n\n    return this.readAtomically(() => {\n      // Read the front part of the address; either the whole thing, or up to the first ::\n      const head = new Uint8Array(16);\n      const [headSize, headIp4] = readGroups(head);\n\n      if (headSize === 16) {\n        return head;\n      }\n\n      // IPv4 part is not allowed before `::`\n      if (headIp4) {\n        return undefined;\n      }\n\n      // Read `::` if previous code parsed less than 8 groups.\n      // `::` indicates one or more groups of 16 bits of zeros.\n      if (this.readGivenChar(\":\") === undefined) {\n        return undefined;\n      }\n      if (this.readGivenChar(\":\") === undefined) {\n        return undefined;\n      }\n\n      // Read the back part of the address. The :: must contain at least one\n      // set of zeroes, so our max length is 7.\n      const tail = new Uint8Array(14);\n      const limit = 16 - (headSize + 2);\n      const [tailSize] = readGroups(tail.subarray(0, limit));\n\n      // Concat the head and tail of the IP address\n      head.set(tail.subarray(0, tailSize), 16 - tailSize);\n\n      return head;\n    });\n  }\n\n  /** Read an IP Address, either IPv4 or IPv6. */\n  readIPAddr(): Uint8Array | undefined {\n    return this.readIPv4Addr() ?? this.readIPv6Addr();\n  }\n}\n", "import { Parser } from \"./parser.js\";\n\n// See https://stackoverflow.com/questions/166132/maximum-length-of-the-textual-representation-of-an-ipv6-address\nconst MAX_IPV6_LENGTH = 45;\nconst MAX_IPV4_LENGTH = 15;\n\nconst parser = new Parser();\n\n/** Parse `input` into IPv4 bytes. */\nexport function parseIPv4(input: string): Uint8Array | undefined {\n  if (input.length > MAX_IPV4_LENGTH) {\n    return undefined;\n  }\n  return parser.new(input).parseWith(() => parser.readIPv4Addr());\n}\n\n/** Parse IPv4 `input` into IPv6 with IPv4-mapped bytes, eg ::ffff:1.2.3.4 */\nexport function parseIPv4Mapped(input: string): Uint8Array | undefined {\n  if (input.length > MAX_IPV4_LENGTH) {\n    return undefined;\n  }\n\n  const ipv4 = parser.new(input).parseWith(() => parser.readIPv4Addr());\n  if (ipv4 === undefined) {\n    return undefined;\n  }\n\n  return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, ipv4[0], ipv4[1], ipv4[2], ipv4[3]]);\n}\n\n/** Parse `input` into IPv6 bytes. */\nexport function parseIPv6(input: string): Uint8Array | undefined {\n  // strip zone index if it is present\n  if (input.includes(\"%\")) {\n    input = input.split(\"%\")[0];\n  }\n  if (input.length > MAX_IPV6_LENGTH) {\n    return undefined;\n  }\n  return parser.new(input).parseWith(() => parser.readIPv6Addr());\n}\n\n/** Parse `input` into IPv4 or IPv6 bytes. */\nexport function parseIP(input: string, mapIPv4ToIPv6 = false): Uint8Array | undefined {\n  // strip zone index if it is present\n  if (input.includes(\"%\")) {\n    input = input.split(\"%\")[0];\n  }\n\n  if (input.length > MAX_IPV6_LENGTH) {\n    return undefined;\n  }\n\n  const addr = parser.new(input).parseWith(() => parser.readIPAddr());\n  if (!addr) {\n    return undefined;\n  }\n\n  if (mapIPv4ToIPv6 && addr.length === 4) {\n    return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, addr[0], addr[1], addr[2], addr[3]]);\n  }\n\n  return addr;\n}\n", "import { IPv4Len, IPv6Len } from \"./ip.js\";\n\nexport function allFF(\n  a: number[] | Uint8Array,\n  from: number,\n  to: number\n): boolean {\n  let i = 0;\n  for (const e of a) {\n    if (i < from) continue;\n    if (i > to) break;\n    if (e !== 0xff) return false;\n    i++;\n  }\n  return true;\n}\n\nexport function deepEqual(\n  a: Uint8Array | number[],\n  b: Uint8Array,\n  from: number,\n  to: number\n): boolean {\n  let i = 0;\n  for (const e of a) {\n    if (i < from) continue;\n    if (i > to) break;\n    if (e !== b[i]) return false;\n    i++;\n  }\n  return true;\n}\n\n/***\n * Returns long ip format\n */\nexport function ipToString(ip: Uint8Array | number[]): string {\n  switch (ip.length) {\n    case IPv4Len: {\n      return ip.join(\".\");\n    }\n    case IPv6Len: {\n      const result = [] as string[];\n      for (let i = 0; i < ip.length; i++) {\n        if (i % 2 === 0) {\n          result.push(\n            ip[i].toString(16).padStart(2, \"0\") +\n              ip[i + 1].toString(16).padStart(2, \"0\")\n          );\n        }\n      }\n      return result.join(\":\");\n    }\n    default: {\n      throw new Error(\"Invalid ip length\");\n    }\n  }\n}\n\n/**\n * If mask is a sequence of 1 bits followed by 0 bits, return number of 1 bits else -1\n */\nexport function simpleMaskLength(mask: Uint8Array): number {\n  let ones = 0;\n  // eslint-disable-next-line prefer-const\n  for (let [index, byte] of mask.entries()) {\n    if (byte === 0xff) {\n      ones += 8;\n      continue;\n    }\n    while ((byte & 0x80) != 0) {\n      ones++;\n      byte = byte << 1;\n    }\n    if ((byte & 0x80) != 0) {\n      return -1;\n    }\n    for (let i = index + 1; i < mask.length; i++) {\n      if (mask[i] != 0) {\n        return -1;\n      }\n    }\n    break;\n  }\n  return ones;\n}\n\nexport function maskToHex(mask: Uint8Array): string {\n  let hex = \"0x\";\n  for (const byte of mask) {\n    hex += (byte >> 4).toString(16) + (byte & 0x0f).toString(16);\n  }\n  return hex;\n}\n", "import { parseIP } from \"@chainsafe/is-ip/parse\";\nimport { allFF, deepEqual } from \"./util.js\";\n\nexport const IPv4Len = 4;\nexport const IPv6Len = 16;\n\nexport const maxIPv6Octet = parseInt(\"0xFFFF\", 16);\nexport const ipv4Prefix = new Uint8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255,\n]);\n\nexport interface IpNetRaw {\n  network: Uint8Array;\n  mask: Uint8Array;\n}\n\nexport function maskIp(ip: Uint8Array, mask: Uint8Array): Uint8Array {\n  if (mask.length === IPv6Len && ip.length === IPv4Len && allFF(mask, 0, 11)) {\n    mask = mask.slice(12);\n  }\n  if (\n    mask.length === IPv4Len &&\n    ip.length === IPv6Len &&\n    deepEqual(ip, ipv4Prefix, 0, 11)\n  ) {\n    ip = ip.slice(12);\n  }\n  const n = ip.length;\n  if (n != mask.length) {\n    throw new Error(\"Failed to mask ip\");\n  }\n  const out = new Uint8Array(n);\n  for (let i = 0; i < n; i++) {\n    out[i] = ip[i] & mask[i];\n  }\n  return out;\n}\n\nexport function containsIp(\n  net: IpNetRaw,\n  ip: Uint8Array | number[] | string\n): boolean {\n  if (typeof ip === \"string\") {\n    ip = parseIP(ip)!;\n  }\n  if (ip == null) throw new Error(\"Invalid ip\");\n  if (ip.length !== net.network.length) {\n    return false;\n  }\n  for (let i = 0; i < ip.length; i++) {\n    if ((net.network[i] & net.mask[i]) !== (ip[i] & net.mask[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function iPv4FromIPv6(ip: Uint8Array): Uint8Array {\n  if (!isIPv4mappedIPv6(ip)) {\n    throw new Error(\"Must have 0xffff prefix\");\n  }\n  return ip.slice(12);\n}\n\nexport function isIPv4mappedIPv6(ip: Uint8Array | number[]): boolean {\n  return deepEqual(ip, ipv4Prefix, 0, 11);\n}\n", "import { parseIPv4, parseIPv6 } from \"@chainsafe/is-ip/parse\";\nimport { IPv4Len, IPv6Len, maskIp } from \"./ip.js\";\n\nexport function parseCidr(s: string): {\n  network: Uint8Array;\n  mask: Uint8Array;\n} {\n  const [address, maskString] = s.split(\"/\");\n  if (!address || !maskString)\n    throw new Error(\"Failed to parse given CIDR: \" + s);\n  let ipLength = IPv4Len;\n  let ip = parseIPv4(address);\n  if (ip == null) {\n    ipLength = IPv6Len;\n    ip = parseIPv6(address);\n    if (ip == null) throw new Error(\"Failed to parse given CIDR: \" + s);\n  }\n  const m = parseInt(maskString, 10);\n  if (\n    Number.isNaN(m) ||\n    String(m).length !== maskString.length ||\n    m < 0 ||\n    m > ipLength * 8\n  ) {\n    throw new Error(\"Failed to parse given CIDR: \" + s);\n  }\n  const mask = cidrMask(m, 8 * ipLength);\n  return {\n    network: maskIp(ip, mask),\n    mask,\n  };\n}\n\nexport function cidrMask(ones: number, bits: number): Uint8Array {\n  if (bits !== 8 * IPv4Len && bits !== 8 * IPv6Len)\n    throw new Error(\"Invalid CIDR mask\");\n  if (ones < 0 || ones > bits) throw new Error(\"Invalid CIDR mask\");\n  const l = bits / 8;\n  const m = new Uint8Array(l);\n  for (let i = 0; i < l; i++) {\n    if (ones >= 8) {\n      m[i] = 0xff;\n      ones -= 8;\n      continue;\n    }\n    m[i] = 255 - (0xff >> ones);\n    ones = 0;\n  }\n  return m;\n}\n", "import { parseIP } from \"@chainsafe/is-ip/parse\";\nimport { cidrMask, parseCidr } from \"./cidr.js\";\nimport { containsIp, maskIp } from \"./ip.js\";\nimport { ipToString, maskToHex, simpleMaskLength } from \"./util.js\";\n\nexport class IpNet {\n  public readonly network: Uint8Array;\n  public readonly mask: Uint8Array;\n\n  /**\n   *\n   * @param ipOrCidr either network ip or full cidr address\n   * @param mask in case ipOrCidr is network this can be either mask in decimal format or as ip address\n   */\n  constructor(ipOrCidr: string, mask?: string | number) {\n    if (mask == null) {\n      ({ network: this.network, mask: this.mask } = parseCidr(ipOrCidr));\n    } else {\n      const ipResult = parseIP(ipOrCidr);\n      if (ipResult == null) {\n        throw new Error(\"Failed to parse network\");\n      }\n      mask = String(mask);\n      const m = parseInt(mask, 10);\n      if (\n        Number.isNaN(m) ||\n        String(m).length !== mask.length ||\n        m < 0 ||\n        m > ipResult.length * 8\n      ) {\n        const maskResult = parseIP(mask);\n        if (maskResult == null) {\n          throw new Error(\"Failed to parse mask\");\n        }\n        this.mask = maskResult;\n      } else {\n        this.mask = cidrMask(m, 8 * ipResult.length);\n      }\n      this.network = maskIp(ipResult, this.mask);\n    }\n  }\n\n  /**\n   * Checks if netmask contains ip address\n   * @param ip\n   * @returns\n   */\n  contains(ip: Uint8Array | number[] | string): boolean {\n    return containsIp({ network: this.network, mask: this.mask }, ip);\n  }\n\n  /**Serializes back to string format */\n  toString(): string {\n    const l = simpleMaskLength(this.mask);\n    const mask = l !== -1 ? String(l) : maskToHex(this.mask);\n    return ipToString(this.network) + \"/\" + mask;\n  }\n}\n", "import { IpNet } from \"./ipnet.js\";\n\nexport { ipToString } from \"./util.js\";\nexport { maskIp, iPv4FromIPv6, isIPv4mappedIPv6 } from \"./ip.js\";\nexport { IpNet } from \"./ipnet.js\";\nexport { parseCidr } from \"./cidr.js\";\n\n/**\n * Checks if cidr block contains ip address\n * @param cidr ipv4 or ipv6 formatted cidr . Example 198.51.100.14/24 or 2001:db8::/48\n * @param ip ipv4 or ipv6 address Example 198.51.100.14 or 2001:db8::\n *\n */\nexport function cidrContains(cidr: string, ip: string): boolean {\n  const ipnet = new IpNet(cidr);\n  return ipnet.contains(ip);\n}\n", "import { parseIP, parseIPv4, parseIPv6 } from \"./parse.js\";\n\n/** Check if `input` is IPv4. */\nexport function isIPv4(input: string): boolean {\n  return Boolean(parseIPv4(input));\n}\n\n/** Check if `input` is IPv6. */\nexport function isIPv6(input: string): boolean {\n  return Boolean(parseIPv6(input));\n}\n\n/** Check if `input` is IPv4 or IPv6. */\nexport function isIP(input: string): boolean {\n  return Boolean(parseIP(input));\n}\n\n/**\n * @returns `6` if `input` is IPv6, `4` if `input` is IPv4, or `undefined` if `input` is neither.\n */\nexport function ipVersion(input: string): 4 | 6 | undefined {\n  if (isIPv4(input)) {\n    return 4;\n  } else if (isIPv6(input)) {\n    return 6;\n  } else {\n    return undefined;\n  }\n}\n", "import { isIPv4, isIPv6 } from '@chainsafe/is-ip'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nexport { isIP } from '@chainsafe/is-ip'\nexport const isV4 = isIPv4\nexport const isV6 = isIPv6\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7\n// but with buf/offset args removed because we don't use them\nexport const toBytes = function (ip: string): Uint8Array {\n  let offset = 0\n  ip = ip.toString().trim()\n\n  if (isV4(ip)) {\n    const bytes = new Uint8Array(offset + 4)\n\n    ip.split(/\\./g).forEach((byte) => {\n      bytes[offset++] = parseInt(byte, 10) & 0xff\n    })\n\n    return bytes\n  }\n\n  if (isV6(ip)) {\n    const sections = ip.split(':', 8)\n\n    let i\n    for (i = 0; i < sections.length; i++) {\n      const isv4 = isV4(sections[i])\n      let v4Buffer: Uint8Array | undefined\n\n      if (isv4) {\n        v4Buffer = toBytes(sections[i])\n        sections[i] = uint8ArrayToString(v4Buffer.slice(0, 2), 'base16')\n      }\n\n      if (v4Buffer != null && ++i < 8) {\n        sections.splice(i, 0, uint8ArrayToString(v4Buffer.slice(2, 4), 'base16'))\n      }\n    }\n\n    if (sections[0] === '') {\n      while (sections.length < 8) sections.unshift('0')\n    } else if (sections[sections.length - 1] === '') {\n      while (sections.length < 8) sections.push('0')\n    } else if (sections.length < 8) {\n      for (i = 0; i < sections.length && sections[i] !== ''; i++);\n      const argv: [number, number, ...string[]] = [i, 1]\n      for (i = 9 - sections.length; i > 0; i--) {\n        argv.push('0')\n      }\n      sections.splice.apply(sections, argv)\n    }\n\n    const bytes = new Uint8Array(offset + 16)\n\n    for (i = 0; i < sections.length; i++) {\n      const word = parseInt(sections[i], 16)\n      bytes[offset++] = (word >> 8) & 0xff\n      bytes[offset++] = word & 0xff\n    }\n\n    return bytes\n  }\n\n  throw new Error('invalid ip address')\n}\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L63\nexport const toString = function (buf: Uint8Array, offset: number = 0, length?: number): string {\n  offset = ~~offset\n  length = length ?? (buf.length - offset)\n\n  const view = new DataView(buf.buffer)\n\n  if (length === 4) {\n    const result = []\n\n    // IPv4\n    for (let i = 0; i < length; i++) {\n      result.push(buf[offset + i])\n    }\n\n    return result.join('.')\n  }\n\n  if (length === 16) {\n    const result = []\n\n    // IPv6\n    for (let i = 0; i < length; i += 2) {\n      result.push(view.getUint16(offset + i).toString(16))\n    }\n\n    return result.join(':')\n      .replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')\n      .replace(/:{3,4}/, '::')\n  }\n\n  return ''\n}\n", "import type { Protocol } from './index.js'\n\nconst V = -1\nexport const names: Record<string, Protocol> = {}\nexport const codes: Record<number, Protocol> = {}\n\nexport const table: Array<[number, number, string, boolean?, boolean?]> = [\n  [4, 32, 'ip4'],\n  [6, 16, 'tcp'],\n  [33, 16, 'dccp'],\n  [41, 128, 'ip6'],\n  [42, V, 'ip6zone'],\n  [43, 8, 'ipcidr'],\n  [53, V, 'dns', true],\n  [54, V, 'dns4', true],\n  [55, V, 'dns6', true],\n  [56, V, 'dnsaddr', true],\n  [132, 16, 'sctp'],\n  [273, 16, 'udp'],\n  [275, 0, 'p2p-webrtc-star'],\n  [276, 0, 'p2p-webrtc-direct'],\n  [277, 0, 'p2p-stardust'],\n  [280, 0, 'webrtc-direct'],\n  [281, 0, 'webrtc'],\n  [290, 0, 'p2p-circuit'],\n  [301, 0, 'udt'],\n  [302, 0, 'utp'],\n  [400, V, 'unix', false, true],\n  // `ipfs` is added before `p2p` for legacy support.\n  // All text representations will default to `p2p`, but `ipfs` will\n  // still be supported\n  [421, V, 'ipfs'],\n  // `p2p` is the preferred name for 421, and is now the default\n  [421, V, 'p2p'],\n  [443, 0, 'https'],\n  [444, 96, 'onion'],\n  [445, 296, 'onion3'],\n  [446, V, 'garlic64'],\n  [448, 0, 'tls'],\n  [449, V, 'sni'],\n  [460, 0, 'quic'],\n  [461, 0, 'quic-v1'],\n  [465, 0, 'webtransport'],\n  [466, V, 'certhash'],\n  [477, 0, 'ws'],\n  [478, 0, 'wss'],\n  [479, 0, 'p2p-websocket-star'],\n  [480, 0, 'http'],\n  [481, V, 'http-path'],\n  [777, V, 'memory']\n]\n\n// populate tables\ntable.forEach(row => {\n  const proto = createProtocol(...row)\n  codes[proto.code] = proto\n  names[proto.name] = proto\n})\n\nexport function createProtocol (code: number, size: number, name: string, resolvable?: any, path?: any): Protocol {\n  return {\n    code,\n    size,\n    name,\n    resolvable: Boolean(resolvable),\n    path: Boolean(path)\n  }\n}\n\n/**\n * For the passed proto string or number, return a {@link Protocol}\n *\n * @example\n *\n * ```js\n * import { protocol } from '@multiformats/multiaddr'\n *\n * console.info(protocol(4))\n * // { code: 4, size: 32, name: 'ip4', resolvable: false, path: false }\n * ```\n */\nexport function getProtocol (proto: number | string): Protocol {\n  if (typeof proto === 'number') {\n    if (codes[proto] != null) {\n      return codes[proto]\n    }\n\n    throw new Error(`no protocol with code: ${proto}`)\n  } else if (typeof proto === 'string') {\n    if (names[proto] != null) {\n      return names[proto]\n    }\n\n    throw new Error(`no protocol with name: ${proto}`)\n  }\n\n  throw new Error(`invalid protocol id type: ${typeof proto}`)\n}\n", "import { IpNet } from '@chainsafe/netmask'\nimport { base32 } from 'multiformats/bases/base32'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { bases } from 'multiformats/basics'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport * as varint from 'uint8-varint'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport * as ip from './ip.js'\nimport { getProtocol } from './protocols-table.js'\nimport type { Multiaddr } from './index.js'\n\nconst ip4Protocol = getProtocol('ip4')\nconst ip6Protocol = getProtocol('ip6')\nconst ipcidrProtocol = getProtocol('ipcidr')\n\n/**\n * converts (serializes) addresses\n */\nexport function convert (proto: string, a: string): Uint8Array\nexport function convert (proto: string, a: Uint8Array): string\nexport function convert (proto: string, a: string | Uint8Array): Uint8Array | string {\n  if (a instanceof Uint8Array) {\n    return convertToString(proto, a)\n  } else {\n    return convertToBytes(proto, a)\n  }\n}\n\n/**\n * Convert [code,Uint8Array] to string\n */\n// eslint-disable-next-line complexity\nexport function convertToString (proto: number | string, buf: Uint8Array): string {\n  const protocol = getProtocol(proto)\n  switch (protocol.code) {\n    case 4: // ipv4\n    case 41: // ipv6\n      return bytes2ip(buf)\n    case 42: // ipv6zone\n      return bytes2str(buf)\n    case 43: // ipcidr\n      return uint8ArrayToString(buf, 'base10')\n\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132: // sctp\n      return bytes2port(buf).toString()\n\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 449: // sni\n    case 777: // memory\n      return bytes2str(buf)\n\n    case 421: // ipfs\n      return bytes2mh(buf)\n    case 444: // onion\n      return bytes2onion(buf)\n    case 445: // onion3\n      return bytes2onion(buf)\n    case 466: // certhash\n      return bytes2mb(buf)\n    case 481: // http-path\n      return globalThis.encodeURIComponent(bytes2str(buf))\n    default:\n      return uint8ArrayToString(buf, 'base16') // no clue. convert to hex\n  }\n}\n\n// eslint-disable-next-line complexity\nexport function convertToBytes (proto: string | number, str: string): Uint8Array {\n  const protocol = getProtocol(proto)\n  switch (protocol.code) {\n    case 4: // ipv4\n      return ip2bytes(str)\n    case 41: // ipv6\n      return ip2bytes(str)\n    case 42: // ipv6zone\n      return str2bytes(str)\n    case 43: // ipcidr\n      return uint8ArrayFromString(str, 'base10')\n\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132: // sctp\n      return port2bytes(parseInt(str, 10))\n\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 449: // sni\n    case 777: // memory\n      return str2bytes(str)\n\n    case 421: // ipfs\n      return mh2bytes(str)\n    case 444: // onion\n      return onion2bytes(str)\n    case 445: // onion3\n      return onion32bytes(str)\n    case 466: // certhash\n      return mb2bytes(str)\n    case 481: // http-path\n      return str2bytes(globalThis.decodeURIComponent(str))\n    default:\n      return uint8ArrayFromString(str, 'base16') // no clue. convert from hex\n  }\n}\n\nexport function convertToIpNet (multiaddr: Multiaddr): IpNet {\n  let mask: string | undefined\n  let addr: string | undefined\n  multiaddr.stringTuples().forEach(([code, value]) => {\n    if (code === ip4Protocol.code || code === ip6Protocol.code) {\n      addr = value\n    }\n    if (code === ipcidrProtocol.code) {\n      mask = value\n    }\n  })\n  if (mask == null || addr == null) {\n    throw new Error('Invalid multiaddr')\n  }\n  return new IpNet(addr, mask)\n}\n\nconst decoders = Object.values(bases).map((c) => c.decoder)\nconst anybaseDecoder = (function () {\n  let acc = decoders[0].or(decoders[1])\n  decoders.slice(2).forEach((d) => (acc = acc.or(d)))\n  return acc\n})()\n\nfunction ip2bytes (ipString: string): Uint8Array {\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address')\n  }\n  return ip.toBytes(ipString)\n}\n\nfunction bytes2ip (ipBuff: Uint8Array): string {\n  const ipString = ip.toString(ipBuff, 0, ipBuff.length)\n  if (ipString == null) {\n    throw new Error('ipBuff is required')\n  }\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address')\n  }\n  return ipString\n}\n\nfunction port2bytes (port: number): Uint8Array {\n  const buf = new ArrayBuffer(2)\n  const view = new DataView(buf)\n  view.setUint16(0, port)\n\n  return new Uint8Array(buf)\n}\n\nfunction bytes2port (buf: Uint8Array): number {\n  const view = new DataView(buf.buffer)\n  return view.getUint16(buf.byteOffset)\n}\n\nfunction str2bytes (str: string): Uint8Array {\n  const buf = uint8ArrayFromString(str)\n  const size = Uint8Array.from(varint.encode(buf.length))\n  return uint8ArrayConcat([size, buf], size.length + buf.length)\n}\n\nfunction bytes2str (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  buf = buf.slice(varint.encodingLength(size))\n\n  if (buf.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return uint8ArrayToString(buf)\n}\n\nfunction mh2bytes (hash: string): Uint8Array {\n  let mh\n\n  if (hash[0] === 'Q' || hash[0] === '1') {\n    mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes\n  } else {\n    mh = CID.parse(hash).multihash.bytes\n  }\n\n  // the address is a varint prefixed multihash string representation\n  const size = Uint8Array.from(varint.encode(mh.length))\n  return uint8ArrayConcat([size, mh], size.length + mh.length)\n}\n\nfunction mb2bytes (mbstr: string): Uint8Array {\n  const mb = anybaseDecoder.decode(mbstr)\n  const size = Uint8Array.from(varint.encode(mb.length))\n  return uint8ArrayConcat([size, mb], size.length + mb.length)\n}\nfunction bytes2mb (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  const hash = buf.slice(varint.encodingLength(size))\n\n  if (hash.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return 'u' + uint8ArrayToString(hash, 'base64url')\n}\n\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  const address = buf.slice(varint.encodingLength(size))\n\n  if (address.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return uint8ArrayToString(address, 'base58btc')\n}\n\nfunction onion2bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n  if (addr[0].length !== 16) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`)\n  }\n\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode('b' + addr[0])\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n  const portBuf = port2bytes(port)\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nfunction onion32bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n  if (addr[0].length !== 56) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`)\n  }\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode(`b${addr[0]}`)\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n  const portBuf = port2bytes(port)\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nfunction bytes2onion (buf: Uint8Array): string {\n  const addrBytes = buf.slice(0, buf.length - 2)\n  const portBytes = buf.slice(buf.length - 2)\n  const addr = uint8ArrayToString(addrBytes, 'base32')\n  const port = bytes2port(portBytes)\n  return `${addr}:${port}`\n}\n", "import * as varint from 'uint8-varint'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { convertToBytes, convertToString } from './convert.js'\nimport { getProtocol } from './protocols-table.js'\nimport type { StringTuple, Tuple, Protocol } from './index.js'\n\nexport interface MultiaddrParts {\n  bytes: Uint8Array\n  string: string\n  tuples: Tuple[]\n  stringTuples: StringTuple[]\n  path: string | null\n}\n\nexport function stringToMultiaddrParts (str: string): MultiaddrParts {\n  str = cleanPath(str)\n  const tuples: Tuple[] = []\n  const stringTuples: StringTuple[] = []\n  let path: string | null = null\n\n  const parts = str.split('/').slice(1)\n  if (parts.length === 1 && parts[0] === '') {\n    return {\n      bytes: new Uint8Array(),\n      string: '/',\n      tuples: [],\n      stringTuples: [],\n      path: null\n    }\n  }\n\n  for (let p = 0; p < parts.length; p++) {\n    const part = parts[p]\n    const proto = getProtocol(part)\n\n    if (proto.size === 0) {\n      tuples.push([proto.code])\n      stringTuples.push([proto.code])\n      // eslint-disable-next-line no-continue\n      continue\n    }\n\n    p++ // advance addr part\n    if (p >= parts.length) {\n      throw new ParseError('invalid address: ' + str)\n    }\n\n    // if it's a path proto, take the rest\n    if (proto.path === true) {\n      // should we need to check each path part to see if it's a proto?\n      // This would allow for other protocols to be added after a unix path,\n      // however it would have issues if the path had a protocol name in the path\n      path = cleanPath(parts.slice(p).join('/'))\n      tuples.push([proto.code, convertToBytes(proto.code, path)])\n      stringTuples.push([proto.code, path])\n      break\n    }\n\n    const bytes = convertToBytes(proto.code, parts[p])\n    tuples.push([proto.code, bytes])\n    stringTuples.push([proto.code, convertToString(proto.code, bytes)])\n  }\n\n  return {\n    string: stringTuplesToString(stringTuples),\n    bytes: tuplesToBytes(tuples),\n    tuples,\n    stringTuples,\n    path\n  }\n}\n\nexport function bytesToMultiaddrParts (bytes: Uint8Array): MultiaddrParts {\n  const tuples: Tuple[] = []\n  const stringTuples: StringTuple[] = []\n  let path: string | null = null\n\n  let i = 0\n  while (i < bytes.length) {\n    const code = varint.decode(bytes, i)\n    const n = varint.encodingLength(code)\n\n    const p = getProtocol(code)\n\n    const size = sizeForAddr(p, bytes.slice(i + n))\n\n    if (size === 0) {\n      tuples.push([code])\n      stringTuples.push([code])\n      i += n\n      // eslint-disable-next-line no-continue\n      continue\n    }\n\n    const addr = bytes.slice(i + n, i + n + size)\n\n    i += (size + n)\n\n    if (i > bytes.length) { // did not end _exactly_ at buffer.length\n      throw new ParseError('Invalid address Uint8Array: ' + uint8ArrayToString(bytes, 'base16'))\n    }\n\n    // ok, tuple seems good.\n    tuples.push([code, addr])\n    const stringAddr = convertToString(code, addr)\n    stringTuples.push([code, stringAddr])\n    if (p.path === true) {\n      // should we need to check each path part to see if it's a proto?\n      // This would allow for other protocols to be added after a unix path,\n      // however it would have issues if the path had a protocol name in the path\n      path = stringAddr\n      break\n    }\n  }\n\n  return {\n    bytes: Uint8Array.from(bytes),\n    string: stringTuplesToString(stringTuples),\n    tuples,\n    stringTuples,\n    path\n  }\n}\n\n/**\n * [[num code, str value?]... ] -> Tuple[]\n */\nexport function stringTuplesToTuples (stringTuples: StringTuple[]): Tuple[] {\n  const tuples: Tuple[] = []\n\n  stringTuples.forEach(([code, value]) => {\n    const tuple: Tuple = [code]\n\n    if (value != null) {\n      tuple[1] = convertToBytes(code, value)\n    }\n\n    tuples.push(tuple)\n  })\n\n  return tuples\n}\n\n/**\n * [[num code, str value?]... ] -> string\n */\nfunction stringTuplesToString (tuples: StringTuple[]): string {\n  const parts: string[] = []\n  tuples.map((tup) => {\n    const proto = getProtocol(tup[0])\n    parts.push(proto.name)\n    if (tup.length > 1 && tup[1] != null) {\n      parts.push(tup[1])\n    }\n    return null\n  })\n\n  return cleanPath(parts.join('/'))\n}\n\n/**\n * [[int code, Uint8Array ]... ] -> Uint8Array\n */\nexport function tuplesToBytes (tuples: Tuple[]): Uint8Array {\n  return uint8ArrayConcat(tuples.map((tup) => {\n    const proto = getProtocol(tup[0])\n    let buf = Uint8Array.from(varint.encode(proto.code))\n\n    if (tup.length > 1 && tup[1] != null) {\n      buf = uint8ArrayConcat([buf, tup[1]]) // add address buffer\n    }\n\n    return buf\n  }))\n}\n\n/**\n * For the passed address, return the serialized size\n */\nfunction sizeForAddr (p: Protocol, addr: Uint8Array | number[]): number {\n  if (p.size > 0) {\n    return p.size / 8\n  } else if (p.size === 0) {\n    return 0\n  } else {\n    const size = varint.decode(addr instanceof Uint8Array ? addr : Uint8Array.from(addr))\n    return size + varint.encodingLength(size)\n  }\n}\n\nexport function bytesToTuples (buf: Uint8Array): Tuple[] {\n  const tuples: Array<[number, Uint8Array?]> = []\n  let i = 0\n  while (i < buf.length) {\n    const code = varint.decode(buf, i)\n    const n = varint.encodingLength(code)\n\n    const p = getProtocol(code)\n\n    const size = sizeForAddr(p, buf.slice(i + n))\n\n    if (size === 0) {\n      tuples.push([code])\n      i += n\n      // eslint-disable-next-line no-continue\n      continue\n    }\n\n    const addr = buf.slice(i + n, i + n + size)\n\n    i += (size + n)\n\n    if (i > buf.length) { // did not end _exactly_ at buffer.length\n      throw new ParseError('Invalid address Uint8Array: ' + uint8ArrayToString(buf, 'base16'))\n    }\n\n    // ok, tuple seems good.\n    tuples.push([code, addr])\n  }\n\n  return tuples\n}\n\nexport function cleanPath (str: string): string {\n  return '/' + str.trim().split('/').filter((a) => a).join('/')\n}\n\nexport class ParseError extends Error {\n  static name = 'ParseError'\n  name = 'ParseError'\n\n  constructor (str: string) {\n    super(`Error parsing address: ${str}`)\n  }\n}\n", "/* eslint-disable complexity */\nimport { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { bytesToMultiaddrParts, stringToMultiaddrParts, type MultiaddrParts, tuplesToBytes } from './codec.js'\nimport { getProtocol, names } from './protocols-table.js'\nimport { isMultiaddr, multiaddr, resolvers } from './index.js'\nimport type { MultiaddrInput, Multiaddr as MultiaddrInterface, MultiaddrObject, Protocol, StringTuple, Tuple, NodeAddress, ResolveOptions } from './index.js'\n\nconst inspect = Symbol.for('nodejs.util.inspect.custom')\nexport const symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr')\n\nconst DNS_CODES = [\n  getProtocol('dns').code,\n  getProtocol('dns4').code,\n  getProtocol('dns6').code,\n  getProtocol('dnsaddr').code\n]\n\nclass NoAvailableResolverError extends Error {\n  constructor (message = 'No available resolver') {\n    super(message)\n    this.name = 'NoAvailableResolverError'\n  }\n}\n\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nexport class Multiaddr implements MultiaddrInterface {\n  public bytes: Uint8Array\n  readonly #string: string\n  readonly #tuples: Tuple[]\n  readonly #stringTuples: StringTuple[]\n  readonly #path: string | null\n\n  [symbol]: boolean = true\n\n  constructor (addr?: MultiaddrInput) {\n    // default\n    if (addr == null) {\n      addr = ''\n    }\n\n    let parts: MultiaddrParts\n    if (addr instanceof Uint8Array) {\n      parts = bytesToMultiaddrParts(addr)\n    } else if (typeof addr === 'string') {\n      if (addr.length > 0 && addr.charAt(0) !== '/') {\n        throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`)\n      }\n      parts = stringToMultiaddrParts(addr)\n    } else if (isMultiaddr(addr)) { // Multiaddr\n      parts = bytesToMultiaddrParts(addr.bytes)\n    } else {\n      throw new Error('addr must be a string, Buffer, or another Multiaddr')\n    }\n\n    this.bytes = parts.bytes\n    this.#string = parts.string\n    this.#tuples = parts.tuples\n    this.#stringTuples = parts.stringTuples\n    this.#path = parts.path\n  }\n\n  toString (): string {\n    return this.#string\n  }\n\n  toJSON (): string {\n    return this.toString()\n  }\n\n  toOptions (): MultiaddrObject {\n    let family: 4 | 6 | undefined\n    let transport: 'tcp' | 'udp' | undefined\n    let host: string | undefined\n    let port: number | undefined\n    let zone = ''\n\n    const tcp = getProtocol('tcp')\n    const udp = getProtocol('udp')\n    const ip4 = getProtocol('ip4')\n    const ip6 = getProtocol('ip6')\n    const dns6 = getProtocol('dns6')\n    const ip6zone = getProtocol('ip6zone')\n\n    for (const [code, value] of this.stringTuples()) {\n      if (code === ip6zone.code) {\n        zone = `%${value ?? ''}`\n      }\n\n      // default to https when protocol & port are omitted from DNS addrs\n      if (DNS_CODES.includes(code)) {\n        transport = tcp.name === 'tcp' ? 'tcp' : 'udp'\n        port = 443\n        host = `${value ?? ''}${zone}`\n        family = code === dns6.code ? 6 : 4\n      }\n\n      if (code === tcp.code || code === udp.code) {\n        transport = getProtocol(code).name === 'tcp' ? 'tcp' : 'udp'\n        port = parseInt(value ?? '')\n      }\n\n      if (code === ip4.code || code === ip6.code) {\n        transport = getProtocol(code).name === 'tcp' ? 'tcp' : 'udp'\n        host = `${value ?? ''}${zone}`\n        family = code === ip6.code ? 6 : 4\n      }\n    }\n\n    if (family == null || transport == null || host == null || port == null) {\n      throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}\".')\n    }\n\n    const opts: MultiaddrObject = {\n      family,\n      host,\n      transport,\n      port\n    }\n\n    return opts\n  }\n\n  protos (): Protocol[] {\n    return this.#tuples.map(([code]) => Object.assign({}, getProtocol(code)))\n  }\n\n  protoCodes (): number[] {\n    return this.#tuples.map(([code]) => code)\n  }\n\n  protoNames (): string[] {\n    return this.#tuples.map(([code]) => getProtocol(code).name)\n  }\n\n  tuples (): Array<[number, Uint8Array?]> {\n    return this.#tuples.map(([code, value]) => {\n      if (value == null) {\n        return [code]\n      }\n\n      return [code, value]\n    })\n  }\n\n  stringTuples (): Array<[number, string?]> {\n    return this.#stringTuples.map(([code, value]) => {\n      if (value == null) {\n        return [code]\n      }\n\n      return [code, value]\n    })\n  }\n\n  encapsulate (addr: MultiaddrInput): Multiaddr {\n    addr = new Multiaddr(addr)\n    return new Multiaddr(this.toString() + addr.toString())\n  }\n\n  decapsulate (addr: Multiaddr | string): Multiaddr {\n    const addrString = addr.toString()\n    const s = this.toString()\n    const i = s.lastIndexOf(addrString)\n    if (i < 0) {\n      throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`)\n    }\n    return new Multiaddr(s.slice(0, i))\n  }\n\n  decapsulateCode (code: number): Multiaddr {\n    const tuples = this.tuples()\n    for (let i = tuples.length - 1; i >= 0; i--) {\n      if (tuples[i][0] === code) {\n        return new Multiaddr(tuplesToBytes(tuples.slice(0, i)))\n      }\n    }\n    return this\n  }\n\n  getPeerId (): string | null {\n    try {\n      let tuples: Array<[number, string | undefined]> = []\n\n      this.stringTuples().forEach(([code, name]) => {\n        if (code === names.p2p.code) {\n          tuples.push([code, name])\n        }\n\n        // if this is a p2p-circuit address, return the target peer id if present\n        // not the peer id of the relay\n        if (code === names['p2p-circuit'].code) {\n          tuples = []\n        }\n      })\n\n      // Get the last ipfs tuple ['p2p', 'peerid string']\n      const tuple = tuples.pop()\n      if (tuple?.[1] != null) {\n        const peerIdStr = tuple[1]\n\n        // peer id is base58btc encoded string but not multibase encoded so add the `z`\n        // prefix so we can validate that it is correctly encoded\n        if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n          return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc')\n        }\n\n        // try to parse peer id as CID\n        return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc')\n      }\n\n      return null\n    } catch (e) {\n      return null\n    }\n  }\n\n  getPath (): string | null {\n    return this.#path\n  }\n\n  equals (addr: { bytes: Uint8Array }): boolean {\n    return uint8ArrayEquals(this.bytes, addr.bytes)\n  }\n\n  async resolve (options?: ResolveOptions): Promise<MultiaddrInterface[]> {\n    const resolvableProto = this.protos().find((p) => p.resolvable)\n\n    // Multiaddr is not resolvable?\n    if (resolvableProto == null) {\n      return [this]\n    }\n\n    const resolver = resolvers.get(resolvableProto.name)\n    if (resolver == null) {\n      throw new NoAvailableResolverError(`no available resolver for ${resolvableProto.name}`)\n    }\n\n    const result = await resolver(this, options)\n\n    return result.map(str => multiaddr(str))\n  }\n\n  nodeAddress (): NodeAddress {\n    const options = this.toOptions()\n\n    if (options.transport !== 'tcp' && options.transport !== 'udp') {\n      throw new Error(`multiaddr must have a valid format - no protocol with name: \"${options.transport}\". Must have a valid transport protocol: \"{tcp, udp}\"`)\n    }\n\n    return {\n      family: options.family,\n      address: options.host,\n      port: options.port\n    }\n  }\n\n  isThinWaistAddress (addr?: Multiaddr): boolean {\n    const protos = (addr ?? this).protos()\n\n    if (protos.length !== 2) {\n      return false\n    }\n\n    if (protos[0].code !== 4 && protos[0].code !== 41) {\n      return false\n    }\n    if (protos[1].code !== 6 && protos[1].code !== 273) {\n      return false\n    }\n    return true\n  }\n\n  /**\n   * Returns Multiaddr as a human-readable string\n   * https://nodejs.org/api/util.html#utilinspectcustom\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n   * ```\n   */\n  [inspect] (): string {\n    return `Multiaddr(${this.#string})`\n  }\n}\n", "import { convertToIpNet } from '../convert.js'\nimport { multiaddr, type Multiaddr, type MultiaddrInput } from '../index.js'\nimport type { IpNet } from '@chainsafe/netmask'\n\n/**\n * A utility class to determine if a Multiaddr contains another\n * multiaddr.\n *\n * This can be used with ipcidr ranges to determine if a given\n * multiaddr is in a ipcidr range.\n *\n * @example\n *\n * ```js\n * import { multiaddr, MultiaddrFilter } from '@multiformats/multiaddr'\n *\n * const range = multiaddr('/ip4/192.168.10.10/ipcidr/24')\n * const filter = new MultiaddrFilter(range)\n *\n * const input = multiaddr('/ip4/192.168.10.2/udp/60')\n * console.info(filter.contains(input)) // true\n * ```\n */\nexport class MultiaddrFilter {\n  private readonly multiaddr: Multiaddr\n  private readonly netmask: IpNet\n\n  public constructor (input: MultiaddrInput) {\n    this.multiaddr = multiaddr(input)\n    this.netmask = convertToIpNet(this.multiaddr)\n  }\n\n  public contains (input: MultiaddrInput): boolean {\n    if (input == null) return false\n    const m = multiaddr(input)\n    let ip\n    for (const [code, value] of m.stringTuples()) {\n      if (code === 4 || code === 41) {\n        ip = value\n        break\n      }\n    }\n    if (ip === undefined) return false\n    return this.netmask.contains(ip)\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * A standard way to represent addresses that\n *\n * - support any standard network protocol\n * - are self-describing\n * - have a binary packed format\n * - have a nice string representation\n * - encapsulate well\n *\n * @example\n *\n * ```TypeScript\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const addr = multiaddr('/ip4/127.0.0.1/udp/1234')\n * // Multiaddr(/ip4/127.0.0.1/udp/1234)\n *\n * addr.bytes\n * // <Uint8Array 04 7f 00 00 01 11 04 d2>\n *\n * addr.toString()\n * // '/ip4/127.0.0.1/udp/1234'\n *\n * addr.protos()\n * // [\n * //   {code: 4, name: 'ip4', size: 32},\n * //   {code: 273, name: 'udp', size: 16}\n * // ]\n *\n * // gives you an object that is friendly with what Node.js core modules expect for addresses\n * addr.nodeAddress()\n * // {\n * //   family: 4,\n * //   port: 1234,\n * //   address: \"127.0.0.1\"\n * // }\n *\n * addr.encapsulate('/sctp/5678')\n * // Multiaddr(/ip4/127.0.0.1/udp/1234/sctp/5678)\n * ```\n *\n * ## Resolving DNSADDR addresses\n *\n * [DNSADDR](https://github.com/multiformats/multiaddr/blob/master/protocols/DNSADDR.md) is a spec that allows storing a TXT DNS record that contains a Multiaddr.\n *\n * To resolve DNSADDR addresses, call the `.resolve()` function the multiaddr, optionally passing a `DNS` resolver.\n *\n * DNSADDR addresses can resolve to multiple multiaddrs, since there is no limit to the number of TXT records that can be stored.\n *\n * @example Resolving DNSADDR Multiaddrs\n *\n * ```TypeScript\n * import { multiaddr, resolvers } from '@multiformats/multiaddr'\n * import { dnsaddrResolver } from '@multiformats/multiaddr/resolvers'\n *\n * resolvers.set('dnsaddr', dnsaddrResolver)\n *\n * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')\n *\n * // resolve with a 5s timeout\n * const resolved = await ma.resolve({\n *   signal: AbortSignal.timeout(5000)\n * })\n *\n * console.info(resolved)\n * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]\n * ```\n *\n * @example Using a custom DNS resolver to resolve DNSADDR Multiaddrs\n *\n * See the docs for [@multiformats/dns](https://www.npmjs.com/package/@multiformats/dns) for a full breakdown of how to specify multiple resolvers or resolvers that can be used for specific TLDs.\n *\n * ```TypeScript\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { dns } from '@multiformats/dns'\n * import { dnsJsonOverHttps } from '@multiformats/dns/resolvers'\n *\n * const resolver = dns({\n *   resolvers: {\n *     '.': dnsJsonOverHttps('https://cloudflare-dns.com/dns-query')\n *   }\n * })\n *\n * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')\n * const resolved = await ma.resolve({\n *  dns: resolver\n * })\n *\n * console.info(resolved)\n * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]\n * ```\n */\n\nimport { stringTuplesToTuples, tuplesToBytes } from './codec.js'\nimport { Multiaddr as MultiaddrClass, symbol } from './multiaddr.js'\nimport { getProtocol } from './protocols-table.js'\nimport type { Resolver } from './resolvers/index.js'\nimport type { DNS } from '@multiformats/dns'\n\n/**\n * Protocols are present in the protocol table\n */\nexport interface Protocol {\n  code: number\n  size: number\n  name: string\n  resolvable?: boolean | undefined\n  path?: boolean | undefined\n}\n\n/**\n * A plain JavaScript object representation of a {@link Multiaddr}\n */\nexport interface MultiaddrObject {\n  family: 4 | 6\n  host: string\n  transport: 'tcp' | 'udp'\n  port: number\n}\n\n/**\n * A NodeAddress is an IPv4/IPv6 address/TCP port combination\n */\nexport interface NodeAddress {\n  family: 4 | 6\n  address: string\n  port: number\n}\n\n/**\n * These types can be parsed into a {@link Multiaddr} object\n */\nexport type MultiaddrInput = string | Multiaddr | Uint8Array | null\n\n/**\n * A code/value pair\n */\nexport type Tuple = [number, Uint8Array?]\n\n/**\n * A code/value pair with the value as a string\n */\nexport type StringTuple = [number, string?]\n\n/**\n * Allows aborting long-lived operations\n */\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\n/**\n * All configured {@link Resolver}s\n */\nexport const resolvers = new Map<string, Resolver>()\n\nexport type { Resolver }\n\nexport { MultiaddrFilter } from './filter/multiaddr-filter.js'\n\nexport interface ResolveOptions extends AbortOptions {\n  /**\n   * An optional DNS resolver\n   */\n  dns?: DNS\n\n  /**\n   * When resolving DNSADDR Multiaddrs that resolve to other DNSADDR Multiaddrs,\n   * limit how many times we will recursively resolve them.\n   *\n   * @default 32\n   */\n  maxRecursiveDepth?: number\n}\n\nexport interface Multiaddr {\n  bytes: Uint8Array\n\n  /**\n   * Returns Multiaddr as a String\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\n   * // '/ip4/127.0.0.1/tcp/4001'\n   * ```\n   */\n  toString(): string\n\n  /**\n   * Returns Multiaddr as a JSON encoded object\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * JSON.stringify(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // '/ip4/127.0.0.1/tcp/4001'\n   * ```\n   */\n  toJSON(): string\n\n  /**\n   * Returns Multiaddr as a convinient options object to be used with net.createConnection\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()\n   * // { family: 4, host: '127.0.0.1', transport: 'tcp', port: 4001 }\n   * ```\n   */\n  toOptions(): MultiaddrObject\n\n  /**\n   * Returns the protocols the Multiaddr is defined with, as an array of objects, in\n   * left-to-right order. Each object contains the protocol code, protocol name,\n   * and the size of its address space in bits.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').protos()\n   * // [ { code: 4, size: 32, name: 'ip4' },\n   * //   { code: 6, size: 16, name: 'tcp' } ]\n   * ```\n   */\n  protos(): Protocol[]\n\n  /**\n   * Returns the codes of the protocols in left-to-right order.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()\n   * // [ 4, 6 ]\n   * ```\n   */\n  protoCodes(): number[]\n\n  /**\n   * Returns the names of the protocols in left-to-right order.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()\n   * // [ 'ip4', 'tcp' ]\n   * ```\n   */\n  protoNames(): string[]\n\n  /**\n   * Returns a tuple of parts\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').tuples()\n   * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]\n   * ```\n   */\n  tuples(): Tuple[]\n\n  /**\n   * Returns a tuple of string/number parts\n   * - tuples[][0] = code of protocol\n   * - tuples[][1] = contents of address\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').stringTuples()\n   * // [ [ 4, '127.0.0.1' ], [ 6, '4001' ] ]\n   * ```\n   */\n  stringTuples(): StringTuple[]\n\n  /**\n   * Encapsulates a Multiaddr in another Multiaddr\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh3.toString()\n   * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\n   * ```\n   *\n   * @param {MultiaddrInput} addr - Multiaddr to add into this Multiaddr\n   */\n  encapsulate(addr: MultiaddrInput): Multiaddr\n\n  /**\n   * Decapsulates a Multiaddr from another Multiaddr\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh3.decapsulate(mh2).toString()\n   * // '/ip4/8.8.8.8/tcp/1080'\n   * ```\n   *\n   * @param {Multiaddr | string} addr - Multiaddr to remove from this Multiaddr\n   */\n  decapsulate(addr: Multiaddr | string): Multiaddr\n\n  /**\n   * A more reliable version of `decapsulate` if you are targeting a\n   * specific code, such as 421 (the `p2p` protocol code). The last index of the code\n   * will be removed from the `Multiaddr`, and a new instance will be returned.\n   * If the code is not present, the original `Multiaddr` is returned.\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const addr = multiaddr('/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC')\n   * // Multiaddr(/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC)\n   *\n   * addr.decapsulateCode(421).toString()\n   * // '/ip4/0.0.0.0/tcp/8080'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/8080').decapsulateCode(421).toString()\n   * // '/ip4/127.0.0.1/tcp/8080'\n   * ```\n   */\n  decapsulateCode(code: number): Multiaddr\n\n  /**\n   * Extract the peerId if the multiaddr contains one\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string)\n   *\n   * // should return QmValidBase58string or null if the id is missing or invalid\n   * const peerId = mh1.getPeerId()\n   * ```\n   */\n  getPeerId(): string | null\n\n  /**\n   * Extract the path if the multiaddr contains one\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock)\n   *\n   * // should return utf8 string or null if the id is missing or invalid\n   * const path = mh1.getPath()\n   * ```\n   */\n  getPath(): string | null\n\n  /**\n   * Checks if two Multiaddrs are the same\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh1.equals(mh1)\n   * // true\n   *\n   * mh1.equals(mh2)\n   * // false\n   * ```\n   */\n  equals(addr: { bytes: Uint8Array }): boolean\n\n  /**\n   * Resolve multiaddr if containing resolvable hostname.\n   *\n   * @example\n   * ```js\n   * import { multiaddr, resolvers } from '@multiformats/multiaddr'\n   *\n   * resolvers.set('dnsaddr', resolverFunction)\n   * const mh1 = multiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb')\n   * const resolvedMultiaddrs = await mh1.resolve()\n   * // [\n   * //   Multiaddr(/ip4/147.75.83.83/tcp/4001/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb),\n   * //   Multiaddr(/ip4/147.75.83.83/tcp/443/wss/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb),\n   * //   Multiaddr(/ip4/147.75.83.83/udp/4001/quic/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb)\n   * // ]\n   * ```\n   */\n  resolve(options?: ResolveOptions): Promise<Multiaddr[]>\n\n  /**\n   * Gets a Multiaddrs node-friendly address object. Note that protocol information\n   * is left out: in Node (and most network systems) the protocol is unknowable\n   * given only the address.\n   *\n   * Has to be a ThinWaist Address, otherwise throws error\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()\n   * // {family: 4, address: '127.0.0.1', port: 4001}\n   * ```\n   */\n  nodeAddress(): NodeAddress\n\n  /**\n   * Returns if a Multiaddr is a Thin Waist address or not.\n   *\n   * Thin Waist is if a Multiaddr adheres to the standard combination of:\n   *\n   * `{IPv4, IPv6}/{TCP, UDP}`\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   * const mh2 = multiaddr('/ip4/192.168.2.1/tcp/5001')\n   * // Multiaddr(/ip4/192.168.2.1/tcp/5001)\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001)\n   * const mh4 = multiaddr('/ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a)\n   * mh1.isThinWaistAddress()\n   * // true\n   * mh2.isThinWaistAddress()\n   * // true\n   * mh3.isThinWaistAddress()\n   * // false\n   * mh4.isThinWaistAddress()\n   * // false\n   * ```\n   */\n  isThinWaistAddress(addr?: Multiaddr): boolean\n}\n\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @example\n * ```js\n * import { fromNodeAddress } from '@multiformats/multiaddr'\n *\n * fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n */\nexport function fromNodeAddress (addr: NodeAddress, transport: string): Multiaddr {\n  if (addr == null) {\n    throw new Error('requires node address object')\n  }\n  if (transport == null) {\n    throw new Error('requires transport protocol')\n  }\n  let ip: string | undefined\n  let host = addr.address\n  switch (addr.family) {\n    case 4:\n      ip = 'ip4'\n      break\n    case 6:\n      ip = 'ip6'\n\n      if (host.includes('%')) {\n        const parts = host.split('%')\n\n        if (parts.length !== 2) {\n          throw Error('Multiple ip6 zones in multiaddr')\n        }\n\n        host = parts[0]\n        const zone = parts[1]\n        ip = `/ip6zone/${zone}/ip6`\n      }\n      break\n    default:\n      throw Error('Invalid addr family, should be 4 or 6.')\n  }\n  return new MultiaddrClass('/' + [ip, host, transport, addr.port].join('/'))\n}\n\n/**\n * Create a {@link Multiaddr} from an array of {@link Tuple}s\n *\n * @example\n *\n * ```ts\n * import { fromTuples, multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1')\n * const tuples = ma.tuples()\n *\n * const ma2 = fromTuples(tuples)\n *\n * console.info(ma2)\n * // '/ip4/127.0.0.1'\n * ```\n */\nexport function fromTuples (tuples: Tuple[]): Multiaddr {\n  return multiaddr(tuplesToBytes(tuples))\n}\n\n/**\n * Create a {@link Multiaddr} from an array of {@link StringTuple}s\n *\n * @example\n *\n * ```ts\n * import { fromStringTuples, multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1')\n * const tuples = ma.stringTuples()\n *\n * const ma2 = fromStringTuples(tuples)\n *\n * console.info(ma2)\n * // '/ip4/127.0.0.1'\n * ```\n */\nexport function fromStringTuples (tuples: StringTuple[]): Multiaddr {\n  return fromTuples(stringTuplesToTuples(tuples))\n}\n\n/**\n * Returns if something is a {@link Multiaddr} that is a resolvable name\n *\n * @example\n *\n * ```js\n * import { isName, multiaddr } from '@multiformats/multiaddr'\n *\n * isName(multiaddr('/ip4/127.0.0.1'))\n * // false\n * isName(multiaddr('/dns/ipfs.io'))\n * // true\n * ```\n */\nexport function isName (addr: Multiaddr): boolean {\n  if (!isMultiaddr(addr)) {\n    return false\n  }\n\n  // if a part of the multiaddr is resolvable, then return true\n  return addr.protos().some((proto) => proto.resolvable)\n}\n\n/**\n * Check if object is a {@link Multiaddr} instance\n *\n * @example\n *\n * ```js\n * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\n *\n * isMultiaddr(5)\n * // false\n * isMultiaddr(multiaddr('/ip4/127.0.0.1'))\n * // true\n * ```\n */\nexport function isMultiaddr (value: any): value is Multiaddr {\n  return Boolean(value?.[symbol])\n}\n\n/**\n * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}\n *\n * @example\n * ```js\n * import { multiaddr } from '@libp2p/multiaddr'\n *\n * multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n *\n * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n */\nexport function multiaddr (addr?: MultiaddrInput): Multiaddr {\n  return new MultiaddrClass(addr)\n}\n\nexport { getProtocol as protocols }\n"],
  "mappings": "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",
  "names": ["toString", "multiaddr", "toString", "decode", "decode"]
}
