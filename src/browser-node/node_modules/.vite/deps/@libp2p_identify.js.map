{
  "version": 3,
  "sources": ["../../.pnpm/@libp2p+peer-record@8.0.26/node_modules/@libp2p/peer-record/src/envelope/envelope.ts", "../../.pnpm/@libp2p+peer-record@8.0.26/node_modules/@libp2p/peer-record/src/envelope/errors.ts", "../../.pnpm/@libp2p+peer-record@8.0.26/node_modules/@libp2p/peer-record/src/envelope/index.ts", "../../.pnpm/@libp2p+utils@6.6.1/node_modules/@libp2p/utils/src/array-equals.ts", "../../.pnpm/@libp2p+peer-record@8.0.26/node_modules/@libp2p/peer-record/src/peer-record/consts.ts", "../../.pnpm/@libp2p+peer-record@8.0.26/node_modules/@libp2p/peer-record/src/peer-record/peer-record.ts", "../../.pnpm/@libp2p+peer-record@8.0.26/node_modules/@libp2p/peer-record/src/peer-record/index.ts", "../../.pnpm/@libp2p+identify@3.0.28/node_modules/@libp2p/identify/src/consts.ts", "../../.pnpm/@libp2p+identify@3.0.28/node_modules/@libp2p/identify/src/pb/message.ts", "../../.pnpm/@libp2p+identify@3.0.28/node_modules/@libp2p/identify/src/utils.ts", "../../.pnpm/@libp2p+identify@3.0.28/node_modules/@libp2p/identify/src/identify-push.ts", "../../.pnpm/@libp2p+utils@6.6.1/node_modules/@libp2p/utils/src/multiaddr/is-global-unicast.ts", "../../.pnpm/@libp2p+utils@6.6.1/node_modules/@libp2p/utils/src/private-ip.ts", "../../.pnpm/@libp2p+utils@6.6.1/node_modules/@libp2p/utils/src/multiaddr/is-ip-based.ts", "../../.pnpm/@libp2p+utils@6.6.1/node_modules/@libp2p/utils/src/multiaddr/is-private.ts", "../../.pnpm/@libp2p+identify@3.0.28/node_modules/@libp2p/identify/src/identify.ts", "../../.pnpm/@libp2p+identify@3.0.28/node_modules/@libp2p/identify/src/index.ts"],
  "sourcesContent": ["/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { type Codec, decodeMessage, type DecodeOptions, encodeMessage, message } from 'protons-runtime'\nimport { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Envelope {\n  publicKey: Uint8Array\n  payloadType: Uint8Array\n  payload: Uint8Array\n  signature: Uint8Array\n}\n\nexport namespace Envelope {\n  let _codec: Codec<Envelope>\n\n  export const codec = (): Codec<Envelope> => {\n    if (_codec == null) {\n      _codec = message<Envelope>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.publicKey != null && obj.publicKey.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.publicKey)\n        }\n\n        if ((obj.payloadType != null && obj.payloadType.byteLength > 0)) {\n          w.uint32(18)\n          w.bytes(obj.payloadType)\n        }\n\n        if ((obj.payload != null && obj.payload.byteLength > 0)) {\n          w.uint32(26)\n          w.bytes(obj.payload)\n        }\n\n        if ((obj.signature != null && obj.signature.byteLength > 0)) {\n          w.uint32(42)\n          w.bytes(obj.signature)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          publicKey: uint8ArrayAlloc(0),\n          payloadType: uint8ArrayAlloc(0),\n          payload: uint8ArrayAlloc(0),\n          signature: uint8ArrayAlloc(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.publicKey = reader.bytes()\n              break\n            }\n            case 2: {\n              obj.payloadType = reader.bytes()\n              break\n            }\n            case 3: {\n              obj.payload = reader.bytes()\n              break\n            }\n            case 5: {\n              obj.signature = reader.bytes()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Envelope>): Uint8Array => {\n    return encodeMessage(obj, Envelope.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Envelope>): Envelope => {\n    return decodeMessage(buf, Envelope.codec(), opts)\n  }\n}\n", "/**\n * The key in the record is not valid for the domain\n */\nexport class InvalidSignatureError extends Error {\n  constructor (message = 'Invalid signature') {\n    super(message)\n    this.name = 'InvalidSignatureError'\n  }\n}\n", "import { publicKeyFromProtobuf, publicKeyToProtobuf } from '@libp2p/crypto/keys'\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { fromString as uint8arraysFromString } from 'uint8arrays/from-string'\nimport { Envelope as Protobuf } from './envelope.js'\nimport { InvalidSignatureError } from './errors.js'\nimport type { Record, Envelope, PrivateKey, PublicKey } from '@libp2p/interface'\n\nexport interface RecordEnvelopeInit {\n  publicKey: PublicKey\n  payloadType: Uint8Array\n  payload: Uint8Array\n  signature: Uint8Array\n}\n\nexport class RecordEnvelope implements Envelope {\n  /**\n   * Unmarshal a serialized Envelope protobuf message\n   */\n  static createFromProtobuf = async (data: Uint8Array | Uint8ArrayList): Promise<RecordEnvelope> => {\n    const envelopeData = Protobuf.decode(data)\n    const publicKey = publicKeyFromProtobuf(envelopeData.publicKey)\n\n    return new RecordEnvelope({\n      publicKey,\n      payloadType: envelopeData.payloadType,\n      payload: envelopeData.payload,\n      signature: envelopeData.signature\n    })\n  }\n\n  /**\n   * Seal marshals the given Record, places the marshaled bytes inside an Envelope\n   * and signs it with the given peerId's private key\n   */\n  static seal = async (record: Record, privateKey: PrivateKey): Promise<RecordEnvelope> => {\n    if (privateKey == null) {\n      throw new Error('Missing private key')\n    }\n\n    const domain = record.domain\n    const payloadType = record.codec\n    const payload = record.marshal()\n    const signData = formatSignaturePayload(domain, payloadType, payload)\n    const signature = await privateKey.sign(signData.subarray())\n\n    return new RecordEnvelope({\n      publicKey: privateKey.publicKey,\n      payloadType,\n      payload,\n      signature\n    })\n  }\n\n  /**\n   * Open and certify a given marshaled envelope.\n   * Data is unmarshaled and the signature validated for the given domain.\n   */\n  static openAndCertify = async (data: Uint8Array | Uint8ArrayList, domain: string): Promise<RecordEnvelope> => {\n    const envelope = await RecordEnvelope.createFromProtobuf(data)\n    const valid = await envelope.validate(domain)\n\n    if (!valid) {\n      throw new InvalidSignatureError('Envelope signature is not valid for the given domain')\n    }\n\n    return envelope\n  }\n\n  public publicKey: PublicKey\n  public payloadType: Uint8Array\n  public payload: Uint8Array\n  public signature: Uint8Array\n  public marshaled?: Uint8Array\n\n  /**\n   * The Envelope is responsible for keeping an arbitrary signed record\n   * by a libp2p peer.\n   */\n  constructor (init: RecordEnvelopeInit) {\n    const { publicKey, payloadType, payload, signature } = init\n\n    this.publicKey = publicKey\n    this.payloadType = payloadType\n    this.payload = payload\n    this.signature = signature\n  }\n\n  /**\n   * Marshal the envelope content\n   */\n  marshal (): Uint8Array {\n    if (this.marshaled == null) {\n      this.marshaled = Protobuf.encode({\n        publicKey: publicKeyToProtobuf(this.publicKey),\n        payloadType: this.payloadType,\n        payload: this.payload.subarray(),\n        signature: this.signature\n      })\n    }\n\n    return this.marshaled\n  }\n\n  /**\n   * Verifies if the other Envelope is identical to this one\n   */\n  equals (other: Envelope): boolean {\n    return uint8ArrayEquals(this.marshal(), other.marshal())\n  }\n\n  /**\n   * Validate envelope data signature for the given domain\n   */\n  async validate (domain: string): Promise<boolean> {\n    const signData = formatSignaturePayload(domain, this.payloadType, this.payload)\n\n    return this.publicKey.verify(signData.subarray(), this.signature)\n  }\n}\n\n/**\n * Helper function that prepares a Uint8Array to sign or verify a signature\n */\nconst formatSignaturePayload = (domain: string, payloadType: Uint8Array, payload: Uint8Array | Uint8ArrayList): Uint8ArrayList => {\n  // When signing, a peer will prepare a Uint8Array by concatenating the following:\n  // - The length of the domain separation string string in bytes\n  // - The domain separation string, encoded as UTF-8\n  // - The length of the payload_type field in bytes\n  // - The value of the payload_type field\n  // - The length of the payload field in bytes\n  // - The value of the payload field\n\n  const domainUint8Array = uint8arraysFromString(domain)\n  const domainLength = varint.encode(domainUint8Array.byteLength)\n  const payloadTypeLength = varint.encode(payloadType.length)\n  const payloadLength = varint.encode(payload.length)\n\n  return new Uint8ArrayList(\n    domainLength,\n    domainUint8Array,\n    payloadTypeLength,\n    payloadType,\n    payloadLength,\n    payload\n  )\n}\n", "/**\n * @packageDocumentation\n *\n * Provides strategies ensure arrays are equivalent.\n *\n * @example\n *\n * ```typescript\n * import { arrayEquals } from '@libp2p/utils/array-equals'\n * import { multiaddr } from '@multformats/multiaddr'\n *\n * const ma1 = multiaddr('/ip4/127.0.0.1/tcp/9000'),\n * const ma2 = multiaddr('/ip4/82.41.53.1/tcp/9000')\n *\n * console.info(arrayEquals([ma1], [ma1])) // true\n * console.info(arrayEquals([ma1], [ma2])) // false\n * ```\n */\n\n/**\n * Verify if two arrays of non primitive types with the \"equals\" function are equal.\n * Compatible with multiaddr, peer-id and others.\n */\nexport function arrayEquals (a: any[], b: any[]): boolean {\n  const sort = (a: any, b: any): number => a.toString().localeCompare(b.toString())\n\n  if (a.length !== b.length) {\n    return false\n  }\n\n  b.sort(sort)\n\n  return a.sort(sort).every((item, index) => b[index].equals(item))\n}\n", "// The domain string used for peer records contained in a Envelope.\nexport const ENVELOPE_DOMAIN_PEER_RECORD = 'libp2p-peer-record'\n\n// The type hint used to identify peer records in a Envelope.\n// Defined in https://github.com/multiformats/multicodec/blob/master/table.csv\n// with name \"libp2p-peer-record\"\nexport const ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1])\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { type Codec, decodeMessage, type DecodeOptions, encodeMessage, MaxLengthError, message } from 'protons-runtime'\nimport { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface PeerRecord {\n  peerId: Uint8Array\n  seq: bigint\n  addresses: PeerRecord.AddressInfo[]\n}\n\nexport namespace PeerRecord {\n  export interface AddressInfo {\n    multiaddr: Uint8Array\n  }\n\n  export namespace AddressInfo {\n    let _codec: Codec<AddressInfo>\n\n    export const codec = (): Codec<AddressInfo> => {\n      if (_codec == null) {\n        _codec = message<AddressInfo>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if ((obj.multiaddr != null && obj.multiaddr.byteLength > 0)) {\n            w.uint32(10)\n            w.bytes(obj.multiaddr)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {\n            multiaddr: uint8ArrayAlloc(0)\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.multiaddr = reader.bytes()\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<AddressInfo>): Uint8Array => {\n      return encodeMessage(obj, AddressInfo.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<AddressInfo>): AddressInfo => {\n      return decodeMessage(buf, AddressInfo.codec(), opts)\n    }\n  }\n\n  let _codec: Codec<PeerRecord>\n\n  export const codec = (): Codec<PeerRecord> => {\n    if (_codec == null) {\n      _codec = message<PeerRecord>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.peerId != null && obj.peerId.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.peerId)\n        }\n\n        if ((obj.seq != null && obj.seq !== 0n)) {\n          w.uint32(16)\n          w.uint64(obj.seq)\n        }\n\n        if (obj.addresses != null) {\n          for (const value of obj.addresses) {\n            w.uint32(26)\n            PeerRecord.AddressInfo.codec().encode(value, w)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          peerId: uint8ArrayAlloc(0),\n          seq: 0n,\n          addresses: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.peerId = reader.bytes()\n              break\n            }\n            case 2: {\n              obj.seq = reader.uint64()\n              break\n            }\n            case 3: {\n              if (opts.limits?.addresses != null && obj.addresses.length === opts.limits.addresses) {\n                throw new MaxLengthError('Decode error - map field \"addresses\" had too many elements')\n              }\n\n              obj.addresses.push(PeerRecord.AddressInfo.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.addresses$\n              }))\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PeerRecord>): Uint8Array => {\n    return encodeMessage(obj, PeerRecord.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<PeerRecord>): PeerRecord => {\n    return decodeMessage(buf, PeerRecord.codec(), opts)\n  }\n}\n", "import { peerIdFromMultihash } from '@libp2p/peer-id'\nimport { arrayEquals } from '@libp2p/utils/array-equals'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport * as Digest from 'multiformats/hashes/digest'\nimport {\n  ENVELOPE_DOMAIN_PEER_RECORD,\n  ENVELOPE_PAYLOAD_TYPE_PEER_RECORD\n} from './consts.js'\nimport { PeerRecord as Protobuf } from './peer-record.js'\nimport type { PeerId } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface PeerRecordInit {\n  peerId: PeerId\n\n  /**\n   * Addresses of the associated peer.\n   */\n  multiaddrs?: Multiaddr[]\n\n  /**\n   * Monotonically-increasing sequence counter that's used to order PeerRecords in time.\n   */\n  seqNumber?: bigint\n}\n\n/**\n * The PeerRecord is used for distributing peer routing records across the network.\n * It contains the peer's reachable listen addresses.\n */\nexport class PeerRecord {\n  /**\n   * Unmarshal Peer Record Protobuf\n   */\n  static createFromProtobuf = (buf: Uint8Array | Uint8ArrayList): PeerRecord => {\n    const peerRecord = Protobuf.decode(buf)\n    const peerId = peerIdFromMultihash(Digest.decode(peerRecord.peerId))\n    const multiaddrs = (peerRecord.addresses ?? []).map((a) => multiaddr(a.multiaddr))\n    const seqNumber = peerRecord.seq\n\n    return new PeerRecord({ peerId, multiaddrs, seqNumber })\n  }\n\n  static DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD\n  static CODEC = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD\n\n  public peerId: PeerId\n  public multiaddrs: Multiaddr[]\n  public seqNumber: bigint\n  public domain = PeerRecord.DOMAIN\n  public codec = PeerRecord.CODEC\n  private marshaled?: Uint8Array\n\n  constructor (init: PeerRecordInit) {\n    const { peerId, multiaddrs, seqNumber } = init\n\n    this.peerId = peerId\n    this.multiaddrs = multiaddrs ?? []\n    this.seqNumber = seqNumber ?? BigInt(Date.now())\n  }\n\n  /**\n   * Marshal a record to be used in an envelope\n   */\n  marshal (): Uint8Array {\n    if (this.marshaled == null) {\n      this.marshaled = Protobuf.encode({\n        peerId: this.peerId.toMultihash().bytes,\n        seq: BigInt(this.seqNumber),\n        addresses: this.multiaddrs.map((m) => ({\n          multiaddr: m.bytes\n        }))\n      })\n    }\n\n    return this.marshaled\n  }\n\n  /**\n   * Returns true if `this` record equals the `other`\n   */\n  equals (other: unknown): boolean {\n    if (!(other instanceof PeerRecord)) {\n      return false\n    }\n\n    // Validate PeerId\n    if (!this.peerId.equals(other.peerId)) {\n      return false\n    }\n\n    // Validate seqNumber\n    if (this.seqNumber !== other.seqNumber) {\n      return false\n    }\n\n    // Validate multiaddrs\n    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {\n      return false\n    }\n\n    return true\n  }\n}\n", "export const PROTOCOL_VERSION = 'ipfs/0.1.0' // deprecated\nexport const MULTICODEC_IDENTIFY = '/ipfs/id/1.0.0' // deprecated\nexport const MULTICODEC_IDENTIFY_PUSH = '/ipfs/id/push/1.0.0' // deprecated\n\nexport const IDENTIFY_PROTOCOL_VERSION = '0.1.0'\nexport const MULTICODEC_IDENTIFY_PROTOCOL_NAME = 'id'\nexport const MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = 'id/push'\nexport const MULTICODEC_IDENTIFY_PROTOCOL_VERSION = '1.0.0'\nexport const MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = '1.0.0'\n\n// https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L52\nexport const MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8\n\n// https://github.com/libp2p/go-libp2p/blob/0385ec924bad172f74a74db09939e97c079b1420/p2p/protocol/identify/id.go#L47C7-L47C25\nexport const MAX_PUSH_CONCURRENCY = 32\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { type Codec, decodeMessage, type DecodeOptions, encodeMessage, MaxLengthError, message } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Identify {\n  protocolVersion?: string\n  agentVersion?: string\n  publicKey?: Uint8Array\n  listenAddrs: Uint8Array[]\n  observedAddr?: Uint8Array\n  protocols: string[]\n  signedPeerRecord?: Uint8Array\n}\n\nexport namespace Identify {\n  let _codec: Codec<Identify>\n\n  export const codec = (): Codec<Identify> => {\n    if (_codec == null) {\n      _codec = message<Identify>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.protocolVersion != null) {\n          w.uint32(42)\n          w.string(obj.protocolVersion)\n        }\n\n        if (obj.agentVersion != null) {\n          w.uint32(50)\n          w.string(obj.agentVersion)\n        }\n\n        if (obj.publicKey != null) {\n          w.uint32(10)\n          w.bytes(obj.publicKey)\n        }\n\n        if (obj.listenAddrs != null) {\n          for (const value of obj.listenAddrs) {\n            w.uint32(18)\n            w.bytes(value)\n          }\n        }\n\n        if (obj.observedAddr != null) {\n          w.uint32(34)\n          w.bytes(obj.observedAddr)\n        }\n\n        if (obj.protocols != null) {\n          for (const value of obj.protocols) {\n            w.uint32(26)\n            w.string(value)\n          }\n        }\n\n        if (obj.signedPeerRecord != null) {\n          w.uint32(66)\n          w.bytes(obj.signedPeerRecord)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          listenAddrs: [],\n          protocols: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 5: {\n              obj.protocolVersion = reader.string()\n              break\n            }\n            case 6: {\n              obj.agentVersion = reader.string()\n              break\n            }\n            case 1: {\n              obj.publicKey = reader.bytes()\n              break\n            }\n            case 2: {\n              if (opts.limits?.listenAddrs != null && obj.listenAddrs.length === opts.limits.listenAddrs) {\n                throw new MaxLengthError('Decode error - map field \"listenAddrs\" had too many elements')\n              }\n\n              obj.listenAddrs.push(reader.bytes())\n              break\n            }\n            case 4: {\n              obj.observedAddr = reader.bytes()\n              break\n            }\n            case 3: {\n              if (opts.limits?.protocols != null && obj.protocols.length === opts.limits.protocols) {\n                throw new MaxLengthError('Decode error - map field \"protocols\" had too many elements')\n              }\n\n              obj.protocols.push(reader.string())\n              break\n            }\n            case 8: {\n              obj.signedPeerRecord = reader.bytes()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Identify>): Uint8Array => {\n    return encodeMessage(obj, Identify.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Identify>): Identify => {\n    return decodeMessage(buf, Identify.codec(), opts)\n  }\n}\n", "import { publicKeyFromProtobuf } from '@libp2p/crypto/keys'\nimport { InvalidMessageError } from '@libp2p/interface'\nimport { peerIdFromCID, peerIdFromPublicKey } from '@libp2p/peer-id'\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record'\nimport { type Multiaddr, multiaddr } from '@multiformats/multiaddr'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { IDENTIFY_PROTOCOL_VERSION, MAX_IDENTIFY_MESSAGE_SIZE, MAX_PUSH_CONCURRENCY } from './consts.js'\nimport type { IdentifyComponents, IdentifyInit } from './index.js'\nimport type { Identify as IdentifyMessage } from './pb/message.js'\nimport type { Libp2pEvents, IdentifyResult, SignedPeerRecord, Logger, Connection, TypedEventTarget, Peer, PeerData, PeerStore, NodeInfo, Startable, PeerId, IncomingStreamData, PrivateKey } from '@libp2p/interface'\nimport type { AddressManager, Registrar } from '@libp2p/interface-internal'\n\nexport const defaultValues = {\n  protocolPrefix: 'ipfs',\n  timeout: 5000,\n  maxInboundStreams: 1,\n  maxOutboundStreams: 1,\n  maxObservedAddresses: 10,\n  maxMessageSize: MAX_IDENTIFY_MESSAGE_SIZE,\n  runOnConnectionOpen: true,\n  runOnSelfUpdate: true,\n  runOnLimitedConnection: true,\n  concurrency: MAX_PUSH_CONCURRENCY\n}\n\n/**\n * Takes the `addr` and converts it to a Multiaddr if possible\n */\nexport function getCleanMultiaddr (addr: Uint8Array | string | null | undefined): Multiaddr | undefined {\n  if (addr != null && addr.length > 0) {\n    try {\n      return multiaddr(addr)\n    } catch {\n\n    }\n  }\n}\n\nexport function getAgentVersion (nodeInfo: NodeInfo, agentVersion?: string): string {\n  if (agentVersion != null) {\n    return agentVersion\n  }\n\n  return nodeInfo.userAgent\n}\n\nexport async function consumeIdentifyMessage (peerStore: PeerStore, events: TypedEventTarget<Libp2pEvents>, log: Logger, connection: Connection, message: IdentifyMessage): Promise<IdentifyResult> {\n  log('received identify from %p', connection.remotePeer)\n\n  if (message == null) {\n    throw new InvalidMessageError('message was null or undefined')\n  }\n\n  const peer: PeerData = {}\n\n  if (message.listenAddrs.length > 0) {\n    peer.addresses = message.listenAddrs.map(buf => ({\n      isCertified: false,\n      multiaddr: multiaddr(buf)\n    }))\n  }\n\n  if (message.protocols.length > 0) {\n    peer.protocols = message.protocols\n  }\n\n  if (message.publicKey != null) {\n    const publicKey = publicKeyFromProtobuf(message.publicKey)\n    const peerId = peerIdFromPublicKey(publicKey)\n\n    if (!peerId.equals(connection.remotePeer)) {\n      throw new InvalidMessageError('public key did not match remote PeerId')\n    }\n\n    peer.publicKey = publicKey\n  }\n\n  let output: SignedPeerRecord | undefined\n\n  // if the peer record has been sent, prefer the addresses in the record as they are signed by the remote peer\n  if (message.signedPeerRecord != null) {\n    log.trace('received signedPeerRecord from %p', connection.remotePeer)\n\n    let peerRecordEnvelope = message.signedPeerRecord\n    const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope, PeerRecord.DOMAIN)\n    let peerRecord = PeerRecord.createFromProtobuf(envelope.payload)\n    const envelopePeer = peerIdFromCID(envelope.publicKey.toCID())\n\n    // Verify peerId\n    if (!peerRecord.peerId.equals(envelopePeer)) {\n      throw new InvalidMessageError('signing key does not match PeerId in the PeerRecord')\n    }\n\n    // Make sure remote peer is the one sending the record\n    if (!connection.remotePeer.equals(peerRecord.peerId)) {\n      throw new InvalidMessageError('signing key does not match remote PeerId')\n    }\n\n    let existingPeer: Peer | undefined\n\n    try {\n      existingPeer = await peerStore.get(peerRecord.peerId)\n    } catch (err: any) {\n      if (err.name !== 'NotFoundError') {\n        throw err\n      }\n    }\n\n    if (existingPeer != null) {\n      // don't lose any existing metadata\n      peer.metadata = existingPeer.metadata\n\n      // if we have previously received a signed record for this peer, compare it to the incoming one\n      if (existingPeer.peerRecordEnvelope != null) {\n        const storedEnvelope = await RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope)\n        const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload)\n\n        // ensure seq is greater than, or equal to, the last received\n        if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n          log('sequence number was lower or equal to existing sequence number - stored: %d received: %d', storedRecord.seqNumber, peerRecord.seqNumber)\n          peerRecord = storedRecord\n          peerRecordEnvelope = existingPeer.peerRecordEnvelope\n        }\n      }\n    }\n\n    // store the signed record for next time\n    peer.peerRecordEnvelope = peerRecordEnvelope\n\n    // override the stored addresses with the signed multiaddrs\n    peer.addresses = peerRecord.multiaddrs.map(multiaddr => ({\n      isCertified: true,\n      multiaddr\n    }))\n\n    output = {\n      seq: peerRecord.seqNumber,\n      addresses: peerRecord.multiaddrs\n    }\n  } else {\n    log('%p did not send a signed peer record', connection.remotePeer)\n  }\n\n  log.trace('patching %p with', connection.remotePeer, peer)\n  await peerStore.patch(connection.remotePeer, peer)\n\n  if (message.agentVersion != null || message.protocolVersion != null) {\n    const metadata: Record<string, Uint8Array> = {}\n\n    if (message.agentVersion != null) {\n      metadata.AgentVersion = uint8ArrayFromString(message.agentVersion)\n    }\n\n    if (message.protocolVersion != null) {\n      metadata.ProtocolVersion = uint8ArrayFromString(message.protocolVersion)\n    }\n\n    log.trace('merging %p metadata', connection.remotePeer, metadata)\n    await peerStore.merge(connection.remotePeer, {\n      metadata\n    })\n  }\n\n  const result: IdentifyResult = {\n    peerId: connection.remotePeer,\n    protocolVersion: message.protocolVersion,\n    agentVersion: message.agentVersion,\n    publicKey: message.publicKey,\n    listenAddrs: message.listenAddrs.map(buf => multiaddr(buf)),\n    observedAddr: message.observedAddr == null ? undefined : multiaddr(message.observedAddr),\n    protocols: message.protocols,\n    signedPeerRecord: output,\n    connection\n  }\n\n  events.safeDispatchEvent('peer:identify', { detail: result })\n\n  return result\n}\n\nexport interface AbstractIdentifyInit extends IdentifyInit {\n  protocol: string\n  log: Logger\n}\n\nexport abstract class AbstractIdentify implements Startable {\n  public readonly host: {\n    protocolVersion: string\n    agentVersion: string\n  }\n\n  protected protocol: string\n  protected started: boolean\n  protected readonly timeout: number\n  protected readonly peerId: PeerId\n  protected readonly privateKey: PrivateKey\n  protected readonly peerStore: PeerStore\n  protected readonly registrar: Registrar\n  protected readonly addressManager: AddressManager\n  private readonly maxInboundStreams: number\n  private readonly maxOutboundStreams: number\n  protected readonly maxMessageSize: number\n  protected readonly maxObservedAddresses: number\n  protected readonly events: TypedEventTarget<Libp2pEvents>\n  protected readonly runOnLimitedConnection: boolean\n  protected readonly log: Logger\n\n  constructor (components: IdentifyComponents, init: AbstractIdentifyInit) {\n    this.protocol = init.protocol\n    this.started = false\n    this.peerId = components.peerId\n    this.privateKey = components.privateKey\n    this.peerStore = components.peerStore\n    this.registrar = components.registrar\n    this.addressManager = components.addressManager\n    this.events = components.events\n    this.log = init.log\n\n    this.timeout = init.timeout ?? defaultValues.timeout\n    this.maxInboundStreams = init.maxInboundStreams ?? defaultValues.maxInboundStreams\n    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues.maxOutboundStreams\n    this.maxMessageSize = init.maxMessageSize ?? defaultValues.maxMessageSize\n    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses\n    this.runOnLimitedConnection = init.runOnLimitedConnection ?? defaultValues.runOnLimitedConnection\n\n    // Store self host metadata\n    this.host = {\n      protocolVersion: `${init.protocolPrefix ?? defaultValues.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,\n      agentVersion: getAgentVersion(components.nodeInfo, init.agentVersion)\n    }\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  async start (): Promise<void> {\n    if (this.started) {\n      return\n    }\n\n    await this.peerStore.merge(this.peerId, {\n      metadata: {\n        AgentVersion: uint8ArrayFromString(this.host.agentVersion),\n        ProtocolVersion: uint8ArrayFromString(this.host.protocolVersion)\n      }\n    })\n\n    await this.registrar.handle(this.protocol, (data) => {\n      void this.handleProtocol(data).catch(err => {\n        this.log.error(err)\n      })\n    }, {\n      maxInboundStreams: this.maxInboundStreams,\n      maxOutboundStreams: this.maxOutboundStreams,\n      runOnLimitedConnection: this.runOnLimitedConnection\n    })\n\n    this.started = true\n  }\n\n  async stop (): Promise<void> {\n    await this.registrar.unhandle(this.protocol)\n\n    this.started = false\n  }\n\n  protected abstract handleProtocol (data: IncomingStreamData): Promise<void>\n}\n", "/* eslint-disable complexity */\n\nimport { serviceCapabilities, setMaxListeners } from '@libp2p/interface'\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record'\nimport { protocols } from '@multiformats/multiaddr'\nimport drain from 'it-drain'\nimport parallel from 'it-parallel'\nimport { pbStream } from 'it-protobuf-stream'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport {\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION\n} from './consts.js'\nimport { Identify as IdentifyMessage } from './pb/message.js'\nimport { AbstractIdentify, consumeIdentifyMessage, defaultValues } from './utils.js'\nimport type { IdentifyPush as IdentifyPushInterface, IdentifyPushComponents, IdentifyPushInit } from './index.js'\nimport type { Stream, Startable, IncomingStreamData } from '@libp2p/interface'\nimport type { ConnectionManager } from '@libp2p/interface-internal'\n\nexport class IdentifyPush extends AbstractIdentify implements Startable, IdentifyPushInterface {\n  private readonly connectionManager: ConnectionManager\n  private readonly concurrency: number\n\n  constructor (components: IdentifyPushComponents, init: IdentifyPushInit = {}) {\n    super(components, {\n      ...init,\n      protocol: `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`,\n      log: components.logger.forComponent('libp2p:identify-push')\n    })\n\n    this.connectionManager = components.connectionManager\n    this.concurrency = init.concurrency ?? defaultValues.concurrency\n\n    if ((init.runOnSelfUpdate ?? defaultValues.runOnSelfUpdate)) {\n      // When self peer record changes, trigger identify-push\n      components.events.addEventListener('self:peer:update', (evt) => {\n        void this.push().catch(err => { this.log.error(err) })\n      })\n    }\n  }\n\n  [serviceCapabilities]: string[] = [\n    '@libp2p/identify-push'\n  ]\n\n  /**\n   * Calls `push` on all peer connections\n   */\n  async push (): Promise<void> {\n    // Do not try to push if we are not running\n    if (!this.isStarted()) {\n      return\n    }\n\n    const listenAddresses = this.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code))\n    const peerRecord = new PeerRecord({\n      peerId: this.peerId,\n      multiaddrs: listenAddresses\n    })\n    const signedPeerRecord = await RecordEnvelope.seal(peerRecord, this.privateKey)\n    const supportedProtocols = this.registrar.getProtocols()\n    const peer = await this.peerStore.get(this.peerId)\n    const agentVersion = uint8ArrayToString(peer.metadata.get('AgentVersion') ?? uint8ArrayFromString(this.host.agentVersion))\n    const protocolVersion = uint8ArrayToString(peer.metadata.get('ProtocolVersion') ?? uint8ArrayFromString(this.host.protocolVersion))\n    const self = this\n\n    async function * pushToConnections (): AsyncGenerator<() => Promise<void>> {\n      for (const connection of self.connectionManager.getConnections()) {\n        const peer = await self.peerStore.get(connection.remotePeer)\n\n        if (!peer.protocols.includes(self.protocol)) {\n          continue\n        }\n\n        yield async () => {\n          let stream: Stream | undefined\n          const signal = AbortSignal.timeout(self.timeout)\n\n          setMaxListeners(Infinity, signal)\n\n          try {\n            stream = await connection.newStream(self.protocol, {\n              signal,\n              runOnLimitedConnection: self.runOnLimitedConnection\n            })\n\n            const pb = pbStream(stream, {\n              maxDataLength: self.maxMessageSize\n            }).pb(IdentifyMessage)\n\n            await pb.write({\n              listenAddrs: listenAddresses.map(ma => ma.bytes),\n              signedPeerRecord: signedPeerRecord.marshal(),\n              protocols: supportedProtocols,\n              agentVersion,\n              protocolVersion\n            }, {\n              signal\n            })\n\n            await stream.close({\n              signal\n            })\n          } catch (err: any) {\n            // Just log errors\n            self.log.error('could not push identify update to peer', err)\n            stream?.abort(err)\n          }\n        }\n      }\n    }\n\n    await drain(parallel(pushToConnections(), {\n      concurrency: this.concurrency\n    }))\n  }\n\n  /**\n   * Reads the Identify Push message from the given `connection`\n   */\n  async handleProtocol (data: IncomingStreamData): Promise<void> {\n    const { connection, stream } = data\n\n    try {\n      if (this.peerId.equals(connection.remotePeer)) {\n        throw new Error('received push from ourselves?')\n      }\n\n      const options = {\n        signal: AbortSignal.timeout(this.timeout)\n      }\n\n      const pb = pbStream(stream, {\n        maxDataLength: this.maxMessageSize\n      }).pb(IdentifyMessage)\n\n      const message = await pb.read(options)\n      await stream.close(options)\n\n      await consumeIdentifyMessage(this.peerStore, this.events, this.log, connection, message)\n    } catch (err: any) {\n      this.log.error('received invalid message', err)\n      stream.abort(err)\n      return\n    }\n\n    this.log.trace('handled push from %p', connection.remotePeer)\n  }\n}\n", "import { cidrContains } from '@chainsafe/netmask'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst CODEC_IP6 = 0x29\n\n/**\n * Check if a given multiaddr is an IPv6 global unicast address\n */\nexport function isGlobalUnicast (ma: Multiaddr): boolean {\n  try {\n    const [[codec, value]] = ma.stringTuples()\n\n    if (value == null) {\n      return false\n    }\n\n    if (codec === CODEC_IP6) {\n      return cidrContains('2000::/3', value)\n    }\n  } catch {\n\n  }\n\n  return false\n}\n", "import { isIPv4, isIPv6 } from '@chainsafe/is-ip'\nimport { Netmask } from 'netmask'\n\nconst PRIVATE_IP_RANGES = [\n  '0.0.0.0/8',\n  '10.0.0.0/8',\n  '100.64.0.0/10',\n  '127.0.0.0/8',\n  '169.254.0.0/16',\n  '172.16.0.0/12',\n  '192.0.0.0/24',\n  '192.0.0.0/29',\n  '192.0.0.8/32',\n  '192.0.0.9/32',\n  '192.0.0.10/32',\n  '192.0.0.170/32',\n  '192.0.0.171/32',\n  '192.0.2.0/24',\n  '192.31.196.0/24',\n  '192.52.193.0/24',\n  '192.88.99.0/24',\n  '192.168.0.0/16',\n  '192.175.48.0/24',\n  '198.18.0.0/15',\n  '198.51.100.0/24',\n  '203.0.113.0/24',\n  '240.0.0.0/4',\n  '255.255.255.255/32'\n]\n\nconst NETMASK_RANGES = PRIVATE_IP_RANGES.map(ipRange => new Netmask(ipRange))\n\nfunction ipv4Check (ipAddr: string): boolean {\n  for (const r of NETMASK_RANGES) {\n    if (r.contains(ipAddr)) return true\n  }\n\n  return false\n}\n\nfunction isIpv4MappedIpv6 (ipAddr: string): boolean {\n  return /^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(ipAddr)\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc4291#section-2.5.5.2\n */\nfunction ipv4MappedIpv6Check (ipAddr: string): boolean {\n  const parts = ipAddr.split(':')\n\n  if (parts.length < 2) {\n    return false\n  }\n\n  const octet34 = parts[parts.length - 1].padStart(4, '0')\n  const octet12 = parts[parts.length - 2].padStart(4, '0')\n\n  const ip4 = `${parseInt(octet12.substring(0, 2), 16)}.${parseInt(octet12.substring(2), 16)}.${parseInt(octet34.substring(0, 2), 16)}.${parseInt(octet34.substring(2), 16)}`\n\n  return ipv4Check(ip4)\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc4291#section-2.2 example 3\n */\nfunction isIpv4EmbeddedIpv6 (ipAddr: string): boolean {\n  return /^::ffff:([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/.test(ipAddr)\n}\n\nfunction ipv4EmbeddedIpv6Check (ipAddr: string): boolean {\n  const parts = ipAddr.split(':')\n  const ip4 = parts[parts.length - 1]\n\n  return ipv4Check(ip4)\n}\n\nfunction ipv6Check (ipAddr: string): boolean {\n  return /^::$/.test(ipAddr) ||\n    /^::1$/.test(ipAddr) ||\n    /^64:ff9b::([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/.test(ipAddr) ||\n    /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n    /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n    /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n    /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n    /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n    /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ipAddr) ||\n    /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ipAddr) ||\n    /^ff([0-9a-fA-F]{2,2}):/i.test(ipAddr)\n}\n\nexport function isPrivateIp (ip: string): boolean | undefined {\n  if (isIPv4(ip)) return ipv4Check(ip)\n  else if (isIpv4MappedIpv6(ip)) return ipv4MappedIpv6Check(ip)\n  else if (isIpv4EmbeddedIpv6(ip)) return ipv4EmbeddedIpv6Check(ip)\n  else if (isIPv6(ip)) return ipv6Check(ip)\n  else return undefined\n}\n", "import type { Multiaddr } from '@multiformats/multiaddr'\n\nconst CODEC_IP4 = 0x04\nconst CODEC_IP6 = 0x29\n\n/**\n * Check if a given multiaddr is IP-based\n */\nexport function isIpBased (ma: Multiaddr): boolean {\n  try {\n    const [[codec]] = ma.stringTuples()\n\n    return codec === CODEC_IP4 || codec === CODEC_IP6\n  } catch {\n\n  }\n\n  return false\n}\n", "import { isPrivateIp } from '../private-ip.js'\nimport { isIpBased } from './is-ip-based.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n/**\n * Check if a given multiaddr starts with a private address\n */\nexport function isPrivate (ma: Multiaddr): boolean {\n  try {\n    if (!isIpBased(ma)) {\n      // not an IP based multiaddr, cannot be private\n      return false\n    }\n\n    const [[, value]] = ma.stringTuples()\n\n    if (value == null) {\n      return false\n    }\n\n    return isPrivateIp(value) ?? false\n  } catch {\n\n  }\n\n  return true\n}\n", "/* eslint-disable complexity */\n\nimport { publicKeyFromProtobuf, publicKeyToProtobuf } from '@libp2p/crypto/keys'\nimport { InvalidMessageError, UnsupportedProtocolError, serviceCapabilities, setMaxListeners } from '@libp2p/interface'\nimport { peerIdFromCID } from '@libp2p/peer-id'\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record'\nimport { isGlobalUnicast } from '@libp2p/utils/multiaddr/is-global-unicast'\nimport { isPrivate } from '@libp2p/utils/multiaddr/is-private'\nimport { protocols } from '@multiformats/multiaddr'\nimport { IP_OR_DOMAIN, TCP } from '@multiformats/multiaddr-matcher'\nimport { pbStream } from 'it-protobuf-stream'\nimport {\n  MULTICODEC_IDENTIFY_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PROTOCOL_VERSION\n} from './consts.js'\nimport { Identify as IdentifyMessage } from './pb/message.js'\nimport { AbstractIdentify, consumeIdentifyMessage, defaultValues, getCleanMultiaddr } from './utils.js'\nimport type { Identify as IdentifyInterface, IdentifyComponents, IdentifyInit } from './index.js'\nimport type { IdentifyResult, AbortOptions, Connection, Stream, Startable, IncomingStreamData } from '@libp2p/interface'\n\nconst CODEC_IP6 = 0x29\n\nexport class Identify extends AbstractIdentify implements Startable, IdentifyInterface {\n  constructor (components: IdentifyComponents, init: IdentifyInit = {}) {\n    super(components, {\n      ...init,\n      protocol: `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,\n      log: components.logger.forComponent('libp2p:identify')\n    })\n\n    if (init.runOnConnectionOpen ?? defaultValues.runOnConnectionOpen) {\n      // When a new connection happens, trigger identify\n      components.events.addEventListener('connection:open', (evt) => {\n        const connection = evt.detail\n        this.identify(connection)\n          .catch(err => {\n            if (err.name === UnsupportedProtocolError.name) {\n              // the remote did not support identify, ignore the error\n              return\n            }\n\n            this.log.error('error during identify trigged by connection:open', err)\n          })\n      })\n    }\n  }\n\n  [serviceCapabilities]: string[] = [\n    '@libp2p/identify'\n  ]\n\n  async _identify (connection: Connection, options: AbortOptions = {}): Promise<IdentifyMessage> {\n    let stream: Stream | undefined\n\n    if (options.signal == null) {\n      const signal = AbortSignal.timeout(this.timeout)\n      setMaxListeners(Infinity, signal)\n\n      options = {\n        ...options,\n        signal\n      }\n    }\n\n    try {\n      stream = await connection.newStream(this.protocol, {\n        ...options,\n        runOnLimitedConnection: this.runOnLimitedConnection\n      })\n\n      const pb = pbStream(stream, {\n        maxDataLength: this.maxMessageSize\n      }).pb(IdentifyMessage)\n\n      const message = await pb.read(options)\n\n      await stream.close(options)\n\n      return message\n    } catch (err: any) {\n      stream?.abort(err)\n      throw err\n    }\n  }\n\n  async identify (connection: Connection, options: AbortOptions = {}): Promise<IdentifyResult> {\n    const message = await this._identify(connection, options)\n    const {\n      publicKey,\n      protocols,\n      observedAddr\n    } = message\n\n    if (publicKey == null) {\n      throw new InvalidMessageError('public key was missing from identify message')\n    }\n\n    const key = publicKeyFromProtobuf(publicKey)\n    const id = peerIdFromCID(key.toCID())\n\n    if (!connection.remotePeer.equals(id)) {\n      throw new InvalidMessageError('identified peer does not match the expected peer')\n    }\n\n    if (this.peerId.equals(id)) {\n      throw new InvalidMessageError('identified peer is our own peer id?')\n    }\n\n    // if the observed address is publicly routable, add it to the address\n    // manager for verification via AutoNAT\n    this.maybeAddObservedAddress(observedAddr)\n\n    this.log('identify completed for peer %p and protocols %o', id, protocols)\n\n    return consumeIdentifyMessage(this.peerStore, this.events, this.log, connection, message)\n  }\n\n  private maybeAddObservedAddress (observedAddr: Uint8Array | undefined): void {\n    const cleanObservedAddr = getCleanMultiaddr(observedAddr)\n\n    if (cleanObservedAddr == null) {\n      return\n    }\n\n    this.log.trace('our observed address was %a', cleanObservedAddr)\n\n    if (isPrivate(cleanObservedAddr)) {\n      this.log.trace('our observed address was private')\n      return\n    }\n\n    const tuples = cleanObservedAddr.stringTuples()\n\n    if (tuples[0][0] === CODEC_IP6 && !isGlobalUnicast(cleanObservedAddr)) {\n      this.log.trace('our observed address was IPv6 but not a global unicast address')\n      return\n    }\n\n    if (TCP.exactMatch(cleanObservedAddr)) {\n      // TODO: because socket dials can't use the same local port as the TCP\n      // listener, many unique observed addresses are reported so ignore all\n      // TCP addresses until https://github.com/libp2p/js-libp2p/issues/2620\n      // is resolved\n      return\n    }\n\n    this.log.trace('storing the observed address')\n    this.addressManager.addObservedAddr(cleanObservedAddr)\n  }\n\n  /**\n   * Sends the `Identify` response with the Signed Peer Record\n   * to the requesting peer over the given `connection`\n   */\n  async handleProtocol (data: IncomingStreamData): Promise<void> {\n    const { connection, stream } = data\n\n    const signal = AbortSignal.timeout(this.timeout)\n\n    setMaxListeners(Infinity, signal)\n\n    try {\n      const peerData = await this.peerStore.get(this.peerId)\n      const multiaddrs = this.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code))\n      let signedPeerRecord = peerData.peerRecordEnvelope\n\n      if (multiaddrs.length > 0 && signedPeerRecord == null) {\n        const peerRecord = new PeerRecord({\n          peerId: this.peerId,\n          multiaddrs\n        })\n\n        const envelope = await RecordEnvelope.seal(peerRecord, this.privateKey)\n        signedPeerRecord = envelope.marshal().subarray()\n      }\n\n      let observedAddr: Uint8Array | undefined = connection.remoteAddr.bytes\n\n      if (!IP_OR_DOMAIN.matches(connection.remoteAddr)) {\n        observedAddr = undefined\n      }\n\n      const pb = pbStream(stream).pb(IdentifyMessage)\n\n      await pb.write({\n        protocolVersion: this.host.protocolVersion,\n        agentVersion: this.host.agentVersion,\n        publicKey: publicKeyToProtobuf(this.privateKey.publicKey),\n        listenAddrs: multiaddrs.map(addr => addr.bytes),\n        signedPeerRecord,\n        observedAddr,\n        protocols: peerData.protocols\n      }, {\n        signal\n      })\n\n      await stream.close({\n        signal\n      })\n    } catch (err: any) {\n      this.log.error('could not respond to identify request', err)\n      stream.abort(err)\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Use the `identify` function to add support for the [Identify protocol](https://github.com/libp2p/specs/blob/master/identify/README.md) to libp2p.\n *\n * This protocol allows network peers to discover the multiaddrs the current node listens on, and the protocols it supports.\n *\n * A second function, `identifyPush` is also exported to add support for [identify/push](https://github.com/libp2p/specs/blob/master/identify/README.md#identifypush).\n *\n * This protocol will send updates to all connected peers when the multiaddrs or protocols of the current node change.\n *\n * > [!TIP]\n * > For maximum network compatibility you should configure both protocols\n *\n * @example Enabling identify\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { identify } from '@libp2p/identify'\n *\n * const node = await createLibp2p({\n *   // ...other options\n *   services: {\n *     identify: identify()\n *   }\n * })\n * ```\n *\n * @example Enabling identify push\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { identifyPush } from '@libp2p/identify'\n *\n * const node = await createLibp2p({\n *   // ...other options\n *   services: {\n *     identifyPush: identifyPush()\n *   }\n * })\n * ```\n */\n\nimport { IdentifyPush as IdentifyPushClass } from './identify-push.js'\nimport { Identify as IdentifyClass } from './identify.js'\nimport type { AbortOptions, IdentifyResult, Libp2pEvents, ComponentLogger, NodeInfo, TypedEventTarget, PeerId, PeerStore, Connection, PrivateKey } from '@libp2p/interface'\nimport type { AddressManager, ConnectionManager, Registrar } from '@libp2p/interface-internal'\n\nexport interface IdentifyInit {\n  /**\n   * The prefix to use for the protocol\n   *\n   * @default 'ipfs'\n   */\n  protocolPrefix?: string\n\n  /**\n   * What details we should send as part of an identify message\n   *\n   * @deprecated Use `nodeInfo.userAgent` in the main libp2p config instead\n   */\n  agentVersion?: string\n\n  /**\n   * How long we should wait for a remote peer to send their identify response\n   *\n   * @default 5000\n   */\n  timeout?: number\n\n  /**\n   * Identify responses larger than this in bytes will be rejected\n   *\n   * @default 8192\n   */\n  maxMessageSize?: number\n\n  /**\n   * The maximum number of inbound streams that may be open on a single\n   * connection for this protocol\n   *\n   * @default 1\n   */\n  maxInboundStreams?: number\n\n  /**\n   * The maximum number of outbound streams that may be open on a single\n   * connection for this protocol\n   *\n   * @default 1\n   */\n  maxOutboundStreams?: number\n\n  /**\n   * The maximum number of observed addresses to send in an Identify message\n   */\n  maxObservedAddresses?: number\n\n  /**\n   * Whether to run on connections with data or duration limits\n   *\n   * @default true\n   */\n  runOnLimitedConnection?: boolean\n\n  /**\n   * Whether to automatically run identify on newly opened connections\n   *\n   * @default true\n   */\n  runOnConnectionOpen?: boolean\n}\n\nexport interface IdentifyPushInit extends Omit<IdentifyInit, 'runOnConnectionOpen'> {\n  /**\n   * Whether to automatically dial identify-push on self updates\n   *\n   * @default true\n   */\n  runOnSelfUpdate?: boolean\n\n  /**\n   * Push to this many connections in parallel\n   *\n   * @default 32\n   */\n  concurrency?: number\n}\n\nexport interface IdentifyComponents {\n  peerId: PeerId\n  privateKey: PrivateKey\n  peerStore: PeerStore\n  registrar: Registrar\n  addressManager: AddressManager\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n  nodeInfo: NodeInfo\n}\n\nexport interface IdentifyPushComponents extends IdentifyComponents {\n  connectionManager: ConnectionManager\n}\n\nexport interface Identify {\n  /**\n   * due to the default limits on inbound/outbound streams for this protocol,\n   * invoking this method when runOnConnectionOpen is true can lead to unpredictable results\n   * as streams may be closed by the local or the remote node.\n   * Please use with caution. If you find yourself needing to call this method to discover other peers that support your protocol,\n   * you may be better off configuring a topology to be notified instead.\n   */\n  identify(connection: Connection, options?: AbortOptions): Promise<IdentifyResult>\n}\n\nexport interface IdentifyPush {\n  push(): Promise<void>\n}\n\nexport function identify (init: IdentifyInit = {}): (components: IdentifyComponents) => Identify {\n  return (components) => new IdentifyClass(components, init)\n}\n\nexport function identifyPush (init: IdentifyPushInit = {}): (components: IdentifyPushComponents) => IdentifyPush {\n  return (components) => new IdentifyPushClass(components, init)\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBM,IAAW;CAAjB,SAAiBA,WAAQ;AACvB,MAAI;AAES,EAAAA,UAAA,QAAQ,MAAsB;AACzC,QAAI,UAAU,MAAM;AAClB,eAAS,QAAkB,CAAC,KAAK,GAAG,OAAO,CAAA,MAAM;AAC/C,YAAI,KAAK,oBAAoB,OAAO;AAClC,YAAE,KAAI;QACR;AAEA,YAAK,IAAI,aAAa,QAAQ,IAAI,UAAU,aAAa,GAAI;AAC3D,YAAE,OAAO,EAAE;AACX,YAAE,MAAM,IAAI,SAAS;QACvB;AAEA,YAAK,IAAI,eAAe,QAAQ,IAAI,YAAY,aAAa,GAAI;AAC/D,YAAE,OAAO,EAAE;AACX,YAAE,MAAM,IAAI,WAAW;QACzB;AAEA,YAAK,IAAI,WAAW,QAAQ,IAAI,QAAQ,aAAa,GAAI;AACvD,YAAE,OAAO,EAAE;AACX,YAAE,MAAM,IAAI,OAAO;QACrB;AAEA,YAAK,IAAI,aAAa,QAAQ,IAAI,UAAU,aAAa,GAAI;AAC3D,YAAE,OAAO,EAAE;AACX,YAAE,MAAM,IAAI,SAAS;QACvB;AAEA,YAAI,KAAK,oBAAoB,OAAO;AAClC,YAAE,OAAM;QACV;MACF,GAAG,CAAC,QAAQ,QAAQ,OAAO,CAAA,MAAM;AAC/B,cAAM,MAAW;UACf,WAAW,MAAgB,CAAC;UAC5B,aAAa,MAAgB,CAAC;UAC9B,SAAS,MAAgB,CAAC;UAC1B,WAAW,MAAgB,CAAC;;AAG9B,cAAM,MAAM,UAAU,OAAO,OAAO,MAAM,OAAO,MAAM;AAEvD,eAAO,OAAO,MAAM,KAAK;AACvB,gBAAM,MAAM,OAAO,OAAM;AAEzB,kBAAQ,QAAQ,GAAG;YACjB,KAAK,GAAG;AACN,kBAAI,YAAY,OAAO,MAAK;AAC5B;YACF;YACA,KAAK,GAAG;AACN,kBAAI,cAAc,OAAO,MAAK;AAC9B;YACF;YACA,KAAK,GAAG;AACN,kBAAI,UAAU,OAAO,MAAK;AAC1B;YACF;YACA,KAAK,GAAG;AACN,kBAAI,YAAY,OAAO,MAAK;AAC5B;YACF;YACA,SAAS;AACP,qBAAO,SAAS,MAAM,CAAC;AACvB;YACF;UACF;QACF;AAEA,eAAO;MACT,CAAC;IACH;AAEA,WAAO;EACT;AAEa,EAAAA,UAAA,SAAS,CAAC,QAAsC;AAC3D,WAAO,cAAc,KAAKA,UAAS,MAAK,CAAE;EAC5C;AAEa,EAAAA,UAAA,SAAS,CAAC,KAAkC,SAA4C;AACnG,WAAO,cAAc,KAAKA,UAAS,MAAK,GAAI,IAAI;EAClD;AACF,GApFiB,aAAA,WAAQ,CAAA,EAAA;;;ACdnB,IAAO,wBAAP,cAAqC,MAAK;EAC9C,YAAaC,WAAU,qBAAmB;AACxC,UAAMA,QAAO;AACb,SAAK,OAAO;EACd;;;;ACSI,IAAO,kBAAP,MAAO,gBAAc;;;;;EAgEzB,YAAa,MAAwB;AAV9B;AACA;AACA;AACA;AACA;AAOL,UAAM,EAAE,WAAW,aAAa,SAAS,UAAS,IAAK;AAEvD,SAAK,YAAY;AACjB,SAAK,cAAc;AACnB,SAAK,UAAU;AACf,SAAK,YAAY;EACnB;;;;EAKA,UAAO;AACL,QAAI,KAAK,aAAa,MAAM;AAC1B,WAAK,YAAY,SAAS,OAAO;QAC/B,WAAW,oBAAoB,KAAK,SAAS;QAC7C,aAAa,KAAK;QAClB,SAAS,KAAK,QAAQ,SAAQ;QAC9B,WAAW,KAAK;OACjB;IACH;AAEA,WAAO,KAAK;EACd;;;;EAKA,OAAQ,OAAe;AACrB,WAAO,OAAiB,KAAK,QAAO,GAAI,MAAM,QAAO,CAAE;EACzD;;;;EAKA,MAAM,SAAU,QAAc;AAC5B,UAAM,WAAW,uBAAuB,QAAQ,KAAK,aAAa,KAAK,OAAO;AAE9E,WAAO,KAAK,UAAU,OAAO,SAAS,SAAQ,GAAI,KAAK,SAAS;EAClE;;;;;AAnGA,cAJW,iBAIJ,sBAAqB,OAAO,SAA8D;AAC/F,QAAM,eAAe,SAAS,OAAO,IAAI;AACzC,QAAM,YAAY,sBAAsB,aAAa,SAAS;AAE9D,SAAO,IAAI,gBAAe;IACxB;IACA,aAAa,aAAa;IAC1B,SAAS,aAAa;IACtB,WAAW,aAAa;GACzB;AACH;;;;;AAMA,cApBW,iBAoBJ,QAAO,OAAO,QAAgB,eAAmD;AACtF,MAAI,cAAc,MAAM;AACtB,UAAM,IAAI,MAAM,qBAAqB;EACvC;AAEA,QAAM,SAAS,OAAO;AACtB,QAAM,cAAc,OAAO;AAC3B,QAAM,UAAU,OAAO,QAAO;AAC9B,QAAM,WAAW,uBAAuB,QAAQ,aAAa,OAAO;AACpE,QAAM,YAAY,MAAM,WAAW,KAAK,SAAS,SAAQ,CAAE;AAE3D,SAAO,IAAI,gBAAe;IACxB,WAAW,WAAW;IACtB;IACA;IACA;GACD;AACH;;;;;AAMA,cA3CW,iBA2CJ,kBAAiB,OAAO,MAAmC,WAA2C;AAC3G,QAAM,WAAW,MAAM,gBAAe,mBAAmB,IAAI;AAC7D,QAAM,QAAQ,MAAM,SAAS,SAAS,MAAM;AAE5C,MAAI,CAAC,OAAO;AACV,UAAM,IAAI,sBAAsB,sDAAsD;EACxF;AAEA,SAAO;AACT;AApDI,IAAO,iBAAP;AA6GN,IAAM,yBAAyB,CAAC,QAAgB,aAAyB,YAAwD;AAS/H,QAAM,mBAAmB,WAAsB,MAAM;AACrD,QAAM,eAAsB,OAAO,iBAAiB,UAAU;AAC9D,QAAM,oBAA2B,OAAO,YAAY,MAAM;AAC1D,QAAM,gBAAuB,OAAO,QAAQ,MAAM;AAElD,SAAO,IAAI,eACT,cACA,kBACA,mBACA,aACA,eACA,OAAO;AAEX;;;AC5HM,SAAU,YAAa,GAAU,GAAQ;AAC7C,QAAM,OAAO,CAACC,IAAQC,OAAmBD,GAAE,SAAQ,EAAG,cAAcC,GAAE,SAAQ,CAAE;AAEhF,MAAI,EAAE,WAAW,EAAE,QAAQ;AACzB,WAAO;EACT;AAEA,IAAE,KAAK,IAAI;AAEX,SAAO,EAAE,KAAK,IAAI,EAAE,MAAM,CAAC,MAAM,UAAU,EAAE,KAAK,EAAE,OAAO,IAAI,CAAC;AAClE;;;AChCO,IAAM,8BAA8B;AAKpC,IAAM,oCAAoC,WAAW,KAAK,CAAC,GAAG,CAAC,CAAC;;;ACUjE,IAAW;CAAjB,SAAiBC,aAAU;AAKzB,MAAiB;AAAjB,GAAA,SAAiBC,cAAW;AAC1B,QAAIC;AAES,IAAAD,aAAA,QAAQ,MAAyB;AAC5C,UAAIC,WAAU,MAAM;AAClB,QAAAA,UAAS,QAAqB,CAAC,KAAK,GAAG,OAAO,CAAA,MAAM;AAClD,cAAI,KAAK,oBAAoB,OAAO;AAClC,cAAE,KAAI;UACR;AAEA,cAAK,IAAI,aAAa,QAAQ,IAAI,UAAU,aAAa,GAAI;AAC3D,cAAE,OAAO,EAAE;AACX,cAAE,MAAM,IAAI,SAAS;UACvB;AAEA,cAAI,KAAK,oBAAoB,OAAO;AAClC,cAAE,OAAM;UACV;QACF,GAAG,CAAC,QAAQ,QAAQ,OAAO,CAAA,MAAM;AAC/B,gBAAM,MAAW;YACf,WAAW,MAAgB,CAAC;;AAG9B,gBAAM,MAAM,UAAU,OAAO,OAAO,MAAM,OAAO,MAAM;AAEvD,iBAAO,OAAO,MAAM,KAAK;AACvB,kBAAM,MAAM,OAAO,OAAM;AAEzB,oBAAQ,QAAQ,GAAG;cACjB,KAAK,GAAG;AACN,oBAAI,YAAY,OAAO,MAAK;AAC5B;cACF;cACA,SAAS;AACP,uBAAO,SAAS,MAAM,CAAC;AACvB;cACF;YACF;UACF;AAEA,iBAAO;QACT,CAAC;MACH;AAEA,aAAOA;IACT;AAEa,IAAAD,aAAA,SAAS,CAAC,QAAyC;AAC9D,aAAO,cAAc,KAAKA,aAAY,MAAK,CAAE;IAC/C;AAEa,IAAAA,aAAA,SAAS,CAAC,KAAkC,SAAkD;AACzG,aAAO,cAAc,KAAKA,aAAY,MAAK,GAAI,IAAI;IACrD;EACF,GAtDiB,cAAAD,YAAA,gBAAAA,YAAA,cAAW,CAAA,EAAA;AAwD5B,MAAI;AAES,EAAAA,YAAA,QAAQ,MAAwB;AAC3C,QAAI,UAAU,MAAM;AAClB,eAAS,QAAoB,CAAC,KAAK,GAAG,OAAO,CAAA,MAAM;AACjD,YAAI,KAAK,oBAAoB,OAAO;AAClC,YAAE,KAAI;QACR;AAEA,YAAK,IAAI,UAAU,QAAQ,IAAI,OAAO,aAAa,GAAI;AACrD,YAAE,OAAO,EAAE;AACX,YAAE,MAAM,IAAI,MAAM;QACpB;AAEA,YAAK,IAAI,OAAO,QAAQ,IAAI,QAAQ,IAAK;AACvC,YAAE,OAAO,EAAE;AACX,YAAE,OAAO,IAAI,GAAG;QAClB;AAEA,YAAI,IAAI,aAAa,MAAM;AACzB,qBAAW,SAAS,IAAI,WAAW;AACjC,cAAE,OAAO,EAAE;AACX,YAAAA,YAAW,YAAY,MAAK,EAAG,OAAO,OAAO,CAAC;UAChD;QACF;AAEA,YAAI,KAAK,oBAAoB,OAAO;AAClC,YAAE,OAAM;QACV;MACF,GAAG,CAAC,QAAQ,QAAQ,OAAO,CAAA,MAAM;AA1GvC,YAAAG,KAAAC;AA2GQ,cAAM,MAAW;UACf,QAAQ,MAAgB,CAAC;UACzB,KAAK;UACL,WAAW,CAAA;;AAGb,cAAM,MAAM,UAAU,OAAO,OAAO,MAAM,OAAO,MAAM;AAEvD,eAAO,OAAO,MAAM,KAAK;AACvB,gBAAM,MAAM,OAAO,OAAM;AAEzB,kBAAQ,QAAQ,GAAG;YACjB,KAAK,GAAG;AACN,kBAAI,SAAS,OAAO,MAAK;AACzB;YACF;YACA,KAAK,GAAG;AACN,kBAAI,MAAM,OAAO,OAAM;AACvB;YACF;YACA,KAAK,GAAG;AACN,oBAAID,MAAA,KAAK,WAAL,gBAAAA,IAAa,cAAa,QAAQ,IAAI,UAAU,WAAW,KAAK,OAAO,WAAW;AACpF,sBAAM,IAAI,eAAe,4DAA4D;cACvF;AAEA,kBAAI,UAAU,KAAKH,YAAW,YAAY,MAAK,EAAG,OAAO,QAAQ,OAAO,OAAM,GAAI;gBAChF,SAAQI,MAAA,KAAK,WAAL,gBAAAA,IAAa;eACtB,CAAC;AACF;YACF;YACA,SAAS;AACP,qBAAO,SAAS,MAAM,CAAC;AACvB;YACF;UACF;QACF;AAEA,eAAO;MACT,CAAC;IACH;AAEA,WAAO;EACT;AAEa,EAAAJ,YAAA,SAAS,CAAC,QAAwC;AAC7D,WAAO,cAAc,KAAKA,YAAW,MAAK,CAAE;EAC9C;AAEa,EAAAA,YAAA,SAAS,CAAC,KAAkC,SAAgD;AACvG,WAAO,cAAc,KAAKA,YAAW,MAAK,GAAI,IAAI;EACpD;AACF,GA9IiB,eAAA,aAAU,CAAA,EAAA;;;ACerB,IAAO,cAAP,MAAO,YAAU;EAuBrB,YAAa,MAAoB;AAP1B;AACA;AACA;AACA,kCAAS,YAAW;AACpB,iCAAQ,YAAW;AAClB;AAGN,UAAM,EAAE,QAAQ,YAAY,UAAS,IAAK;AAE1C,SAAK,SAAS;AACd,SAAK,aAAa,cAAc,CAAA;AAChC,SAAK,YAAY,aAAa,OAAO,KAAK,IAAG,CAAE;EACjD;;;;EAKA,UAAO;AACL,QAAI,KAAK,aAAa,MAAM;AAC1B,WAAK,YAAY,WAAS,OAAO;QAC/B,QAAQ,KAAK,OAAO,YAAW,EAAG;QAClC,KAAK,OAAO,KAAK,SAAS;QAC1B,WAAW,KAAK,WAAW,IAAI,CAAC,OAAO;UACrC,WAAW,EAAE;UACb;OACH;IACH;AAEA,WAAO,KAAK;EACd;;;;EAKA,OAAQ,OAAc;AACpB,QAAI,EAAE,iBAAiB,cAAa;AAClC,aAAO;IACT;AAGA,QAAI,CAAC,KAAK,OAAO,OAAO,MAAM,MAAM,GAAG;AACrC,aAAO;IACT;AAGA,QAAI,KAAK,cAAc,MAAM,WAAW;AACtC,aAAO;IACT;AAGA,QAAI,CAAC,YAAY,KAAK,YAAY,MAAM,UAAU,GAAG;AACnD,aAAO;IACT;AAEA,WAAO;EACT;;;;;AApEA,cAJW,aAIJ,sBAAqB,CAAC,QAAgD;AAC3E,QAAM,aAAa,WAAS,OAAO,GAAG;AACtC,QAAM,SAAS,oBAA2B,OAAO,WAAW,MAAM,CAAC;AACnE,QAAM,cAAc,WAAW,aAAa,CAAA,GAAI,IAAI,CAAC,MAAM,UAAU,EAAE,SAAS,CAAC;AACjF,QAAM,YAAY,WAAW;AAE7B,SAAO,IAAI,YAAW,EAAE,QAAQ,YAAY,UAAS,CAAE;AACzD;AAEA,cAbW,aAaJ,UAAS;AAChB,cAdW,aAcJ,SAAQ;AAdX,IAAOK,cAAP;;;AC3BC,IAAM,4BAA4B;AAClC,IAAM,oCAAoC;AAC1C,IAAM,yCAAyC;AAC/C,IAAM,uCAAuC;AAC7C,IAAM,4CAA4C;AAGlD,IAAM,4BAA4B,OAAO;AAGzC,IAAM,uBAAuB;;;ACK9B,IAAW;CAAjB,SAAiBC,WAAQ;AACvB,MAAI;AAES,EAAAA,UAAA,QAAQ,MAAsB;AACzC,QAAI,UAAU,MAAM;AAClB,eAAS,QAAkB,CAAC,KAAK,GAAG,OAAO,CAAA,MAAM;AAC/C,YAAI,KAAK,oBAAoB,OAAO;AAClC,YAAE,KAAI;QACR;AAEA,YAAI,IAAI,mBAAmB,MAAM;AAC/B,YAAE,OAAO,EAAE;AACX,YAAE,OAAO,IAAI,eAAe;QAC9B;AAEA,YAAI,IAAI,gBAAgB,MAAM;AAC5B,YAAE,OAAO,EAAE;AACX,YAAE,OAAO,IAAI,YAAY;QAC3B;AAEA,YAAI,IAAI,aAAa,MAAM;AACzB,YAAE,OAAO,EAAE;AACX,YAAE,MAAM,IAAI,SAAS;QACvB;AAEA,YAAI,IAAI,eAAe,MAAM;AAC3B,qBAAW,SAAS,IAAI,aAAa;AACnC,cAAE,OAAO,EAAE;AACX,cAAE,MAAM,KAAK;UACf;QACF;AAEA,YAAI,IAAI,gBAAgB,MAAM;AAC5B,YAAE,OAAO,EAAE;AACX,YAAE,MAAM,IAAI,YAAY;QAC1B;AAEA,YAAI,IAAI,aAAa,MAAM;AACzB,qBAAW,SAAS,IAAI,WAAW;AACjC,cAAE,OAAO,EAAE;AACX,cAAE,OAAO,KAAK;UAChB;QACF;AAEA,YAAI,IAAI,oBAAoB,MAAM;AAChC,YAAE,OAAO,EAAE;AACX,YAAE,MAAM,IAAI,gBAAgB;QAC9B;AAEA,YAAI,KAAK,oBAAoB,OAAO;AAClC,YAAE,OAAM;QACV;MACF,GAAG,CAAC,QAAQ,QAAQ,OAAO,CAAA,MAAM;AAvEvC,YAAAC,KAAAC;AAwEQ,cAAM,MAAW;UACf,aAAa,CAAA;UACb,WAAW,CAAA;;AAGb,cAAM,MAAM,UAAU,OAAO,OAAO,MAAM,OAAO,MAAM;AAEvD,eAAO,OAAO,MAAM,KAAK;AACvB,gBAAM,MAAM,OAAO,OAAM;AAEzB,kBAAQ,QAAQ,GAAG;YACjB,KAAK,GAAG;AACN,kBAAI,kBAAkB,OAAO,OAAM;AACnC;YACF;YACA,KAAK,GAAG;AACN,kBAAI,eAAe,OAAO,OAAM;AAChC;YACF;YACA,KAAK,GAAG;AACN,kBAAI,YAAY,OAAO,MAAK;AAC5B;YACF;YACA,KAAK,GAAG;AACN,oBAAID,MAAA,KAAK,WAAL,gBAAAA,IAAa,gBAAe,QAAQ,IAAI,YAAY,WAAW,KAAK,OAAO,aAAa;AAC1F,sBAAM,IAAI,eAAe,8DAA8D;cACzF;AAEA,kBAAI,YAAY,KAAK,OAAO,MAAK,CAAE;AACnC;YACF;YACA,KAAK,GAAG;AACN,kBAAI,eAAe,OAAO,MAAK;AAC/B;YACF;YACA,KAAK,GAAG;AACN,oBAAIC,MAAA,KAAK,WAAL,gBAAAA,IAAa,cAAa,QAAQ,IAAI,UAAU,WAAW,KAAK,OAAO,WAAW;AACpF,sBAAM,IAAI,eAAe,4DAA4D;cACvF;AAEA,kBAAI,UAAU,KAAK,OAAO,OAAM,CAAE;AAClC;YACF;YACA,KAAK,GAAG;AACN,kBAAI,mBAAmB,OAAO,MAAK;AACnC;YACF;YACA,SAAS;AACP,qBAAO,SAAS,MAAM,CAAC;AACvB;YACF;UACF;QACF;AAEA,eAAO;MACT,CAAC;IACH;AAEA,WAAO;EACT;AAEa,EAAAF,UAAA,SAAS,CAAC,QAAsC;AAC3D,WAAO,cAAc,KAAKA,UAAS,MAAK,CAAE;EAC5C;AAEa,EAAAA,UAAA,SAAS,CAAC,KAAkC,SAA4C;AACnG,WAAO,cAAc,KAAKA,UAAS,MAAK,GAAI,IAAI;EAClD;AACF,GAzHiB,aAAA,WAAQ,CAAA,EAAA;;;ACPlB,IAAM,gBAAgB;EAC3B,gBAAgB;EAChB,SAAS;EACT,mBAAmB;EACnB,oBAAoB;EACpB,sBAAsB;EACtB,gBAAgB;EAChB,qBAAqB;EACrB,iBAAiB;EACjB,wBAAwB;EACxB,aAAa;;AAMT,SAAU,kBAAmB,MAA4C;AAC7E,MAAI,QAAQ,QAAQ,KAAK,SAAS,GAAG;AACnC,QAAI;AACF,aAAO,UAAU,IAAI;IACvB,QAAQ;IAER;EACF;AACF;AAEM,SAAU,gBAAiB,UAAoB,cAAqB;AACxE,MAAI,gBAAgB,MAAM;AACxB,WAAO;EACT;AAEA,SAAO,SAAS;AAClB;AAEA,eAAsB,uBAAwB,WAAsB,QAAwC,KAAa,YAAwBG,UAAwB;AACvK,MAAI,6BAA6B,WAAW,UAAU;AAEtD,MAAIA,YAAW,MAAM;AACnB,UAAM,IAAI,oBAAoB,+BAA+B;EAC/D;AAEA,QAAM,OAAiB,CAAA;AAEvB,MAAIA,SAAQ,YAAY,SAAS,GAAG;AAClC,SAAK,YAAYA,SAAQ,YAAY,IAAI,UAAQ;MAC/C,aAAa;MACb,WAAW,UAAU,GAAG;MACxB;EACJ;AAEA,MAAIA,SAAQ,UAAU,SAAS,GAAG;AAChC,SAAK,YAAYA,SAAQ;EAC3B;AAEA,MAAIA,SAAQ,aAAa,MAAM;AAC7B,UAAM,YAAY,sBAAsBA,SAAQ,SAAS;AACzD,UAAM,SAAS,oBAAoB,SAAS;AAE5C,QAAI,CAAC,OAAO,OAAO,WAAW,UAAU,GAAG;AACzC,YAAM,IAAI,oBAAoB,wCAAwC;IACxE;AAEA,SAAK,YAAY;EACnB;AAEA,MAAI;AAGJ,MAAIA,SAAQ,oBAAoB,MAAM;AACpC,QAAI,MAAM,qCAAqC,WAAW,UAAU;AAEpE,QAAI,qBAAqBA,SAAQ;AACjC,UAAM,WAAW,MAAM,eAAe,eAAe,oBAAoBC,YAAW,MAAM;AAC1F,QAAI,aAAaA,YAAW,mBAAmB,SAAS,OAAO;AAC/D,UAAM,eAAe,cAAc,SAAS,UAAU,MAAK,CAAE;AAG7D,QAAI,CAAC,WAAW,OAAO,OAAO,YAAY,GAAG;AAC3C,YAAM,IAAI,oBAAoB,qDAAqD;IACrF;AAGA,QAAI,CAAC,WAAW,WAAW,OAAO,WAAW,MAAM,GAAG;AACpD,YAAM,IAAI,oBAAoB,0CAA0C;IAC1E;AAEA,QAAI;AAEJ,QAAI;AACF,qBAAe,MAAM,UAAU,IAAI,WAAW,MAAM;IACtD,SAAS,KAAU;AACjB,UAAI,IAAI,SAAS,iBAAiB;AAChC,cAAM;MACR;IACF;AAEA,QAAI,gBAAgB,MAAM;AAExB,WAAK,WAAW,aAAa;AAG7B,UAAI,aAAa,sBAAsB,MAAM;AAC3C,cAAM,iBAAiB,MAAM,eAAe,mBAAmB,aAAa,kBAAkB;AAC9F,cAAM,eAAeA,YAAW,mBAAmB,eAAe,OAAO;AAGzE,YAAI,aAAa,aAAa,WAAW,WAAW;AAClD,cAAI,4FAA4F,aAAa,WAAW,WAAW,SAAS;AAC5I,uBAAa;AACb,+BAAqB,aAAa;QACpC;MACF;IACF;AAGA,SAAK,qBAAqB;AAG1B,SAAK,YAAY,WAAW,WAAW,IAAI,CAAAC,gBAAc;MACvD,aAAa;MACb,WAAAA;MACA;AAEF,aAAS;MACP,KAAK,WAAW;MAChB,WAAW,WAAW;;EAE1B,OAAO;AACL,QAAI,wCAAwC,WAAW,UAAU;EACnE;AAEA,MAAI,MAAM,oBAAoB,WAAW,YAAY,IAAI;AACzD,QAAM,UAAU,MAAM,WAAW,YAAY,IAAI;AAEjD,MAAIF,SAAQ,gBAAgB,QAAQA,SAAQ,mBAAmB,MAAM;AACnE,UAAM,WAAuC,CAAA;AAE7C,QAAIA,SAAQ,gBAAgB,MAAM;AAChC,eAAS,eAAe,WAAqBA,SAAQ,YAAY;IACnE;AAEA,QAAIA,SAAQ,mBAAmB,MAAM;AACnC,eAAS,kBAAkB,WAAqBA,SAAQ,eAAe;IACzE;AAEA,QAAI,MAAM,uBAAuB,WAAW,YAAY,QAAQ;AAChE,UAAM,UAAU,MAAM,WAAW,YAAY;MAC3C;KACD;EACH;AAEA,QAAM,SAAyB;IAC7B,QAAQ,WAAW;IACnB,iBAAiBA,SAAQ;IACzB,cAAcA,SAAQ;IACtB,WAAWA,SAAQ;IACnB,aAAaA,SAAQ,YAAY,IAAI,SAAO,UAAU,GAAG,CAAC;IAC1D,cAAcA,SAAQ,gBAAgB,OAAO,SAAY,UAAUA,SAAQ,YAAY;IACvF,WAAWA,SAAQ;IACnB,kBAAkB;IAClB;;AAGF,SAAO,kBAAkB,iBAAiB,EAAE,QAAQ,OAAM,CAAE;AAE5D,SAAO;AACT;AAOM,IAAgB,mBAAhB,MAAgC;EAsBpC,YAAa,YAAgC,MAA0B;AArBvD;AAKN;AACA;AACS;AACA;AACA;AACA;AACA;AACA;AACF;AACA;AACE;AACA;AACA;AACA;AACA;AAGjB,SAAK,WAAW,KAAK;AACrB,SAAK,UAAU;AACf,SAAK,SAAS,WAAW;AACzB,SAAK,aAAa,WAAW;AAC7B,SAAK,YAAY,WAAW;AAC5B,SAAK,YAAY,WAAW;AAC5B,SAAK,iBAAiB,WAAW;AACjC,SAAK,SAAS,WAAW;AACzB,SAAK,MAAM,KAAK;AAEhB,SAAK,UAAU,KAAK,WAAW,cAAc;AAC7C,SAAK,oBAAoB,KAAK,qBAAqB,cAAc;AACjE,SAAK,qBAAqB,KAAK,sBAAsB,cAAc;AACnE,SAAK,iBAAiB,KAAK,kBAAkB,cAAc;AAC3D,SAAK,uBAAuB,KAAK,wBAAwB,cAAc;AACvE,SAAK,yBAAyB,KAAK,0BAA0B,cAAc;AAG3E,SAAK,OAAO;MACV,iBAAiB,GAAG,KAAK,kBAAkB,cAAc,cAAc,IAAI,yBAAyB;MACpG,cAAc,gBAAgB,WAAW,UAAU,KAAK,YAAY;;EAExE;EAEA,YAAS;AACP,WAAO,KAAK;EACd;EAEA,MAAM,QAAK;AACT,QAAI,KAAK,SAAS;AAChB;IACF;AAEA,UAAM,KAAK,UAAU,MAAM,KAAK,QAAQ;MACtC,UAAU;QACR,cAAc,WAAqB,KAAK,KAAK,YAAY;QACzD,iBAAiB,WAAqB,KAAK,KAAK,eAAe;;KAElE;AAED,UAAM,KAAK,UAAU,OAAO,KAAK,UAAU,CAAC,SAAQ;AAClD,WAAK,KAAK,eAAe,IAAI,EAAE,MAAM,SAAM;AACzC,aAAK,IAAI,MAAM,GAAG;MACpB,CAAC;IACH,GAAG;MACD,mBAAmB,KAAK;MACxB,oBAAoB,KAAK;MACzB,wBAAwB,KAAK;KAC9B;AAED,SAAK,UAAU;EACjB;EAEA,MAAM,OAAI;AACR,UAAM,KAAK,UAAU,SAAS,KAAK,QAAQ;AAE3C,SAAK,UAAU;EACjB;;;;ACzQF;AAoBM,IAAO,eAAP,eAA4B,uBAsB/B,0BAtB+B,IAAgB;EAIhD,YAAa,YAAoC,OAAyB,CAAA,GAAE;AAC1E,UAAM,YAAY;MAChB,GAAG;MACH,UAAU,IAAI,KAAK,kBAAkB,cAAc,cAAc,IAAI,sCAAsC,IAAI,yCAAyC;MACxJ,KAAK,WAAW,OAAO,aAAa,sBAAsB;KAC3D;AARc;AACA;AAoBjB,wBAAC,IAAiC;MAChC;;AAZA,SAAK,oBAAoB,WAAW;AACpC,SAAK,cAAc,KAAK,eAAe,cAAc;AAErD,QAAK,KAAK,mBAAmB,cAAc,iBAAkB;AAE3D,iBAAW,OAAO,iBAAiB,oBAAoB,CAAC,QAAO;AAC7D,aAAK,KAAK,KAAI,EAAG,MAAM,SAAM;AAAG,eAAK,IAAI,MAAM,GAAG;QAAE,CAAC;MACvD,CAAC;IACH;EACF;;;;EASA,MAAM,OAAI;AAER,QAAI,CAAC,KAAK,UAAS,GAAI;AACrB;IACF;AAEA,UAAM,kBAAkB,KAAK,eAAe,aAAY,EAAG,IAAI,QAAM,GAAG,gBAAgB,YAAU,KAAK,EAAE,IAAI,CAAC;AAC9G,UAAM,aAAa,IAAIG,YAAW;MAChC,QAAQ,KAAK;MACb,YAAY;KACb;AACD,UAAM,mBAAmB,MAAM,eAAe,KAAK,YAAY,KAAK,UAAU;AAC9E,UAAM,qBAAqB,KAAK,UAAU,aAAY;AACtD,UAAM,OAAO,MAAM,KAAK,UAAU,IAAI,KAAK,MAAM;AACjD,UAAM,eAAe,SAAmB,KAAK,SAAS,IAAI,cAAc,KAAK,WAAqB,KAAK,KAAK,YAAY,CAAC;AACzH,UAAM,kBAAkB,SAAmB,KAAK,SAAS,IAAI,iBAAiB,KAAK,WAAqB,KAAK,KAAK,eAAe,CAAC;AAClI,UAAM,OAAO;AAEb,oBAAiB,oBAAiB;AAChC,iBAAW,cAAc,KAAK,kBAAkB,eAAc,GAAI;AAChE,cAAMC,QAAO,MAAM,KAAK,UAAU,IAAI,WAAW,UAAU;AAE3D,YAAI,CAACA,MAAK,UAAU,SAAS,KAAK,QAAQ,GAAG;AAC3C;QACF;AAEA,cAAM,YAAW;AACf,cAAI;AACJ,gBAAM,SAAS,YAAY,QAAQ,KAAK,OAAO;AAE/C,0BAAgB,UAAU,MAAM;AAEhC,cAAI;AACF,qBAAS,MAAM,WAAW,UAAU,KAAK,UAAU;cACjD;cACA,wBAAwB,KAAK;aAC9B;AAED,kBAAM,KAAK,SAAS,QAAQ;cAC1B,eAAe,KAAK;aACrB,EAAE,GAAG,QAAe;AAErB,kBAAM,GAAG,MAAM;cACb,aAAa,gBAAgB,IAAI,QAAM,GAAG,KAAK;cAC/C,kBAAkB,iBAAiB,QAAO;cAC1C,WAAW;cACX;cACA;eACC;cACD;aACD;AAED,kBAAM,OAAO,MAAM;cACjB;aACD;UACH,SAAS,KAAU;AAEjB,iBAAK,IAAI,MAAM,0CAA0C,GAAG;AAC5D,6CAAQ,MAAM;UAChB;QACF;MACF;IACF;AAEA,UAAM,YAAM,SAAS,kBAAiB,GAAI;MACxC,aAAa,KAAK;KACnB,CAAC;EACJ;;;;EAKA,MAAM,eAAgB,MAAwB;AAC5C,UAAM,EAAE,YAAY,OAAM,IAAK;AAE/B,QAAI;AACF,UAAI,KAAK,OAAO,OAAO,WAAW,UAAU,GAAG;AAC7C,cAAM,IAAI,MAAM,+BAA+B;MACjD;AAEA,YAAM,UAAU;QACd,QAAQ,YAAY,QAAQ,KAAK,OAAO;;AAG1C,YAAM,KAAK,SAAS,QAAQ;QAC1B,eAAe,KAAK;OACrB,EAAE,GAAG,QAAe;AAErB,YAAMC,WAAU,MAAM,GAAG,KAAK,OAAO;AACrC,YAAM,OAAO,MAAM,OAAO;AAE1B,YAAM,uBAAuB,KAAK,WAAW,KAAK,QAAQ,KAAK,KAAK,YAAYA,QAAO;IACzF,SAAS,KAAU;AACjB,WAAK,IAAI,MAAM,4BAA4B,GAAG;AAC9C,aAAO,MAAM,GAAG;AAChB;IACF;AAEA,SAAK,IAAI,MAAM,wBAAwB,WAAW,UAAU;EAC9D;;;;ACjJF,IAAM,YAAY;AAKZ,SAAU,gBAAiB,IAAa;AAC5C,MAAI;AACF,UAAM,CAAC,CAAC,OAAO,KAAK,CAAC,IAAI,GAAG,aAAY;AAExC,QAAI,SAAS,MAAM;AACjB,aAAO;IACT;AAEA,QAAI,UAAU,WAAW;AACvB,aAAO,aAAa,YAAY,KAAK;IACvC;EACF,QAAQ;EAER;AAEA,SAAO;AACT;;;ACvBA,IAAAC,kBAAwB;AAExB,IAAM,oBAAoB;EACxB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;AAGF,IAAM,iBAAiB,kBAAkB,IAAI,aAAW,IAAI,wBAAQ,OAAO,CAAC;AAE5E,SAAS,UAAW,QAAc;AAChC,aAAW,KAAK,gBAAgB;AAC9B,QAAI,EAAE,SAAS,MAAM;AAAG,aAAO;EACjC;AAEA,SAAO;AACT;AAEA,SAAS,iBAAkB,QAAc;AACvC,SAAO,iDAAiD,KAAK,MAAM;AACrE;AAKA,SAAS,oBAAqB,QAAc;AAC1C,QAAM,QAAQ,OAAO,MAAM,GAAG;AAE9B,MAAI,MAAM,SAAS,GAAG;AACpB,WAAO;EACT;AAEA,QAAM,UAAU,MAAM,MAAM,SAAS,CAAC,EAAE,SAAS,GAAG,GAAG;AACvD,QAAM,UAAU,MAAM,MAAM,SAAS,CAAC,EAAE,SAAS,GAAG,GAAG;AAEvD,QAAM,MAAM,GAAG,SAAS,QAAQ,UAAU,GAAG,CAAC,GAAG,EAAE,CAAC,IAAI,SAAS,QAAQ,UAAU,CAAC,GAAG,EAAE,CAAC,IAAI,SAAS,QAAQ,UAAU,GAAG,CAAC,GAAG,EAAE,CAAC,IAAI,SAAS,QAAQ,UAAU,CAAC,GAAG,EAAE,CAAC;AAEzK,SAAO,UAAU,GAAG;AACtB;AAKA,SAAS,mBAAoB,QAAc;AACzC,SAAO,kEAAkE,KAAK,MAAM;AACtF;AAEA,SAAS,sBAAuB,QAAc;AAC5C,QAAM,QAAQ,OAAO,MAAM,GAAG;AAC9B,QAAM,MAAM,MAAM,MAAM,SAAS,CAAC;AAElC,SAAO,UAAU,GAAG;AACtB;AAEA,SAAS,UAAW,QAAc;AAChC,SAAO,OAAO,KAAK,MAAM,KACvB,QAAQ,KAAK,MAAM,KACnB,oEAAoE,KAAK,MAAM,KAC/E,wFAAwF,KAAK,MAAM,KACnG,iIAAiI,KAAK,MAAM,KAC5I,6IAA6I,KAAK,MAAM,KACxJ,oIAAoI,KAAK,MAAM,KAC/I,oJAAoJ,KAAK,MAAM,KAC/J,8BAA8B,KAAK,MAAM,KACzC,8BAA8B,KAAK,MAAM,KACzC,0BAA0B,KAAK,MAAM;AACzC;AAEM,SAAU,YAAa,IAAU;AACrC,MAAI,OAAO,EAAE;AAAG,WAAO,UAAU,EAAE;WAC1B,iBAAiB,EAAE;AAAG,WAAO,oBAAoB,EAAE;WACnD,mBAAmB,EAAE;AAAG,WAAO,sBAAsB,EAAE;WACvD,OAAO,EAAE;AAAG,WAAO,UAAU,EAAE;;AACnC,WAAO;AACd;;;AC9FA,IAAM,YAAY;AAClB,IAAMC,aAAY;AAKZ,SAAU,UAAW,IAAa;AACtC,MAAI;AACF,UAAM,CAAC,CAAC,KAAK,CAAC,IAAI,GAAG,aAAY;AAEjC,WAAO,UAAU,aAAa,UAAUA;EAC1C,QAAQ;EAER;AAEA,SAAO;AACT;;;ACXM,SAAU,UAAW,IAAa;AACtC,MAAI;AACF,QAAI,CAAC,UAAU,EAAE,GAAG;AAElB,aAAO;IACT;AAEA,UAAM,CAAC,CAAC,EAAE,KAAK,CAAC,IAAI,GAAG,aAAY;AAEnC,QAAI,SAAS,MAAM;AACjB,aAAO;IACT;AAEA,WAAO,YAAY,KAAK,KAAK;EAC/B,QAAQ;EAER;AAEA,SAAO;AACT;;;ACNA,IAAMC,aAAY;AApBlB,IAAAC,KAAAC;AAsBM,IAAOC,YAAP,eAAwBD,MAAA,kBAyB3BD,MAAA,qBAzB2BC,KAAgB;EAC5C,YAAa,YAAgC,OAAqB,CAAA,GAAE;AAClE,UAAM,YAAY;MAChB,GAAG;MACH,UAAU,IAAI,KAAK,kBAAkB,cAAc,cAAc,IAAI,iCAAiC,IAAI,oCAAoC;MAC9I,KAAK,WAAW,OAAO,aAAa,iBAAiB;KACtD;AAmBH,wBAACD,KAAiC;MAChC;;AAlBA,QAAI,KAAK,uBAAuB,cAAc,qBAAqB;AAEjE,iBAAW,OAAO,iBAAiB,mBAAmB,CAAC,QAAO;AAC5D,cAAM,aAAa,IAAI;AACvB,aAAK,SAAS,UAAU,EACrB,MAAM,SAAM;AACX,cAAI,IAAI,SAAS,yBAAyB,MAAM;AAE9C;UACF;AAEA,eAAK,IAAI,MAAM,oDAAoD,GAAG;QACxE,CAAC;MACL,CAAC;IACH;EACF;EAMA,MAAM,UAAW,YAAwB,UAAwB,CAAA,GAAE;AACjE,QAAI;AAEJ,QAAI,QAAQ,UAAU,MAAM;AAC1B,YAAM,SAAS,YAAY,QAAQ,KAAK,OAAO;AAC/C,sBAAgB,UAAU,MAAM;AAEhC,gBAAU;QACR,GAAG;QACH;;IAEJ;AAEA,QAAI;AACF,eAAS,MAAM,WAAW,UAAU,KAAK,UAAU;QACjD,GAAG;QACH,wBAAwB,KAAK;OAC9B;AAED,YAAM,KAAK,SAAS,QAAQ;QAC1B,eAAe,KAAK;OACrB,EAAE,GAAG,QAAe;AAErB,YAAMG,WAAU,MAAM,GAAG,KAAK,OAAO;AAErC,YAAM,OAAO,MAAM,OAAO;AAE1B,aAAOA;IACT,SAAS,KAAU;AACjB,uCAAQ,MAAM;AACd,YAAM;IACR;EACF;EAEA,MAAM,SAAU,YAAwB,UAAwB,CAAA,GAAE;AAChE,UAAMA,WAAU,MAAM,KAAK,UAAU,YAAY,OAAO;AACxD,UAAM,EACJ,WACA,WACA,aAAY,IACVA;AAEJ,QAAI,aAAa,MAAM;AACrB,YAAM,IAAI,oBAAoB,8CAA8C;IAC9E;AAEA,UAAM,MAAM,sBAAsB,SAAS;AAC3C,UAAM,KAAK,cAAc,IAAI,MAAK,CAAE;AAEpC,QAAI,CAAC,WAAW,WAAW,OAAO,EAAE,GAAG;AACrC,YAAM,IAAI,oBAAoB,kDAAkD;IAClF;AAEA,QAAI,KAAK,OAAO,OAAO,EAAE,GAAG;AAC1B,YAAM,IAAI,oBAAoB,qCAAqC;IACrE;AAIA,SAAK,wBAAwB,YAAY;AAEzC,SAAK,IAAI,mDAAmD,IAAI,SAAS;AAEzE,WAAO,uBAAuB,KAAK,WAAW,KAAK,QAAQ,KAAK,KAAK,YAAYA,QAAO;EAC1F;EAEQ,wBAAyB,cAAoC;AACnE,UAAM,oBAAoB,kBAAkB,YAAY;AAExD,QAAI,qBAAqB,MAAM;AAC7B;IACF;AAEA,SAAK,IAAI,MAAM,+BAA+B,iBAAiB;AAE/D,QAAI,UAAU,iBAAiB,GAAG;AAChC,WAAK,IAAI,MAAM,kCAAkC;AACjD;IACF;AAEA,UAAM,SAAS,kBAAkB,aAAY;AAE7C,QAAI,OAAO,CAAC,EAAE,CAAC,MAAMJ,cAAa,CAAC,gBAAgB,iBAAiB,GAAG;AACrE,WAAK,IAAI,MAAM,gEAAgE;AAC/E;IACF;AAEA,QAAI,IAAI,WAAW,iBAAiB,GAAG;AAKrC;IACF;AAEA,SAAK,IAAI,MAAM,8BAA8B;AAC7C,SAAK,eAAe,gBAAgB,iBAAiB;EACvD;;;;;EAMA,MAAM,eAAgB,MAAwB;AAC5C,UAAM,EAAE,YAAY,OAAM,IAAK;AAE/B,UAAM,SAAS,YAAY,QAAQ,KAAK,OAAO;AAE/C,oBAAgB,UAAU,MAAM;AAEhC,QAAI;AACF,YAAM,WAAW,MAAM,KAAK,UAAU,IAAI,KAAK,MAAM;AACrD,YAAM,aAAa,KAAK,eAAe,aAAY,EAAG,IAAI,QAAM,GAAG,gBAAgB,YAAU,KAAK,EAAE,IAAI,CAAC;AACzG,UAAI,mBAAmB,SAAS;AAEhC,UAAI,WAAW,SAAS,KAAK,oBAAoB,MAAM;AACrD,cAAM,aAAa,IAAIK,YAAW;UAChC,QAAQ,KAAK;UACb;SACD;AAED,cAAM,WAAW,MAAM,eAAe,KAAK,YAAY,KAAK,UAAU;AACtE,2BAAmB,SAAS,QAAO,EAAG,SAAQ;MAChD;AAEA,UAAI,eAAuC,WAAW,WAAW;AAEjE,UAAI,CAAC,aAAa,QAAQ,WAAW,UAAU,GAAG;AAChD,uBAAe;MACjB;AAEA,YAAM,KAAK,SAAS,MAAM,EAAE,GAAG,QAAe;AAE9C,YAAM,GAAG,MAAM;QACb,iBAAiB,KAAK,KAAK;QAC3B,cAAc,KAAK,KAAK;QACxB,WAAW,oBAAoB,KAAK,WAAW,SAAS;QACxD,aAAa,WAAW,IAAI,UAAQ,KAAK,KAAK;QAC9C;QACA;QACA,WAAW,SAAS;SACnB;QACD;OACD;AAED,YAAM,OAAO,MAAM;QACjB;OACD;IACH,SAAS,KAAU;AACjB,WAAK,IAAI,MAAM,yCAAyC,GAAG;AAC3D,aAAO,MAAM,GAAG;IAClB;EACF;;;;AC5CI,SAAU,SAAU,OAAqB,CAAA,GAAE;AAC/C,SAAO,CAAC,eAAe,IAAIC,UAAc,YAAY,IAAI;AAC3D;AAEM,SAAU,aAAc,OAAyB,CAAA,GAAE;AACvD,SAAO,CAAC,eAAe,IAAI,aAAkB,YAAY,IAAI;AAC/D;",
  "names": ["Envelope", "message", "a", "b", "PeerRecord", "AddressInfo", "_codec", "_a", "_b", "PeerRecord", "Identify", "_a", "_b", "message", "PeerRecord", "multiaddr", "PeerRecord", "peer", "message", "import_netmask", "CODEC_IP6", "CODEC_IP6", "_a", "_b", "Identify", "message", "PeerRecord", "Identify"]
}
