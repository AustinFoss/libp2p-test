import {
  getIterator
} from "./chunk-RIADKXEZ.js";
import {
  StreamResetError,
  StreamStateError,
  pushable
} from "./chunk-3DZGSS4M.js";
import {
  Uint8ArrayList,
  pDefer,
  raceSignal
} from "./chunk-FILK5HTN.js";
import {
  __publicField
} from "./chunk-WOOG5QLI.js";

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/is-promise.js
function isPromise(thing) {
  if (thing == null) {
    return false;
  }
  return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/close-source.js
function closeSource(source, log) {
  var _a, _b;
  const res = (_b = (_a = getIterator(source)).return) == null ? void 0 : _b.call(_a);
  if (isPromise(res)) {
    res.catch((err) => {
      log.error("could not cause iterator to return", err);
    });
  }
}

// node_modules/.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/dist/src/abstract-stream.js
var DEFAULT_SEND_CLOSE_WRITE_TIMEOUT = 5e3;
function isPromise2(thing) {
  if (thing == null) {
    return false;
  }
  return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}
var AbstractStream = class {
  constructor(init) {
    __publicField(this, "id");
    __publicField(this, "direction");
    __publicField(this, "timeline");
    __publicField(this, "protocol");
    __publicField(this, "metadata");
    __publicField(this, "source");
    __publicField(this, "status");
    __publicField(this, "readStatus");
    __publicField(this, "writeStatus");
    __publicField(this, "log");
    __publicField(this, "sinkController");
    __publicField(this, "sinkEnd");
    __publicField(this, "closed");
    __publicField(this, "endErr");
    __publicField(this, "streamSource");
    __publicField(this, "onEnd");
    __publicField(this, "onCloseRead");
    __publicField(this, "onCloseWrite");
    __publicField(this, "onReset");
    __publicField(this, "onAbort");
    __publicField(this, "sendCloseWriteTimeout");
    __publicField(this, "sendingData");
    this.sinkController = new AbortController();
    this.sinkEnd = pDefer();
    this.closed = pDefer();
    this.log = init.log;
    this.status = "open";
    this.readStatus = "ready";
    this.writeStatus = "ready";
    this.id = init.id;
    this.metadata = init.metadata ?? {};
    this.direction = init.direction;
    this.timeline = {
      open: Date.now()
    };
    this.sendCloseWriteTimeout = init.sendCloseWriteTimeout ?? DEFAULT_SEND_CLOSE_WRITE_TIMEOUT;
    this.onEnd = init.onEnd;
    this.onCloseRead = init == null ? void 0 : init.onCloseRead;
    this.onCloseWrite = init == null ? void 0 : init.onCloseWrite;
    this.onReset = init == null ? void 0 : init.onReset;
    this.onAbort = init == null ? void 0 : init.onAbort;
    this.source = this.streamSource = pushable({
      onEnd: (err) => {
        if (err != null) {
          this.log.trace("source ended with error", err);
        } else {
          this.log.trace("source ended");
        }
        this.onSourceEnd(err);
      }
    });
    this.sink = this.sink.bind(this);
  }
  async sink(source) {
    if (this.writeStatus !== "ready") {
      throw new StreamStateError(`writable end state is "${this.writeStatus}" not "ready"`);
    }
    try {
      this.writeStatus = "writing";
      const options = {
        signal: this.sinkController.signal
      };
      if (this.direction === "outbound") {
        const res = this.sendNewStream(options);
        if (isPromise2(res)) {
          await res;
        }
      }
      const abortListener = () => {
        closeSource(source, this.log);
      };
      try {
        this.sinkController.signal.addEventListener("abort", abortListener);
        this.log.trace("sink reading from source");
        for await (let data of source) {
          data = data instanceof Uint8Array ? new Uint8ArrayList(data) : data;
          const res = this.sendData(data, options);
          if (isPromise2(res)) {
            this.sendingData = pDefer();
            await res;
            this.sendingData.resolve();
            this.sendingData = void 0;
          }
        }
      } finally {
        this.sinkController.signal.removeEventListener("abort", abortListener);
      }
      this.log.trace('sink finished reading from source, write status is "%s"', this.writeStatus);
      if (this.writeStatus === "writing") {
        this.writeStatus = "closing";
        this.log.trace("send close write to remote");
        await this.sendCloseWrite({
          signal: AbortSignal.timeout(this.sendCloseWriteTimeout)
        });
        this.writeStatus = "closed";
      }
      this.onSinkEnd();
    } catch (err) {
      this.log.trace("sink ended with error, calling abort with error", err);
      this.abort(err);
      throw err;
    } finally {
      this.log.trace("resolve sink end");
      this.sinkEnd.resolve();
    }
  }
  onSourceEnd(err) {
    var _a;
    if (this.timeline.closeRead != null) {
      return;
    }
    this.timeline.closeRead = Date.now();
    this.readStatus = "closed";
    if (err != null && this.endErr == null) {
      this.endErr = err;
    }
    (_a = this.onCloseRead) == null ? void 0 : _a.call(this);
    if (this.timeline.closeWrite != null) {
      this.log.trace("source and sink ended");
      this.timeline.close = Date.now();
      if (this.status !== "aborted" && this.status !== "reset") {
        this.status = "closed";
      }
      if (this.onEnd != null) {
        this.onEnd(this.endErr);
      }
      this.closed.resolve();
    } else {
      this.log.trace("source ended, waiting for sink to end");
    }
  }
  onSinkEnd(err) {
    var _a;
    if (this.timeline.closeWrite != null) {
      return;
    }
    this.timeline.closeWrite = Date.now();
    this.writeStatus = "closed";
    if (err != null && this.endErr == null) {
      this.endErr = err;
    }
    (_a = this.onCloseWrite) == null ? void 0 : _a.call(this);
    if (this.timeline.closeRead != null) {
      this.log.trace("sink and source ended");
      this.timeline.close = Date.now();
      if (this.status !== "aborted" && this.status !== "reset") {
        this.status = "closed";
      }
      if (this.onEnd != null) {
        this.onEnd(this.endErr);
      }
      this.closed.resolve();
    } else {
      this.log.trace("sink ended, waiting for source to end");
    }
  }
  // Close for both Reading and Writing
  async close(options) {
    if (this.status !== "open") {
      return;
    }
    this.log.trace("closing gracefully");
    this.status = "closing";
    await raceSignal(Promise.all([
      this.closeWrite(options),
      this.closeRead(options),
      this.closed.promise
    ]), options == null ? void 0 : options.signal);
    this.status = "closed";
    this.log.trace("closed gracefully");
  }
  async closeRead(options = {}) {
    if (this.readStatus === "closing" || this.readStatus === "closed") {
      return;
    }
    this.log.trace('closing readable end of stream with starting read status "%s"', this.readStatus);
    const readStatus = this.readStatus;
    this.readStatus = "closing";
    if (this.status !== "reset" && this.status !== "aborted" && this.timeline.closeRead == null) {
      this.log.trace("send close read to remote");
      await this.sendCloseRead(options);
    }
    if (readStatus === "ready") {
      this.log.trace("ending internal source queue with %d queued bytes", this.streamSource.readableLength);
      this.streamSource.end();
    }
    this.log.trace("closed readable end of stream");
  }
  async closeWrite(options = {}) {
    if (this.writeStatus === "closing" || this.writeStatus === "closed") {
      return;
    }
    this.log.trace('closing writable end of stream with starting write status "%s"', this.writeStatus);
    if (this.writeStatus === "ready") {
      this.log.trace("sink was never sunk, sink an empty array");
      await raceSignal(this.sink([]), options.signal);
    }
    if (this.writeStatus === "writing") {
      if (this.sendingData != null) {
        await raceSignal(this.sendingData.promise, options.signal);
      }
      this.log.trace("aborting source passed to .sink");
      this.sinkController.abort();
      await raceSignal(this.sinkEnd.promise, options.signal);
    }
    this.writeStatus = "closed";
    this.log.trace("closed writable end of stream");
  }
  /**
   * Close immediately for reading and writing and send a reset message (local
   * error)
   */
  abort(err) {
    var _a;
    if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
      return;
    }
    this.log("abort with error", err);
    this.log("try to send reset to remote");
    const res = this.sendReset();
    if (isPromise2(res)) {
      res.catch((err2) => {
        this.log.error("error sending reset message", err2);
      });
    }
    this.status = "aborted";
    this.timeline.abort = Date.now();
    this._closeSinkAndSource(err);
    (_a = this.onAbort) == null ? void 0 : _a.call(this, err);
  }
  /**
   * Receive a reset message - close immediately for reading and writing (remote
   * error)
   */
  reset() {
    var _a;
    if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
      return;
    }
    const err = new StreamResetError("stream reset");
    this.status = "reset";
    this.timeline.reset = Date.now();
    this._closeSinkAndSource(err);
    (_a = this.onReset) == null ? void 0 : _a.call(this);
  }
  _closeSinkAndSource(err) {
    this._closeSink(err);
    this._closeSource(err);
  }
  _closeSink(err) {
    if (this.writeStatus === "writing") {
      this.log.trace("end sink source");
      this.sinkController.abort();
    }
    this.onSinkEnd(err);
  }
  _closeSource(err) {
    if (this.readStatus !== "closing" && this.readStatus !== "closed") {
      this.log.trace("ending source with %d bytes to be read by consumer", this.streamSource.readableLength);
      this.readStatus = "closing";
      this.streamSource.end(err);
    }
  }
  /**
   * The remote closed for writing so we should expect to receive no more
   * messages
   */
  remoteCloseWrite() {
    if (this.readStatus === "closing" || this.readStatus === "closed") {
      this.log("received remote close write but local source is already closed");
      return;
    }
    this.log.trace("remote close write");
    this._closeSource();
  }
  /**
   * The remote closed for reading so we should not send any more
   * messages
   */
  remoteCloseRead() {
    if (this.writeStatus === "closing" || this.writeStatus === "closed") {
      this.log("received remote close read but local sink is already closed");
      return;
    }
    this.log.trace("remote close read");
    this._closeSink();
  }
  /**
   * The underlying muxer has closed, no more messages can be sent or will
   * be received, close immediately to free up resources
   */
  destroy() {
    if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
      this.log("received destroy but we are already closed");
      return;
    }
    this.log.trace("stream destroyed");
    this._closeSinkAndSource();
  }
  /**
   * When an extending class reads data from it's implementation-specific source,
   * call this method to allow the stream consumer to read the data.
   */
  sourcePush(data) {
    this.streamSource.push(data);
  }
  /**
   * Returns the amount of unread data - can be used to prevent large amounts of
   * data building up when the stream consumer is too slow.
   */
  sourceReadableLength() {
    return this.streamSource.readableLength;
  }
};

export {
  AbstractStream
};
//# sourceMappingURL=chunk-YVXRMXU7.js.map
