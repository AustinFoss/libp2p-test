import {
  decodeMessage,
  ed25519,
  encodeMessage,
  enumeration,
  message,
  queuelessPushable,
  randomBytes,
  secp256k1,
  sha256 as sha2562
} from "./chunk-GN2SHL2J.js";
import {
  Uint8ArrayList,
  raceSignal
} from "./chunk-FILK5HTN.js";
import {
  CID,
  base58btc,
  create,
  fromString,
  identity,
  sha256,
  toString
} from "./chunk-EZM3SP6L.js";
import {
  equals
} from "./chunk-PM7HCL6E.js";
import {
  __export,
  __privateAdd,
  __privateGet,
  __publicField
} from "./chunk-WOOG5QLI.js";

// node_modules/.pnpm/@libp2p+interface@2.8.0/node_modules/@libp2p/interface/dist/src/transport.js
var transportSymbol = Symbol.for("@libp2p/transport");
var FaultTolerance;
(function(FaultTolerance2) {
  FaultTolerance2[FaultTolerance2["FATAL_ALL"] = 0] = "FATAL_ALL";
  FaultTolerance2[FaultTolerance2["NO_FATAL"] = 1] = "NO_FATAL";
})(FaultTolerance || (FaultTolerance = {}));

// node_modules/.pnpm/@libp2p+interface@2.8.0/node_modules/@libp2p/interface/dist/src/errors.js
var InvalidParametersError = class extends Error {
  constructor(message2 = "Invalid parameters") {
    super(message2);
    this.name = "InvalidParametersError";
  }
};
__publicField(InvalidParametersError, "name", "InvalidParametersError");
var InvalidPublicKeyError = class extends Error {
  constructor(message2 = "Invalid public key") {
    super(message2);
    this.name = "InvalidPublicKeyError";
  }
};
__publicField(InvalidPublicKeyError, "name", "InvalidPublicKeyError");
var InvalidPrivateKeyError = class extends Error {
  constructor(message2 = "Invalid private key") {
    super(message2);
    this.name = "InvalidPrivateKeyError";
  }
};
__publicField(InvalidPrivateKeyError, "name", "InvalidPrivateKeyError");
var ConnectionFailedError = class extends Error {
  constructor(message2 = "Connection failed") {
    super(message2);
    this.name = "ConnectionFailedError";
  }
};
__publicField(ConnectionFailedError, "name", "ConnectionFailedError");
var StreamResetError = class extends Error {
  constructor(message2 = "The stream has been reset") {
    super(message2);
    this.name = "StreamResetError";
  }
};
__publicField(StreamResetError, "name", "StreamResetError");
var StreamStateError = class extends Error {
  constructor(message2 = "The stream is in an invalid state") {
    super(message2);
    this.name = "StreamStateError";
  }
};
__publicField(StreamStateError, "name", "StreamStateError");
var NotFoundError = class extends Error {
  constructor(message2 = "Not found") {
    super(message2);
    this.name = "NotFoundError";
  }
};
__publicField(NotFoundError, "name", "NotFoundError");
var InvalidCIDError = class extends Error {
  constructor(message2 = "Invalid CID") {
    super(message2);
    this.name = "InvalidCIDError";
  }
};
__publicField(InvalidCIDError, "name", "InvalidCIDError");
var InvalidMultihashError = class extends Error {
  constructor(message2 = "Invalid Multihash") {
    super(message2);
    this.name = "InvalidMultihashError";
  }
};
__publicField(InvalidMultihashError, "name", "InvalidMultihashError");
var UnsupportedProtocolError = class extends Error {
  constructor(message2 = "Unsupported protocol error") {
    super(message2);
    this.name = "UnsupportedProtocolError";
  }
};
__publicField(UnsupportedProtocolError, "name", "UnsupportedProtocolError");
var InvalidMessageError = class extends Error {
  constructor(message2 = "Invalid message") {
    super(message2);
    this.name = "InvalidMessageError";
  }
};
__publicField(InvalidMessageError, "name", "InvalidMessageError");
var ProtocolError = class extends Error {
  constructor(message2 = "Protocol error") {
    super(message2);
    this.name = "ProtocolError";
  }
};
__publicField(ProtocolError, "name", "ProtocolError");
var TimeoutError = class extends Error {
  constructor(message2 = "Timed out") {
    super(message2);
    this.name = "TimeoutError";
  }
};
__publicField(TimeoutError, "name", "TimeoutError");
var NotStartedError = class extends Error {
  constructor(message2 = "Not started") {
    super(message2);
    this.name = "NotStartedError";
  }
};
__publicField(NotStartedError, "name", "NotStartedError");
var UnsupportedKeyTypeError = class extends Error {
  constructor(message2 = "Unsupported key type") {
    super(message2);
    this.name = "UnsupportedKeyTypeError";
  }
};
__publicField(UnsupportedKeyTypeError, "name", "UnsupportedKeyTypeError");

// node_modules/.pnpm/@libp2p+interface@2.8.0/node_modules/@libp2p/interface/dist/src/events.browser.js
function setMaxListeners() {
}

// node_modules/.pnpm/@libp2p+interface@2.8.0/node_modules/@libp2p/interface/dist/src/event-target.js
var _listeners;
var TypedEventEmitter = class extends EventTarget {
  constructor() {
    super();
    __privateAdd(this, _listeners, /* @__PURE__ */ new Map());
    setMaxListeners(Infinity, this);
  }
  listenerCount(type) {
    const listeners = __privateGet(this, _listeners).get(type);
    if (listeners == null) {
      return 0;
    }
    return listeners.length;
  }
  addEventListener(type, listener, options) {
    super.addEventListener(type, listener, options);
    let list = __privateGet(this, _listeners).get(type);
    if (list == null) {
      list = [];
      __privateGet(this, _listeners).set(type, list);
    }
    list.push({
      callback: listener,
      once: (options !== true && options !== false && (options == null ? void 0 : options.once)) ?? false
    });
  }
  removeEventListener(type, listener, options) {
    super.removeEventListener(type.toString(), listener ?? null, options);
    let list = __privateGet(this, _listeners).get(type);
    if (list == null) {
      return;
    }
    list = list.filter(({ callback }) => callback !== listener);
    __privateGet(this, _listeners).set(type, list);
  }
  dispatchEvent(event) {
    const result = super.dispatchEvent(event);
    let list = __privateGet(this, _listeners).get(event.type);
    if (list == null) {
      return result;
    }
    list = list.filter(({ once }) => !once);
    __privateGet(this, _listeners).set(event.type, list);
    return result;
  }
  safeDispatchEvent(type, detail = {}) {
    return this.dispatchEvent(new CustomEvent(type, detail));
  }
};
_listeners = new WeakMap();

// node_modules/.pnpm/@libp2p+interface@2.8.0/node_modules/@libp2p/interface/dist/src/connection.js
var connectionSymbol = Symbol.for("@libp2p/connection");

// node_modules/.pnpm/@libp2p+interface@2.8.0/node_modules/@libp2p/interface/dist/src/content-routing.js
var contentRoutingSymbol = Symbol.for("@libp2p/content-routing");

// node_modules/.pnpm/@libp2p+interface@2.8.0/node_modules/@libp2p/interface/dist/src/peer-discovery.js
var peerDiscoverySymbol = Symbol.for("@libp2p/peer-discovery");

// node_modules/.pnpm/@libp2p+interface@2.8.0/node_modules/@libp2p/interface/dist/src/peer-id.js
var peerIdSymbol = Symbol.for("@libp2p/peer-id");

// node_modules/.pnpm/@libp2p+interface@2.8.0/node_modules/@libp2p/interface/dist/src/peer-routing.js
var peerRoutingSymbol = Symbol.for("@libp2p/peer-routing");

// node_modules/.pnpm/@libp2p+interface@2.8.0/node_modules/@libp2p/interface/dist/src/pubsub.js
var TopicValidatorResult;
(function(TopicValidatorResult2) {
  TopicValidatorResult2["Accept"] = "accept";
  TopicValidatorResult2["Ignore"] = "ignore";
  TopicValidatorResult2["Reject"] = "reject";
})(TopicValidatorResult || (TopicValidatorResult = {}));
var pubSubSymbol = Symbol.for("@libp2p/pubsub");

// node_modules/.pnpm/@libp2p+interface@2.8.0/node_modules/@libp2p/interface/dist/src/index.js
var serviceCapabilities = Symbol.for("@libp2p/service-capabilities");
var serviceDependencies = Symbol.for("@libp2p/service-dependencies");

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/random-bytes.js
function randomBytes2(length) {
  if (isNaN(length) || length <= 0) {
    throw new InvalidParametersError("random bytes length must be a Number bigger than 0");
  }
  return randomBytes(length);
}

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/keys/rsa/der.js
var TAG_MASK = parseInt("11111", 2);
var LONG_LENGTH_MASK = parseInt("10000000", 2);
var LONG_LENGTH_BYTES_MASK = parseInt("01111111", 2);
var decoders = {
  0: readSequence,
  1: readSequence,
  2: readInteger,
  3: readBitString,
  4: readOctetString,
  5: readNull,
  6: readObjectIdentifier,
  16: readSequence,
  22: readSequence,
  48: readSequence
};
function decodeDer(buf, context = { offset: 0 }) {
  const tag = buf[context.offset] & TAG_MASK;
  context.offset++;
  if (decoders[tag] != null) {
    return decoders[tag](buf, context);
  }
  throw new Error("No decoder for tag " + tag);
}
function readLength(buf, context) {
  let length = 0;
  if ((buf[context.offset] & LONG_LENGTH_MASK) === LONG_LENGTH_MASK) {
    const count = buf[context.offset] & LONG_LENGTH_BYTES_MASK;
    let str = "0x";
    context.offset++;
    for (let i = 0; i < count; i++, context.offset++) {
      str += buf[context.offset].toString(16).padStart(2, "0");
    }
    length = parseInt(str, 16);
  } else {
    length = buf[context.offset];
    context.offset++;
  }
  return length;
}
function readSequence(buf, context) {
  readLength(buf, context);
  const entries = [];
  while (true) {
    if (context.offset >= buf.byteLength) {
      break;
    }
    const result = decodeDer(buf, context);
    if (result === null) {
      break;
    }
    entries.push(result);
  }
  return entries;
}
function readInteger(buf, context) {
  const length = readLength(buf, context);
  const start = context.offset;
  const end = context.offset + length;
  const vals = [];
  for (let i = start; i < end; i++) {
    if (i === start && buf[i] === 0) {
      continue;
    }
    vals.push(buf[i]);
  }
  context.offset += length;
  return Uint8Array.from(vals);
}
function readObjectIdentifier(buf, context) {
  const count = readLength(buf, context);
  const finalOffset = context.offset + count;
  const byte = buf[context.offset];
  context.offset++;
  let val1 = 0;
  let val2 = 0;
  if (byte < 40) {
    val1 = 0;
    val2 = byte;
  } else if (byte < 80) {
    val1 = 1;
    val2 = byte - 40;
  } else {
    val1 = 2;
    val2 = byte - 80;
  }
  let oid = `${val1}.${val2}`;
  let num = [];
  while (context.offset < finalOffset) {
    const byte2 = buf[context.offset];
    context.offset++;
    num.push(byte2 & 127);
    if (byte2 < 128) {
      num.reverse();
      let val = 0;
      for (let i = 0; i < num.length; i++) {
        val += num[i] << i * 7;
      }
      oid += `.${val}`;
      num = [];
    }
  }
  return oid;
}
function readNull(buf, context) {
  context.offset++;
  return null;
}
function readBitString(buf, context) {
  const length = readLength(buf, context);
  const unusedBits = buf[context.offset];
  context.offset++;
  const bytes = buf.subarray(context.offset, context.offset + length - 1);
  context.offset += length;
  if (unusedBits !== 0) {
    throw new Error("Unused bits in bit string is unimplemented");
  }
  return bytes;
}
function readOctetString(buf, context) {
  const length = readLength(buf, context);
  const bytes = buf.subarray(context.offset, context.offset + length);
  context.offset += length;
  return bytes;
}
function encodeNumber(value) {
  let number = value.toString(16);
  if (number.length % 2 === 1) {
    number = "0" + number;
  }
  const array = new Uint8ArrayList();
  for (let i = 0; i < number.length; i += 2) {
    array.append(Uint8Array.from([parseInt(`${number[i]}${number[i + 1]}`, 16)]));
  }
  return array;
}
function encodeLength(bytes) {
  if (bytes.byteLength < 128) {
    return Uint8Array.from([bytes.byteLength]);
  }
  const length = encodeNumber(bytes.byteLength);
  return new Uint8ArrayList(Uint8Array.from([
    length.byteLength | LONG_LENGTH_MASK
  ]), length);
}
function encodeInteger(value) {
  const contents = new Uint8ArrayList();
  const mask = 128;
  const positive = (value.subarray()[0] & mask) === mask;
  if (positive) {
    contents.append(Uint8Array.from([0]));
  }
  contents.append(value);
  return new Uint8ArrayList(Uint8Array.from([2]), encodeLength(contents), contents);
}
function encodeBitString(value) {
  const unusedBits = Uint8Array.from([0]);
  const contents = new Uint8ArrayList(unusedBits, value);
  return new Uint8ArrayList(Uint8Array.from([3]), encodeLength(contents), contents);
}
function encodeOctetString(value) {
  return new Uint8ArrayList(Uint8Array.from([4]), encodeLength(value), value);
}
function encodeSequence(values, tag = 48) {
  const output = new Uint8ArrayList();
  for (const buf of values) {
    output.append(buf);
  }
  return new Uint8ArrayList(Uint8Array.from([tag]), encodeLength(output), output);
}

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/keys/ecdsa/index.js
async function generateECDSAKey(curve = "P-256") {
  const keyPair = await crypto.subtle.generateKey({
    name: "ECDSA",
    namedCurve: curve
  }, true, ["sign", "verify"]);
  return {
    publicKey: await crypto.subtle.exportKey("jwk", keyPair.publicKey),
    privateKey: await crypto.subtle.exportKey("jwk", keyPair.privateKey)
  };
}
async function hashAndSign(key, msg) {
  const privateKey = await crypto.subtle.importKey("jwk", key, {
    name: "ECDSA",
    namedCurve: key.crv ?? "P-256"
  }, false, ["sign"]);
  const signature = await crypto.subtle.sign({
    name: "ECDSA",
    hash: {
      name: "SHA-256"
    }
  }, privateKey, msg.subarray());
  return new Uint8Array(signature, 0, signature.byteLength);
}
async function hashAndVerify(key, sig, msg) {
  const publicKey = await crypto.subtle.importKey("jwk", key, {
    name: "ECDSA",
    namedCurve: key.crv ?? "P-256"
  }, false, ["verify"]);
  return crypto.subtle.verify({
    name: "ECDSA",
    hash: {
      name: "SHA-256"
    }
  }, publicKey, sig, msg.subarray());
}

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/keys/ecdsa/utils.js
var OID_256 = Uint8Array.from([6, 8, 42, 134, 72, 206, 61, 3, 1, 7]);
var OID_384 = Uint8Array.from([6, 5, 43, 129, 4, 0, 34]);
var OID_521 = Uint8Array.from([6, 5, 43, 129, 4, 0, 35]);
var P_256_KEY_JWK = {
  ext: true,
  kty: "EC",
  crv: "P-256"
};
var P_384_KEY_JWK = {
  ext: true,
  kty: "EC",
  crv: "P-384"
};
var P_521_KEY_JWK = {
  ext: true,
  kty: "EC",
  crv: "P-521"
};
var P_256_KEY_LENGTH = 32;
var P_384_KEY_LENGTH = 48;
var P_521_KEY_LENGTH = 66;
function unmarshalECDSAPublicKey(bytes) {
  const message2 = decodeDer(bytes);
  return pkiMessageToECDSAPublicKey(message2);
}
function pkiMessageToECDSAPublicKey(message2) {
  const coordinates = message2[1][1][0];
  const offset = 1;
  let x;
  let y;
  if (coordinates.byteLength === P_256_KEY_LENGTH * 2 + 1) {
    x = toString(coordinates.subarray(offset, offset + P_256_KEY_LENGTH), "base64url");
    y = toString(coordinates.subarray(offset + P_256_KEY_LENGTH), "base64url");
    return new ECDSAPublicKey({
      ...P_256_KEY_JWK,
      key_ops: ["verify"],
      x,
      y
    });
  }
  if (coordinates.byteLength === P_384_KEY_LENGTH * 2 + 1) {
    x = toString(coordinates.subarray(offset, offset + P_384_KEY_LENGTH), "base64url");
    y = toString(coordinates.subarray(offset + P_384_KEY_LENGTH), "base64url");
    return new ECDSAPublicKey({
      ...P_384_KEY_JWK,
      key_ops: ["verify"],
      x,
      y
    });
  }
  if (coordinates.byteLength === P_521_KEY_LENGTH * 2 + 1) {
    x = toString(coordinates.subarray(offset, offset + P_521_KEY_LENGTH), "base64url");
    y = toString(coordinates.subarray(offset + P_521_KEY_LENGTH), "base64url");
    return new ECDSAPublicKey({
      ...P_521_KEY_JWK,
      key_ops: ["verify"],
      x,
      y
    });
  }
  throw new InvalidParametersError(`coordinates were wrong length, got ${coordinates.byteLength}, expected 65, 97 or 133`);
}
function privateKeyToPKIMessage(privateKey) {
  return encodeSequence([
    encodeInteger(Uint8Array.from([1])),
    // header
    encodeOctetString(fromString(privateKey.d ?? "", "base64url")),
    // body
    encodeSequence([
      getOID(privateKey.crv)
    ], 160),
    encodeSequence([
      encodeBitString(new Uint8ArrayList(Uint8Array.from([4]), fromString(privateKey.x ?? "", "base64url"), fromString(privateKey.y ?? "", "base64url")))
    ], 161)
  ]).subarray();
}
function publicKeyToPKIMessage(publicKey) {
  return encodeSequence([
    encodeInteger(Uint8Array.from([1])),
    // header
    encodeSequence([
      getOID(publicKey.crv)
    ], 160),
    encodeSequence([
      encodeBitString(new Uint8ArrayList(Uint8Array.from([4]), fromString(publicKey.x ?? "", "base64url"), fromString(publicKey.y ?? "", "base64url")))
    ], 161)
  ]).subarray();
}
function getOID(curve) {
  if (curve === "P-256") {
    return OID_256;
  }
  if (curve === "P-384") {
    return OID_384;
  }
  if (curve === "P-521") {
    return OID_521;
  }
  throw new InvalidParametersError(`Invalid curve ${curve}`);
}
async function generateECDSAKeyPair(curve = "P-256") {
  const key = await generateECDSAKey(curve);
  return new ECDSAPrivateKey(key.privateKey);
}

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/keys/ecdsa/ecdsa.js
var ECDSAPublicKey = class {
  constructor(jwk) {
    __publicField(this, "type", "ECDSA");
    __publicField(this, "jwk");
    __publicField(this, "_raw");
    this.jwk = jwk;
  }
  get raw() {
    if (this._raw == null) {
      this._raw = publicKeyToPKIMessage(this.jwk);
    }
    return this._raw;
  }
  toMultihash() {
    return identity.digest(publicKeyToProtobuf(this));
  }
  toCID() {
    return CID.createV1(114, this.toMultihash());
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key.raw);
  }
  async verify(data, sig) {
    return hashAndVerify(this.jwk, sig, data);
  }
};
var ECDSAPrivateKey = class {
  constructor(jwk) {
    __publicField(this, "type", "ECDSA");
    __publicField(this, "jwk");
    __publicField(this, "publicKey");
    __publicField(this, "_raw");
    this.jwk = jwk;
    this.publicKey = new ECDSAPublicKey({
      crv: jwk.crv,
      ext: jwk.ext,
      key_ops: ["verify"],
      kty: "EC",
      x: jwk.x,
      y: jwk.y
    });
  }
  get raw() {
    if (this._raw == null) {
      this._raw = privateKeyToPKIMessage(this.jwk);
    }
    return this._raw;
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key.raw);
  }
  async sign(message2) {
    return hashAndSign(this.jwk, message2);
  }
};

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/keys/ed25519/index.browser.js
var PUBLIC_KEY_BYTE_LENGTH = 32;
var PRIVATE_KEY_BYTE_LENGTH = 64;
var KEYS_BYTE_LENGTH = 32;
function generateKey() {
  const privateKeyRaw = ed25519.utils.randomPrivateKey();
  const publicKey = ed25519.getPublicKey(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
function hashAndSign2(privateKey, msg) {
  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);
  return ed25519.sign(msg instanceof Uint8Array ? msg : msg.subarray(), privateKeyRaw);
}
function hashAndVerify2(publicKey, sig, msg) {
  return ed25519.verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey);
}
function concatKeys(privateKeyRaw, publicKey) {
  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);
  for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {
    privateKey[i] = privateKeyRaw[i];
    privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i];
  }
  return privateKey;
}

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/keys/ed25519/ed25519.js
var Ed25519PublicKey = class {
  constructor(key) {
    __publicField(this, "type", "Ed25519");
    __publicField(this, "raw");
    this.raw = ensureEd25519Key(key, PUBLIC_KEY_BYTE_LENGTH);
  }
  toMultihash() {
    return identity.digest(publicKeyToProtobuf(this));
  }
  toCID() {
    return CID.createV1(114, this.toMultihash());
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key.raw);
  }
  verify(data, sig) {
    return hashAndVerify2(this.raw, sig, data);
  }
};
var Ed25519PrivateKey = class {
  // key       - 64 byte Uint8Array containing private key
  // publicKey - 32 byte Uint8Array containing public key
  constructor(key, publicKey) {
    __publicField(this, "type", "Ed25519");
    __publicField(this, "raw");
    __publicField(this, "publicKey");
    this.raw = ensureEd25519Key(key, PRIVATE_KEY_BYTE_LENGTH);
    this.publicKey = new Ed25519PublicKey(publicKey);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key.raw);
  }
  sign(message2) {
    return hashAndSign2(this.raw, message2);
  }
};

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/keys/ed25519/utils.js
function unmarshalEd25519PublicKey(bytes) {
  bytes = ensureEd25519Key(bytes, PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PublicKey(bytes);
}
async function generateEd25519KeyPair() {
  const { privateKey, publicKey } = generateKey();
  return new Ed25519PrivateKey(privateKey, publicKey);
}
function ensureEd25519Key(key, length) {
  key = Uint8Array.from(key ?? []);
  if (key.length !== length) {
    throw new InvalidParametersError(`Key must be a Uint8Array of length ${length}, got ${key.length}`);
  }
  return key;
}

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/keys/keys.js
var KeyType;
(function(KeyType2) {
  KeyType2["RSA"] = "RSA";
  KeyType2["Ed25519"] = "Ed25519";
  KeyType2["secp256k1"] = "secp256k1";
  KeyType2["ECDSA"] = "ECDSA";
})(KeyType || (KeyType = {}));
var __KeyTypeValues;
(function(__KeyTypeValues2) {
  __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
  __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
  __KeyTypeValues2[__KeyTypeValues2["secp256k1"] = 2] = "secp256k1";
  __KeyTypeValues2[__KeyTypeValues2["ECDSA"] = 3] = "ECDSA";
})(__KeyTypeValues || (__KeyTypeValues = {}));
(function(KeyType2) {
  KeyType2.codec = () => {
    return enumeration(__KeyTypeValues);
  };
})(KeyType || (KeyType = {}));
var PublicKey;
(function(PublicKey2) {
  let _codec;
  PublicKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {};
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.Type = KeyType.codec().decode(reader);
              break;
            }
            case 2: {
              obj.Data = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PublicKey2.encode = (obj) => {
    return encodeMessage(obj, PublicKey2.codec());
  };
  PublicKey2.decode = (buf, opts) => {
    return decodeMessage(buf, PublicKey2.codec(), opts);
  };
})(PublicKey || (PublicKey = {}));
var PrivateKey;
(function(PrivateKey2) {
  let _codec;
  PrivateKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {};
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.Type = KeyType.codec().decode(reader);
              break;
            }
            case 2: {
              obj.Data = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PrivateKey2.encode = (obj) => {
    return encodeMessage(obj, PrivateKey2.codec());
  };
  PrivateKey2.decode = (buf, opts) => {
    return decodeMessage(buf, PrivateKey2.codec(), opts);
  };
})(PrivateKey || (PrivateKey = {}));

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/errors.js
var SigningError = class extends Error {
  constructor(message2 = "An error occurred while signing a message") {
    super(message2);
    this.name = "SigningError";
  }
};
var VerificationError = class extends Error {
  constructor(message2 = "An error occurred while verifying a message") {
    super(message2);
    this.name = "VerificationError";
  }
};
var WebCryptoMissingError = class extends Error {
  constructor(message2 = "Missing Web Crypto API") {
    super(message2);
    this.name = "WebCryptoMissingError";
  }
};

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/webcrypto/webcrypto.browser.js
var webcrypto_browser_default = {
  get(win = globalThis) {
    const nativeCrypto = win.crypto;
    if ((nativeCrypto == null ? void 0 : nativeCrypto.subtle) == null) {
      throw new WebCryptoMissingError("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");
    }
    return nativeCrypto;
  }
};

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/webcrypto/index.js
var webcrypto_default = webcrypto_browser_default;

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/keys/rsa/utils.js
var utils_exports = {};
__export(utils_exports, {
  MAX_RSA_KEY_SIZE: () => MAX_RSA_KEY_SIZE,
  generateRSAKeyPair: () => generateRSAKeyPair,
  jwkToJWKKeyPair: () => jwkToJWKKeyPair,
  jwkToPkcs1: () => jwkToPkcs1,
  jwkToPkix: () => jwkToPkix,
  jwkToRSAPrivateKey: () => jwkToRSAPrivateKey,
  pkcs1MessageToJwk: () => pkcs1MessageToJwk,
  pkcs1MessageToRSAPrivateKey: () => pkcs1MessageToRSAPrivateKey,
  pkcs1ToJwk: () => pkcs1ToJwk,
  pkcs1ToRSAPrivateKey: () => pkcs1ToRSAPrivateKey,
  pkixMessageToJwk: () => pkixMessageToJwk,
  pkixMessageToRSAPublicKey: () => pkixMessageToRSAPublicKey,
  pkixToJwk: () => pkixToJwk,
  pkixToRSAPublicKey: () => pkixToRSAPublicKey
});

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/keys/rsa/rsa.js
var RSAPublicKey = class {
  constructor(jwk, digest) {
    __publicField(this, "type", "RSA");
    __publicField(this, "jwk");
    __publicField(this, "_raw");
    __publicField(this, "_multihash");
    this.jwk = jwk;
    this._multihash = digest;
  }
  get raw() {
    if (this._raw == null) {
      this._raw = utils_exports.jwkToPkix(this.jwk);
    }
    return this._raw;
  }
  toMultihash() {
    return this._multihash;
  }
  toCID() {
    return CID.createV1(114, this._multihash);
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key.raw);
  }
  verify(data, sig) {
    return hashAndVerify3(this.jwk, sig, data);
  }
};
var RSAPrivateKey = class {
  constructor(jwk, publicKey) {
    __publicField(this, "type", "RSA");
    __publicField(this, "jwk");
    __publicField(this, "_raw");
    __publicField(this, "publicKey");
    this.jwk = jwk;
    this.publicKey = publicKey;
  }
  get raw() {
    if (this._raw == null) {
      this._raw = utils_exports.jwkToPkcs1(this.jwk);
    }
    return this._raw;
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key.raw);
  }
  sign(message2) {
    return hashAndSign3(this.jwk, message2);
  }
};

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/keys/rsa/utils.js
var MAX_RSA_KEY_SIZE = 8192;
var SHA2_256_CODE = 18;
var MAX_RSA_JWK_SIZE = 1062;
var RSA_ALGORITHM_IDENTIFIER = Uint8Array.from([
  48,
  13,
  6,
  9,
  42,
  134,
  72,
  134,
  247,
  13,
  1,
  1,
  1,
  5,
  0
]);
function pkcs1ToJwk(bytes) {
  const message2 = decodeDer(bytes);
  return pkcs1MessageToJwk(message2);
}
function pkcs1MessageToJwk(message2) {
  return {
    n: toString(message2[1], "base64url"),
    e: toString(message2[2], "base64url"),
    d: toString(message2[3], "base64url"),
    p: toString(message2[4], "base64url"),
    q: toString(message2[5], "base64url"),
    dp: toString(message2[6], "base64url"),
    dq: toString(message2[7], "base64url"),
    qi: toString(message2[8], "base64url"),
    kty: "RSA"
  };
}
function jwkToPkcs1(jwk) {
  if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
    throw new InvalidParametersError("JWK was missing components");
  }
  return encodeSequence([
    encodeInteger(Uint8Array.from([0])),
    encodeInteger(fromString(jwk.n, "base64url")),
    encodeInteger(fromString(jwk.e, "base64url")),
    encodeInteger(fromString(jwk.d, "base64url")),
    encodeInteger(fromString(jwk.p, "base64url")),
    encodeInteger(fromString(jwk.q, "base64url")),
    encodeInteger(fromString(jwk.dp, "base64url")),
    encodeInteger(fromString(jwk.dq, "base64url")),
    encodeInteger(fromString(jwk.qi, "base64url"))
  ]).subarray();
}
function pkixToJwk(bytes) {
  const message2 = decodeDer(bytes, {
    offset: 0
  });
  return pkixMessageToJwk(message2);
}
function pkixMessageToJwk(message2) {
  const keys = decodeDer(message2[1], {
    offset: 0
  });
  return {
    kty: "RSA",
    n: toString(keys[0], "base64url"),
    e: toString(keys[1], "base64url")
  };
}
function jwkToPkix(jwk) {
  if (jwk.n == null || jwk.e == null) {
    throw new InvalidParametersError("JWK was missing components");
  }
  const subjectPublicKeyInfo = encodeSequence([
    RSA_ALGORITHM_IDENTIFIER,
    encodeBitString(encodeSequence([
      encodeInteger(fromString(jwk.n, "base64url")),
      encodeInteger(fromString(jwk.e, "base64url"))
    ]))
  ]);
  return subjectPublicKeyInfo.subarray();
}
function pkcs1ToRSAPrivateKey(bytes) {
  const message2 = decodeDer(bytes);
  return pkcs1MessageToRSAPrivateKey(message2);
}
function pkcs1MessageToRSAPrivateKey(message2) {
  const jwk = pkcs1MessageToJwk(message2);
  return jwkToRSAPrivateKey(jwk);
}
function pkixToRSAPublicKey(bytes, digest) {
  if (bytes.byteLength >= MAX_RSA_JWK_SIZE) {
    throw new InvalidPublicKeyError("Key size is too large");
  }
  const message2 = decodeDer(bytes, {
    offset: 0
  });
  return pkixMessageToRSAPublicKey(message2, bytes, digest);
}
function pkixMessageToRSAPublicKey(message2, bytes, digest) {
  const jwk = pkixMessageToJwk(message2);
  if (digest == null) {
    const hash = sha2562(PublicKey.encode({
      Type: KeyType.RSA,
      Data: bytes
    }));
    digest = create(SHA2_256_CODE, hash);
  }
  return new RSAPublicKey(jwk, digest);
}
function jwkToRSAPrivateKey(jwk) {
  if (rsaKeySize(jwk) > MAX_RSA_KEY_SIZE) {
    throw new InvalidParametersError("Key size is too large");
  }
  const keys = jwkToJWKKeyPair(jwk);
  const hash = sha2562(PublicKey.encode({
    Type: KeyType.RSA,
    Data: jwkToPkix(keys.publicKey)
  }));
  const digest = create(SHA2_256_CODE, hash);
  return new RSAPrivateKey(keys.privateKey, new RSAPublicKey(keys.publicKey, digest));
}
async function generateRSAKeyPair(bits) {
  if (bits > MAX_RSA_KEY_SIZE) {
    throw new InvalidParametersError("Key size is too large");
  }
  const keys = await generateRSAKey(bits);
  const hash = sha2562(PublicKey.encode({
    Type: KeyType.RSA,
    Data: jwkToPkix(keys.publicKey)
  }));
  const digest = create(SHA2_256_CODE, hash);
  return new RSAPrivateKey(keys.privateKey, new RSAPublicKey(keys.publicKey, digest));
}
function jwkToJWKKeyPair(key) {
  if (key == null) {
    throw new InvalidParametersError("Missing key parameter");
  }
  return {
    privateKey: key,
    publicKey: {
      kty: key.kty,
      n: key.n,
      e: key.e
    }
  };
}

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/keys/rsa/index.browser.js
async function generateRSAKey(bits) {
  const pair = await webcrypto_default.get().subtle.generateKey({
    name: "RSASSA-PKCS1-v1_5",
    modulusLength: bits,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash: { name: "SHA-256" }
  }, true, ["sign", "verify"]);
  const keys = await exportKey(pair);
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
async function hashAndSign3(key, msg) {
  const privateKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["sign"]);
  const sig = await webcrypto_default.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, msg instanceof Uint8Array ? msg : msg.subarray());
  return new Uint8Array(sig, 0, sig.byteLength);
}
async function hashAndVerify3(key, sig, msg) {
  const publicKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["verify"]);
  return webcrypto_default.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg instanceof Uint8Array ? msg : msg.subarray());
}
async function exportKey(pair) {
  if (pair.privateKey == null || pair.publicKey == null) {
    throw new InvalidParametersError("Private and public key are required");
  }
  return Promise.all([
    webcrypto_default.get().subtle.exportKey("jwk", pair.privateKey),
    webcrypto_default.get().subtle.exportKey("jwk", pair.publicKey)
  ]);
}
function rsaKeySize(jwk) {
  if (jwk.kty !== "RSA") {
    throw new InvalidParametersError("invalid key type");
  } else if (jwk.n == null) {
    throw new InvalidParametersError("invalid key modulus");
  }
  const bytes = fromString(jwk.n, "base64url");
  return bytes.length * 8;
}

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/util.js
function isPromise(thing) {
  if (thing == null) {
    return false;
  }
  return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/keys/secp256k1/index.browser.js
function hashAndSign4(key, msg) {
  const p = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray());
  if (isPromise(p)) {
    return p.then(({ digest }) => secp256k1.sign(digest, key).toDERRawBytes()).catch((err) => {
      throw new SigningError(String(err));
    });
  }
  try {
    return secp256k1.sign(p.digest, key).toDERRawBytes();
  } catch (err) {
    throw new SigningError(String(err));
  }
}
function hashAndVerify4(key, sig, msg) {
  const p = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray());
  if (isPromise(p)) {
    return p.then(({ digest }) => secp256k1.verify(sig, digest, key)).catch((err) => {
      throw new VerificationError(String(err));
    });
  }
  try {
    return secp256k1.verify(sig, p.digest, key);
  } catch (err) {
    throw new VerificationError(String(err));
  }
}

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/keys/secp256k1/secp256k1.js
var Secp256k1PublicKey = class {
  constructor(key) {
    __publicField(this, "type", "secp256k1");
    __publicField(this, "raw");
    __publicField(this, "_key");
    this._key = validateSecp256k1PublicKey(key);
    this.raw = compressSecp256k1PublicKey(this._key);
  }
  toMultihash() {
    return identity.digest(publicKeyToProtobuf(this));
  }
  toCID() {
    return CID.createV1(114, this.toMultihash());
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key.raw);
  }
  verify(data, sig) {
    return hashAndVerify4(this._key, sig, data);
  }
};
var Secp256k1PrivateKey = class {
  constructor(key, publicKey) {
    __publicField(this, "type", "secp256k1");
    __publicField(this, "raw");
    __publicField(this, "publicKey");
    this.raw = validateSecp256k1PrivateKey(key);
    this.publicKey = new Secp256k1PublicKey(publicKey ?? computeSecp256k1PublicKey(key));
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key.raw);
  }
  sign(message2) {
    return hashAndSign4(this.raw, message2);
  }
};

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/keys/secp256k1/utils.js
function unmarshalSecp256k1PublicKey(bytes) {
  return new Secp256k1PublicKey(bytes);
}
async function generateSecp256k1KeyPair() {
  const privateKeyBytes = generateSecp256k1PrivateKey();
  return new Secp256k1PrivateKey(privateKeyBytes);
}
function compressSecp256k1PublicKey(key) {
  const point = secp256k1.ProjectivePoint.fromHex(key).toRawBytes(true);
  return point;
}
function validateSecp256k1PrivateKey(key) {
  try {
    secp256k1.getPublicKey(key, true);
    return key;
  } catch (err) {
    throw new InvalidPrivateKeyError(String(err));
  }
}
function validateSecp256k1PublicKey(key) {
  try {
    secp256k1.ProjectivePoint.fromHex(key);
    return key;
  } catch (err) {
    throw new InvalidPublicKeyError(String(err));
  }
}
function computeSecp256k1PublicKey(privateKey) {
  try {
    return secp256k1.getPublicKey(privateKey, true);
  } catch (err) {
    throw new InvalidPrivateKeyError(String(err));
  }
}
function generateSecp256k1PrivateKey() {
  return secp256k1.utils.randomPrivateKey();
}

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/keys/ecdh/index.browser.js
var curveLengths = {
  "P-256": 32,
  "P-384": 48,
  "P-521": 66
};
var curveTypes = Object.keys(curveLengths);
var names = curveTypes.join(" / ");

// node_modules/.pnpm/@libp2p+crypto@5.1.0/node_modules/@libp2p/crypto/dist/src/keys/index.js
async function generateKeyPair(type, bits) {
  if (type === "Ed25519") {
    return generateEd25519KeyPair();
  }
  if (type === "secp256k1") {
    return generateSecp256k1KeyPair();
  }
  if (type === "RSA") {
    return generateRSAKeyPair(toBits(bits));
  }
  if (type === "ECDSA") {
    return generateECDSAKeyPair(toCurve(bits));
  }
  throw new UnsupportedKeyTypeError();
}
function publicKeyFromProtobuf(buf, digest) {
  const { Type, Data } = PublicKey.decode(buf);
  const data = Data ?? new Uint8Array();
  switch (Type) {
    case KeyType.RSA:
      return pkixToRSAPublicKey(data, digest);
    case KeyType.Ed25519:
      return unmarshalEd25519PublicKey(data);
    case KeyType.secp256k1:
      return unmarshalSecp256k1PublicKey(data);
    case KeyType.ECDSA:
      return unmarshalECDSAPublicKey(data);
    default:
      throw new UnsupportedKeyTypeError();
  }
}
function publicKeyFromMultihash(digest) {
  const { Type, Data } = PublicKey.decode(digest.digest);
  const data = Data ?? new Uint8Array();
  switch (Type) {
    case KeyType.Ed25519:
      return unmarshalEd25519PublicKey(data);
    case KeyType.secp256k1:
      return unmarshalSecp256k1PublicKey(data);
    case KeyType.ECDSA:
      return unmarshalECDSAPublicKey(data);
    default:
      throw new UnsupportedKeyTypeError();
  }
}
function publicKeyToProtobuf(key) {
  return PublicKey.encode({
    Type: KeyType[key.type],
    Data: key.raw
  });
}
function toBits(bits) {
  if (bits == null) {
    return 2048;
  }
  return parseInt(bits, 10);
}
function toCurve(curve) {
  if (curve === "P-256" || curve == null) {
    return "P-256";
  }
  if (curve === "P-384") {
    return "P-384";
  }
  if (curve === "P-521") {
    return "P-521";
  }
  throw new InvalidParametersError("Unsupported curve, should be P-256, P-384 or P-521");
}
async function privateKeyToCryptoKeyPair(privateKey) {
  if (privateKey.type === "RSA") {
    return {
      privateKey: await crypto.subtle.importKey("jwk", privateKey.jwk, {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      }, true, ["sign"]),
      publicKey: await crypto.subtle.importKey("jwk", privateKey.publicKey.jwk, {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      }, true, ["verify"])
    };
  }
  if (privateKey.type === "ECDSA") {
    return {
      privateKey: await crypto.subtle.importKey("jwk", privateKey.jwk, {
        name: "ECDSA",
        namedCurve: privateKey.jwk.crv ?? "P-256"
      }, true, ["sign"]),
      publicKey: await crypto.subtle.importKey("jwk", privateKey.publicKey.jwk, {
        name: "ECDSA",
        namedCurve: privateKey.publicKey.jwk.crv ?? "P-256"
      }, true, ["verify"])
    };
  }
  throw new InvalidParametersError("Only RSA and ECDSA keys are supported");
}

// node_modules/.pnpm/it-byte-stream@2.0.1/node_modules/it-byte-stream/dist/src/errors.js
var UnexpectedEOFError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UnexpectedEOFError");
    __publicField(this, "code", "ERR_UNEXPECTED_EOF");
  }
};

// node_modules/.pnpm/it-byte-stream@2.0.1/node_modules/it-byte-stream/dist/src/index.js
function byteStream(duplex, opts) {
  const write = queuelessPushable();
  duplex.sink(write).catch(async (err) => {
    await write.end(err);
  });
  duplex.sink = async (source2) => {
    for await (const buf of source2) {
      await write.push(buf);
    }
    await write.end();
  };
  let source = duplex.source;
  if (duplex.source[Symbol.iterator] != null) {
    source = duplex.source[Symbol.iterator]();
  } else if (duplex.source[Symbol.asyncIterator] != null) {
    source = duplex.source[Symbol.asyncIterator]();
  }
  const readBuffer = new Uint8ArrayList();
  const W = {
    read: async (options) => {
      var _a;
      (_a = options == null ? void 0 : options.signal) == null ? void 0 : _a.throwIfAborted();
      if ((options == null ? void 0 : options.bytes) == null) {
        const { done, value } = await raceSignal(source.next(), options == null ? void 0 : options.signal);
        if (done === true) {
          return null;
        }
        return value;
      }
      while (readBuffer.byteLength < options.bytes) {
        const { value, done } = await raceSignal(source.next(), options == null ? void 0 : options.signal);
        if (done === true) {
          throw new UnexpectedEOFError("unexpected end of input");
        }
        readBuffer.append(value);
      }
      const buf = readBuffer.sublist(0, options.bytes);
      readBuffer.consume(options.bytes);
      return buf;
    },
    write: async (data, options) => {
      var _a;
      (_a = options == null ? void 0 : options.signal) == null ? void 0 : _a.throwIfAborted();
      if (data instanceof Uint8Array) {
        await write.push(data, options);
      } else {
        await write.push(data.subarray(), options);
      }
    },
    unwrap: () => {
      if (readBuffer.byteLength > 0) {
        const originalStream = duplex.source;
        duplex.source = async function* () {
          if ((opts == null ? void 0 : opts.yieldBytes) === false) {
            yield readBuffer;
          } else {
            yield* readBuffer;
          }
          yield* originalStream;
        }();
      }
      return duplex;
    }
  };
  return W;
}

export {
  peerIdSymbol,
  transportSymbol,
  InvalidParametersError,
  ConnectionFailedError,
  StreamResetError,
  StreamStateError,
  NotFoundError,
  InvalidCIDError,
  InvalidMultihashError,
  UnsupportedProtocolError,
  InvalidMessageError,
  ProtocolError,
  TimeoutError,
  NotStartedError,
  UnsupportedKeyTypeError,
  setMaxListeners,
  TypedEventEmitter,
  serviceCapabilities,
  serviceDependencies,
  randomBytes2 as randomBytes,
  generateKeyPair,
  publicKeyFromProtobuf,
  publicKeyFromMultihash,
  publicKeyToProtobuf,
  privateKeyToCryptoKeyPair,
  byteStream
};
//# sourceMappingURL=chunk-RIK5ZR2K.js.map
