{
  "version": 3,
  "sources": ["../../.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js", "../../.pnpm/hashlru@2.3.0/node_modules/hashlru/index.js", "../../.pnpm/is-plain-obj@2.1.0/node_modules/is-plain-obj/index.js", "../../.pnpm/merge-options@3.0.4/node_modules/merge-options/index.js", "../../.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js", "../../.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js", "../../.pnpm/retry@0.13.1/node_modules/retry/index.js", "../../.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.mjs", "../../.pnpm/p-queue@8.1.0/node_modules/p-queue/dist/lower-bound.js", "../../.pnpm/p-queue@8.1.0/node_modules/p-queue/dist/priority-queue.js", "../../.pnpm/p-queue@8.1.0/node_modules/p-queue/dist/index.js", "../../.pnpm/@multiformats+dns@1.0.6/node_modules/@multiformats/dns/src/utils/get-types.ts", "../../.pnpm/@multiformats+dns@1.0.6/node_modules/@multiformats/dns/src/utils/to-dns-response.ts", "../../.pnpm/@multiformats+dns@1.0.6/node_modules/@multiformats/dns/src/resolvers/dns-json-over-https.ts", "../../.pnpm/@multiformats+dns@1.0.6/node_modules/@multiformats/dns/src/resolvers/default.browser.ts", "../../.pnpm/@multiformats+dns@1.0.6/node_modules/@multiformats/dns/src/utils/cache.ts", "../../.pnpm/@multiformats+dns@1.0.6/node_modules/@multiformats/dns/src/dns.ts", "../../.pnpm/@multiformats+dns@1.0.6/node_modules/@multiformats/dns/src/index.ts", "../../.pnpm/@multiformats+multiaddr@12.4.0/node_modules/@multiformats/multiaddr/src/resolvers/dnsaddr.ts", "../../.pnpm/merge-options@3.0.4/node_modules/merge-options/index.mjs", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/config.ts", "../../.pnpm/ms@3.0.0-canary.1/node_modules/ms/dist/index.mjs", "../../.pnpm/weald@1.0.4/node_modules/weald/src/common.ts", "../../.pnpm/weald@1.0.4/node_modules/weald/src/browser.ts", "../../.pnpm/weald@1.0.4/node_modules/weald/src/index.ts", "../../.pnpm/@libp2p+logger@5.1.13/node_modules/@libp2p/logger/src/index.ts", "../../.pnpm/@libp2p+peer-collections@6.0.25/node_modules/@libp2p/peer-collections/src/util.ts", "../../.pnpm/@libp2p+peer-collections@6.0.25/node_modules/@libp2p/peer-collections/src/map.ts", "../../.pnpm/@libp2p+peer-collections@6.0.25/node_modules/@libp2p/peer-collections/src/set.ts", "../../.pnpm/@sindresorhus+fnv1a@3.1.0/node_modules/@sindresorhus/fnv1a/index.js", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/filters/hashes.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/filters/bloom-filter.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/filters/fingerprint.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/filters/utils.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/filters/bucket.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/filters/cuckoo-filter.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/filters/scalable-cuckoo-filter.ts", "../../.pnpm/@libp2p+peer-record@8.0.25/node_modules/@libp2p/peer-record/src/envelope/envelope.ts", "../../.pnpm/@libp2p+peer-record@8.0.25/node_modules/@libp2p/peer-record/src/envelope/errors.ts", "../../.pnpm/@libp2p+peer-record@8.0.25/node_modules/@libp2p/peer-record/src/envelope/index.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/array-equals.ts", "../../.pnpm/@libp2p+peer-record@8.0.25/node_modules/@libp2p/peer-record/src/peer-record/consts.ts", "../../.pnpm/@libp2p+peer-record@8.0.25/node_modules/@libp2p/peer-record/src/peer-record/peer-record.ts", "../../.pnpm/@libp2p+peer-record@8.0.25/node_modules/@libp2p/peer-record/src/peer-record/index.ts", "../../.pnpm/it-all@3.0.7/node_modules/it-all/src/index.ts", "../../.pnpm/observable-webworkers@2.0.1/node_modules/observable-webworkers/src/index.ts", "../../.pnpm/mortice@3.0.6/node_modules/mortice/src/constants.ts", "../../.pnpm/mortice@3.0.6/node_modules/mortice/src/utils.ts", "../../.pnpm/mortice@3.0.6/node_modules/mortice/src/browser.ts", "../../.pnpm/mortice@3.0.6/node_modules/mortice/src/index.ts", "../../.pnpm/@libp2p+peer-store@11.1.2/node_modules/@libp2p/peer-store/src/constants.ts", "../../.pnpm/@libp2p+peer-store@11.1.2/node_modules/@libp2p/peer-store/src/pb/peer.ts", "../../.pnpm/@libp2p+peer-store@11.1.2/node_modules/@libp2p/peer-store/src/utils/bytes-to-peer.ts", "../../.pnpm/@libp2p+peer-store@11.1.2/node_modules/@libp2p/peer-store/src/utils/peer-equals.ts", "../../.pnpm/@libp2p+peer-store@11.1.2/node_modules/@libp2p/peer-store/src/utils/peer-id-to-datastore-key.ts", "../../.pnpm/@libp2p+peer-store@11.1.2/node_modules/@libp2p/peer-store/src/utils/dedupe-addresses.ts", "../../.pnpm/@libp2p+peer-store@11.1.2/node_modules/@libp2p/peer-store/src/utils/to-peer-pb.ts", "../../.pnpm/@libp2p+peer-store@11.1.2/node_modules/@libp2p/peer-store/src/store.ts", "../../.pnpm/@libp2p+peer-store@11.1.2/node_modules/@libp2p/peer-store/src/index.ts", "../../.pnpm/interface-store@6.0.2/node_modules/interface-store/src/errors.ts", "../../.pnpm/it-filter@3.1.2/node_modules/it-filter/src/index.ts", "../../.pnpm/it-sort@3.0.7/node_modules/it-sort/src/index.ts", "../../.pnpm/it-take@3.0.7/node_modules/it-take/src/index.ts", "../../.pnpm/datastore-core@10.0.2/node_modules/datastore-core/src/base.ts", "../../.pnpm/datastore-core@10.0.2/node_modules/datastore-core/src/memory.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/debounce.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/private-ip.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/address-manager/dns-mappings.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/address-manager/ip-mappings.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/multiaddr/is-link-local.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/multiaddr/is-ip-based.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/multiaddr/is-private.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/address-manager/observed-addresses.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/multiaddr/is-network-address.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/address-manager/transport-addresses.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/address-manager/index.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/errors.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/components.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/config/connection-gater.browser.ts", "../../.pnpm/delay@6.0.0/node_modules/delay/index.js", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/errors.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/rate-limiter.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/get-peer.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/close.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/connection-manager/constants.defaults.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/connection-manager/constants.browser.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/connection-manager/utils.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/connection-manager/connection-pruner.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/queue/recipient.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/queue/job.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/queue/index.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/priority-queue.ts", "../../.pnpm/is-loopback-addr@2.0.2/node_modules/is-loopback-addr/src/index.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/multiaddr/is-loopback.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/connection-manager/address-sorter.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/connection-manager/dial-queue.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/peer-queue.ts", "../../.pnpm/p-retry@6.2.1/node_modules/p-retry/index.js", "../../.pnpm/is-network-error@1.1.0/node_modules/is-network-error/index.js", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/connection-manager/reconnect-queue.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/connection-manager/index.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/moving-average.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/adaptive-timeout.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/connection-monitor.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/content-routing.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/peer-routing.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/random-walk.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/registrar.ts", "../../.pnpm/@libp2p+utils@6.6.0/node_modules/@libp2p/utils/src/tracked-map.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/transport-manager.ts", "../../.pnpm/@libp2p+multistream-select@6.0.20/node_modules/@libp2p/multistream-select/src/constants.ts", "../../.pnpm/@libp2p+multistream-select@6.0.20/node_modules/@libp2p/multistream-select/src/multistream.ts", "../../.pnpm/@libp2p+multistream-select@6.0.20/node_modules/@libp2p/multistream-select/src/select.ts", "../../.pnpm/@libp2p+multistream-select@6.0.20/node_modules/@libp2p/multistream-select/src/handle.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/connection/index.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/upgrader.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/version.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/user-agent.browser.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/libp2p.ts", "../../.pnpm/libp2p@2.8.2/node_modules/libp2p/src/index.ts"],
  "sourcesContent": ["'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n", "module.exports = function (max) {\n\n  if (!max) throw Error('hashlru must have a max value, of type number, greater than 0')\n\n  var size = 0, cache = Object.create(null), _cache = Object.create(null)\n\n  function update (key, value) {\n    cache[key] = value\n    size ++\n    if(size >= max) {\n      size = 0\n      _cache = cache\n      cache = Object.create(null)\n    }\n  }\n\n  return {\n    has: function (key) {\n      return cache[key] !== undefined || _cache[key] !== undefined\n    },\n    remove: function (key) {\n      if(cache[key] !== undefined)\n        cache[key] = undefined\n      if(_cache[key] !== undefined)\n        _cache[key] = undefined\n    },\n    get: function (key) {\n      var v = cache[key]\n      if(v !== undefined) return v\n      if((v = _cache[key]) !== undefined) {\n        update(key, v)\n        return v\n      }\n    },\n    set: function (key, value) {\n      if(cache[key] !== undefined) cache[key] = value\n      else update(key, value)\n    },\n    clear: function () {\n      cache = Object.create(null)\n      _cache = Object.create(null)\n    }\n  }\n}\n\n\n\n\n\n\n\n", "'use strict';\n\nmodule.exports = value => {\n\tif (Object.prototype.toString.call(value) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn prototype === null || prototype === Object.prototype;\n};\n", "'use strict';\nconst isOptionObject = require('is-plain-obj');\n\nconst {hasOwnProperty} = Object.prototype;\nconst {propertyIsEnumerable} = Object;\nconst defineProperty = (object, name, value) => Object.defineProperty(object, name, {\n\tvalue,\n\twritable: true,\n\tenumerable: true,\n\tconfigurable: true\n});\n\nconst globalThis = this;\nconst defaultMergeOptions = {\n\tconcatArrays: false,\n\tignoreUndefined: false\n};\n\nconst getEnumerableOwnPropertyKeys = value => {\n\tconst keys = [];\n\n\tfor (const key in value) {\n\t\tif (hasOwnProperty.call(value, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\n\t/* istanbul ignore else  */\n\tif (Object.getOwnPropertySymbols) {\n\t\tconst symbols = Object.getOwnPropertySymbols(value);\n\n\t\tfor (const symbol of symbols) {\n\t\t\tif (propertyIsEnumerable.call(value, symbol)) {\n\t\t\t\tkeys.push(symbol);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn keys;\n};\n\nfunction clone(value) {\n\tif (Array.isArray(value)) {\n\t\treturn cloneArray(value);\n\t}\n\n\tif (isOptionObject(value)) {\n\t\treturn cloneOptionObject(value);\n\t}\n\n\treturn value;\n}\n\nfunction cloneArray(array) {\n\tconst result = array.slice(0, 0);\n\n\tgetEnumerableOwnPropertyKeys(array).forEach(key => {\n\t\tdefineProperty(result, key, clone(array[key]));\n\t});\n\n\treturn result;\n}\n\nfunction cloneOptionObject(object) {\n\tconst result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};\n\n\tgetEnumerableOwnPropertyKeys(object).forEach(key => {\n\t\tdefineProperty(result, key, clone(object[key]));\n\t});\n\n\treturn result;\n}\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {string[]} keys keys to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */\nconst mergeKeys = (merged, source, keys, config) => {\n\tkeys.forEach(key => {\n\t\tif (typeof source[key] === 'undefined' && config.ignoreUndefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Do not recurse into prototype chain of merged\n\t\tif (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {\n\t\t\tdefineProperty(merged, key, merge(merged[key], source[key], config));\n\t\t} else {\n\t\t\tdefineProperty(merged, key, clone(source[key]));\n\t\t}\n\t});\n\n\treturn merged;\n};\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n *\n * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)\n */\nconst concatArrays = (merged, source, config) => {\n\tlet result = merged.slice(0, 0);\n\tlet resultIndex = 0;\n\n\t[merged, source].forEach(array => {\n\t\tconst indices = [];\n\n\t\t// `result.concat(array)` with cloning\n\t\tfor (let k = 0; k < array.length; k++) {\n\t\t\tif (!hasOwnProperty.call(array, k)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tindices.push(String(k));\n\n\t\t\tif (array === merged) {\n\t\t\t\t// Already cloned\n\t\t\t\tdefineProperty(result, resultIndex++, array[k]);\n\t\t\t} else {\n\t\t\t\tdefineProperty(result, resultIndex++, clone(array[k]));\n\t\t\t}\n\t\t}\n\n\t\t// Merge non-index keys\n\t\tresult = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(key => !indices.includes(key)), config);\n\t});\n\n\treturn result;\n};\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */\nfunction merge(merged, source, config) {\n\tif (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {\n\t\treturn concatArrays(merged, source, config);\n\t}\n\n\tif (!isOptionObject(source) || !isOptionObject(merged)) {\n\t\treturn clone(source);\n\t}\n\n\treturn mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);\n}\n\nmodule.exports = function (...options) {\n\tconst config = merge(clone(defaultMergeOptions), (this !== globalThis && this) || {}, defaultMergeOptions);\n\tlet merged = {_: {}};\n\n\tfor (const option of options) {\n\t\tif (option === undefined) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!isOptionObject(option)) {\n\t\t\tthrow new TypeError('`' + option + '` is not an Option Object');\n\t\t}\n\n\t\tmerged = merge(merged, {_: option}, config);\n\t}\n\n\treturn merged._;\n};\n", "function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n  this._timer = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts.slice(0);\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n  if (this._timer) {\n    clearTimeout(this._timer);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.push(err);\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(0, this._errors.length - 1);\n      timeout = this._cachedTimeouts.slice(-1);\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      this._timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n", "var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && (options.forever || options.retries === Infinity),\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n", "module.exports = require('./lib/retry');", "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n", "// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nexport default function lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = Math.trunc(count / 2);\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\n", "import lowerBound from './lower-bound.js';\nexport default class PriorityQueue {\n    #queue = [];\n    enqueue(run, options) {\n        options = {\n            priority: 0,\n            ...options,\n        };\n        const element = {\n            priority: options.priority,\n            id: options.id,\n            run,\n        };\n        if (this.size === 0 || this.#queue[this.size - 1].priority >= options.priority) {\n            this.#queue.push(element);\n            return;\n        }\n        const index = lowerBound(this.#queue, element, (a, b) => b.priority - a.priority);\n        this.#queue.splice(index, 0, element);\n    }\n    setPriority(id, priority) {\n        const index = this.#queue.findIndex((element) => element.id === id);\n        if (index === -1) {\n            throw new ReferenceError(`No promise function with the id \"${id}\" exists in the queue.`);\n        }\n        const [item] = this.#queue.splice(index, 1);\n        this.enqueue(item.run, { priority, id });\n    }\n    dequeue() {\n        const item = this.#queue.shift();\n        return item?.run;\n    }\n    filter(options) {\n        return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return this.#queue.length;\n    }\n}\n", "import { EventEmitter } from 'eventemitter3';\nimport pTimeout, { TimeoutError } from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nPromise queue with concurrency control.\n*/\nexport default class PQueue extends EventEmitter {\n    #carryoverConcurrencyCount;\n    #isIntervalIgnored;\n    #intervalCount = 0;\n    #intervalCap;\n    #interval;\n    #intervalEnd = 0;\n    #intervalId;\n    #timeoutId;\n    #queue;\n    #queueClass;\n    #pending = 0;\n    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n    #concurrency;\n    #isPaused;\n    #throwOnTimeout;\n    // Use to assign a unique identifier to a promise function, if not explicitly specified\n    #idAssigner = 1n;\n    /**\n    Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.\n\n    Applies to each future operation.\n    */\n    timeout;\n    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`\n    constructor(options) {\n        super();\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverConcurrencyCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${options.intervalCap?.toString() ?? ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${options.interval?.toString() ?? ''}\\` (${typeof options.interval})`);\n        }\n        this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;\n        this.#intervalCap = options.intervalCap;\n        this.#interval = options.interval;\n        this.#queue = new options.queueClass();\n        this.#queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this.timeout = options.timeout;\n        this.#throwOnTimeout = options.throwOnTimeout === true;\n        this.#isPaused = options.autoStart === false;\n    }\n    get #doesIntervalAllowAnother() {\n        return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;\n    }\n    get #doesConcurrentAllowAnother() {\n        return this.#pending < this.#concurrency;\n    }\n    #next() {\n        this.#pending--;\n        this.#tryToStartAnother();\n        this.emit('next');\n    }\n    #onResumeInterval() {\n        this.#onInterval();\n        this.#initializeIntervalIfNeeded();\n        this.#timeoutId = undefined;\n    }\n    get #isIntervalPaused() {\n        const now = Date.now();\n        if (this.#intervalId === undefined) {\n            const delay = this.#intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this.#intervalCount = (this.#carryoverConcurrencyCount) ? this.#pending : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this.#timeoutId === undefined) {\n                    this.#timeoutId = setTimeout(() => {\n                        this.#onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    #tryToStartAnother() {\n        if (this.#queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this.#intervalId) {\n                clearInterval(this.#intervalId);\n            }\n            this.#intervalId = undefined;\n            this.emit('empty');\n            if (this.#pending === 0) {\n                this.emit('idle');\n            }\n            return false;\n        }\n        if (!this.#isPaused) {\n            const canInitializeInterval = !this.#isIntervalPaused;\n            if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {\n                const job = this.#queue.dequeue();\n                if (!job) {\n                    return false;\n                }\n                this.emit('active');\n                job();\n                if (canInitializeInterval) {\n                    this.#initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    #initializeIntervalIfNeeded() {\n        if (this.#isIntervalIgnored || this.#intervalId !== undefined) {\n            return;\n        }\n        this.#intervalId = setInterval(() => {\n            this.#onInterval();\n        }, this.#interval);\n        this.#intervalEnd = Date.now() + this.#interval;\n    }\n    #onInterval() {\n        if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {\n            clearInterval(this.#intervalId);\n            this.#intervalId = undefined;\n        }\n        this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;\n        this.#processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    #processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this.#tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this.#concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this.#concurrency = newConcurrency;\n        this.#processQueue();\n    }\n    async #throwOnAbort(signal) {\n        return new Promise((_resolve, reject) => {\n            signal.addEventListener('abort', () => {\n                reject(signal.reason);\n            }, { once: true });\n        });\n    }\n    /**\n    Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.\n\n    For example, this can be used to prioritize a promise function to run earlier.\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 1});\n\n    queue.add(async () => '🦄', {priority: 1});\n    queue.add(async () => '🦀', {priority: 0, id: '🦀'});\n    queue.add(async () => '🦄', {priority: 1});\n    queue.add(async () => '🦄', {priority: 1});\n\n    queue.setPriority('🦀', 2);\n    ```\n\n    In this case, the promise function with `id: '🦀'` runs second.\n\n    You can also deprioritize a promise function to delay its execution:\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 1});\n\n    queue.add(async () => '🦄', {priority: 1});\n    queue.add(async () => '🦀', {priority: 1, id: '🦀'});\n    queue.add(async () => '🦄');\n    queue.add(async () => '🦄', {priority: 0});\n\n    queue.setPriority('🦀', -1);\n    ```\n    Here, the promise function with `id: '🦀'` executes last.\n    */\n    setPriority(id, priority) {\n        this.#queue.setPriority(id, priority);\n    }\n    async add(function_, options = {}) {\n        // In case `id` is not defined.\n        options.id ??= (this.#idAssigner++).toString();\n        options = {\n            timeout: this.timeout,\n            throwOnTimeout: this.#throwOnTimeout,\n            ...options,\n        };\n        return new Promise((resolve, reject) => {\n            this.#queue.enqueue(async () => {\n                this.#pending++;\n                this.#intervalCount++;\n                try {\n                    options.signal?.throwIfAborted();\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });\n                    }\n                    if (options.signal) {\n                        operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    if (error instanceof TimeoutError && !options.throwOnTimeout) {\n                        resolve();\n                        return;\n                    }\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    this.#next();\n                }\n            }, options);\n            this.emit('add');\n            this.#tryToStartAnother();\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this.#isPaused) {\n            return this;\n        }\n        this.#isPaused = false;\n        this.#processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this.#isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this.#queue = new this.#queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (this.#queue.size < limit) {\n            return;\n        }\n        await this.#onEvent('next', () => this.#queue.size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this.#pending === 0 && this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('idle');\n    }\n    async #onEvent(event, filter) {\n        return new Promise(resolve => {\n            const listener = () => {\n                if (filter && !filter()) {\n                    return;\n                }\n                this.off(event, listener);\n                resolve();\n            };\n            this.on(event, listener);\n        });\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return this.#queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return this.#queue.filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return this.#pending;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this.#isPaused;\n    }\n}\n", "import { RecordType } from '../index.js'\n\nexport function getTypes (types?: RecordType | RecordType[]): RecordType[] {\n  const DEFAULT_TYPES = [\n    RecordType.A\n  ]\n\n  if (types == null) {\n    return DEFAULT_TYPES\n  }\n\n  if (Array.isArray(types)) {\n    if (types.length === 0) {\n      return DEFAULT_TYPES\n    }\n\n    return types\n  }\n\n  return [\n    types\n  ]\n}\n", "import { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { RecordType, type DNSResponse } from '../index.js'\n\n/**\n * This TTL will be used if the remote service does not return one\n */\nexport const DEFAULT_TTL = 60\n\nexport function toDNSResponse (obj: any): DNSResponse {\n  return {\n    Status: obj.Status ?? 0,\n    TC: obj.TC ?? obj.flag_tc ?? false,\n    RD: obj.RD ?? obj.flag_rd ?? false,\n    RA: obj.RA ?? obj.flag_ra ?? false,\n    AD: obj.AD ?? obj.flag_ad ?? false,\n    CD: obj.CD ?? obj.flag_cd ?? false,\n    Question: (obj.Question ?? obj.questions ?? []).map((question: any) => {\n      return {\n        name: question.name,\n        type: RecordType[question.type]\n      }\n    }),\n    Answer: (obj.Answer ?? obj.answers ?? []).map((answer: any) => {\n      return {\n        name: answer.name,\n        type: RecordType[answer.type],\n        TTL: (answer.TTL ?? answer.ttl ?? DEFAULT_TTL),\n        data: answer.data instanceof Uint8Array ? uint8ArrayToString(answer.data) : answer.data\n      }\n    })\n  }\n}\n", "/* eslint-env browser */\n\nimport PQueue from 'p-queue'\nimport { CustomProgressEvent } from 'progress-events'\nimport { RecordType, type DNSResponse } from '../index.js'\nimport { getTypes } from '../utils/get-types.js'\nimport { toDNSResponse } from '../utils/to-dns-response.js'\nimport type { DNSResolver } from './index.js'\n\n/**\n * Browsers limit concurrent connections per host (~6), we don't want to exhaust\n * the limit so this value controls how many DNS queries can be in flight at\n * once.\n */\nexport const DEFAULT_QUERY_CONCURRENCY = 4\n\nexport interface DNSJSONOverHTTPSOptions {\n  queryConcurrency?: number\n}\n\n/**\n * Uses the RFC 8427 'application/dns-json' content-type to resolve DNS queries.\n *\n * Supports and server that uses the same schema as Google's DNS over HTTPS\n * resolver.\n *\n * This resolver needs fewer dependencies than the regular DNS-over-HTTPS\n * resolver so can result in a smaller bundle size and consequently is preferred\n * for browser use.\n *\n * @see https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/make-api-requests/dns-json/\n * @see https://github.com/curl/curl/wiki/DNS-over-HTTPS#publicly-available-servers\n * @see https://dnsprivacy.org/public_resolvers/\n * @see https://datatracker.ietf.org/doc/html/rfc8427\n */\nexport function dnsJsonOverHttps (url: string, init: DNSJSONOverHTTPSOptions = {}): DNSResolver {\n  const httpQueue = new PQueue({\n    concurrency: init.queryConcurrency ?? DEFAULT_QUERY_CONCURRENCY\n  })\n\n  return async (fqdn, options = {}) => {\n    const searchParams = new URLSearchParams()\n    searchParams.set('name', fqdn)\n\n    getTypes(options.types).forEach(type => {\n      // We pass record type as a string to the server because cloudflare DNS bug. see https://github.com/ipfs/helia/issues/474\n      searchParams.append('type', RecordType[type])\n    })\n\n    options.onProgress?.(new CustomProgressEvent<string>('dns:query', { detail: fqdn }))\n\n    // query DNS-JSON over HTTPS server\n    const response = await httpQueue.add(async () => {\n      const res = await fetch(`${url}?${searchParams}`, {\n        headers: {\n          accept: 'application/dns-json'\n        },\n        signal: options?.signal\n      })\n\n      if (res.status !== 200) {\n        throw new Error(`Unexpected HTTP status: ${res.status} - ${res.statusText}`)\n      }\n\n      const response = toDNSResponse(await res.json())\n\n      options.onProgress?.(new CustomProgressEvent<DNSResponse>('dns:response', { detail: response }))\n\n      return response\n    }, {\n      signal: options.signal\n    })\n\n    if (response == null) {\n      throw new Error('No DNS response received')\n    }\n\n    return response\n  }\n}\n", "import { dnsJsonOverHttps } from './dns-json-over-https.js'\nimport type { DNSResolver } from './index.js'\n\nexport function defaultResolver (): DNSResolver[] {\n  return [\n    dnsJsonOverHttps('https://cloudflare-dns.com/dns-query'),\n    dnsJsonOverHttps('https://dns.google/resolve')\n  ]\n}\n", "import hashlru from 'hashlru'\nimport { RecordType } from '../index.js'\nimport { DEFAULT_TTL, toDNSResponse } from './to-dns-response.js'\nimport type { Answer, DNSResponse } from '../index.js'\n\ninterface CachedAnswer {\n  expires: number\n  value: Answer\n}\n\nexport interface AnswerCache {\n  get (fqdn: string, types: RecordType[]): DNSResponse | undefined\n  add (domain: string, answer: Answer): void\n  remove (domain: string, type: ResponseType): void\n  clear (): void\n}\n\n/**\n * Time Aware Least Recent Used Cache\n *\n * @see https://arxiv.org/pdf/1801.00390\n */\nclass CachedAnswers {\n  private readonly lru: ReturnType<typeof hashlru>\n\n  constructor (maxSize: number) {\n    this.lru = hashlru(maxSize)\n  }\n\n  get (fqdn: string, types: RecordType[]): DNSResponse | undefined {\n    let foundAllAnswers = true\n    const answers: Answer[] = []\n\n    for (const type of types) {\n      const cached = this.getAnswers(fqdn, type)\n\n      if (cached.length === 0) {\n        foundAllAnswers = false\n        break\n      }\n\n      answers.push(...cached)\n    }\n\n    if (foundAllAnswers) {\n      return toDNSResponse({ answers })\n    }\n  }\n\n  private getAnswers (domain: string, type: RecordType): Answer[] {\n    const key = `${domain.toLowerCase()}-${type}`\n    const answers: CachedAnswer[] = this.lru.get(key)\n\n    if (answers != null) {\n      const cachedAnswers = answers\n        .filter((entry) => {\n          return entry.expires > Date.now()\n        })\n        .map(({ expires, value }) => ({\n          ...value,\n          TTL: Math.round((expires - Date.now()) / 1000),\n          type: RecordType[value.type]\n        }))\n\n      if (cachedAnswers.length === 0) {\n        this.lru.remove(key)\n      }\n\n      // @ts-expect-error hashlru stringifies stored types which turns enums\n      // into strings, we convert back into enums above but tsc doesn't know\n      return cachedAnswers\n    }\n\n    return []\n  }\n\n  add (domain: string, answer: Answer): void {\n    const key = `${domain.toLowerCase()}-${answer.type}`\n\n    const answers: CachedAnswer[] = this.lru.get(key) ?? []\n    answers.push({\n      expires: Date.now() + ((answer.TTL ?? DEFAULT_TTL) * 1000),\n      value: answer\n    })\n\n    this.lru.set(key, answers)\n  }\n\n  remove (domain: string, type: ResponseType): void {\n    const key = `${domain.toLowerCase()}-${type}`\n\n    this.lru.remove(key)\n  }\n\n  clear (): void {\n    this.lru.clear()\n  }\n}\n\n/**\n * Avoid sending multiple queries for the same hostname by caching results\n */\nexport function cache (size: number): AnswerCache {\n  return new CachedAnswers(size)\n}\n", "import { CustomProgressEvent } from 'progress-events'\nimport { defaultResolver } from './resolvers/default.js'\nimport { cache } from './utils/cache.js'\nimport { getTypes } from './utils/get-types.js'\nimport type { DNS as DNSInterface, DNSInit, DNSResponse, QueryOptions } from './index.js'\nimport type { DNSResolver } from './resolvers/index.js'\nimport type { AnswerCache } from './utils/cache.js'\n\nconst DEFAULT_ANSWER_CACHE_SIZE = 1000\n\nexport class DNS implements DNSInterface {\n  private readonly resolvers: Record<string, DNSResolver[]>\n  private readonly cache: AnswerCache\n\n  constructor (init: DNSInit) {\n    this.resolvers = {}\n    this.cache = cache(init.cacheSize ?? DEFAULT_ANSWER_CACHE_SIZE)\n\n    Object.entries(init.resolvers ?? {}).forEach(([tld, resolver]) => {\n      if (!Array.isArray(resolver)) {\n        resolver = [resolver]\n      }\n\n      // convert `com` -> `com.`\n      if (!tld.endsWith('.')) {\n        tld = `${tld}.`\n      }\n\n      this.resolvers[tld] = resolver\n    })\n\n    // configure default resolver if none specified\n    if (this.resolvers['.'] == null) {\n      this.resolvers['.'] = defaultResolver()\n    }\n  }\n\n  /**\n   * Queries DNS resolvers for the passed record types for the passed domain.\n   *\n   * If cached records exist for all desired types they will be returned\n   * instead.\n   *\n   * Any new responses will be added to the cache for subsequent requests.\n   */\n  async query (domain: string, options: QueryOptions = {}): Promise<DNSResponse> {\n    const types = getTypes(options.types)\n    const cached = options.cached !== false ? this.cache.get(domain, types) : undefined\n\n    if (cached != null) {\n      options.onProgress?.(new CustomProgressEvent<string>('dns:cache', { detail: cached }))\n\n      return cached\n    }\n\n    const tld = `${domain.split('.').pop()}.`\n    const resolvers = (this.resolvers[tld] ?? this.resolvers['.']).sort(() => {\n      return (Math.random() > 0.5) ? -1 : 1\n    })\n\n    const errors: Error[] = []\n\n    for (const resolver of resolvers) {\n      // skip further resolutions if the user aborted the signal\n      if (options.signal?.aborted === true) {\n        break\n      }\n\n      try {\n        const result = await resolver(domain, {\n          ...options,\n          types\n        })\n\n        for (const answer of result.Answer) {\n          this.cache.add(domain, answer)\n        }\n\n        return result\n      } catch (err: any) {\n        errors.push(err)\n        options.onProgress?.(new CustomProgressEvent<Error>('dns:error', { detail: err }))\n      }\n    }\n\n    if (errors.length === 1) {\n      throw errors[0]\n    }\n\n    throw new AggregateError(errors, `DNS lookup of ${domain} ${types} failed`)\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Query DNS records using `node:dns`, DNS over HTTP and/or DNSJSON over HTTP.\n *\n * A list of publicly accessible servers can be found [here](https://github.com/curl/curl/wiki/DNS-over-HTTPS#publicly-available-servers).\n *\n * @example Using the default resolver\n *\n * ```TypeScript\n * import { dns } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // resolve A records with a 5s timeout\n * const result = await dns.query('google.com', {\n *   signal: AbortSignal.timeout(5000)\n * })\n * ```\n *\n * @example Using per-TLD resolvers\n *\n * ```TypeScript\n * import { dns } from '@multiformats/dns'\n * import { dnsJsonOverHttps } from '@multiformats/dns/resolvers'\n *\n * const resolver = dns({\n *   resolvers: {\n *     // will only be used to resolve `.com` addresses\n *     'com.': dnsJsonOverHttps('https://cloudflare-dns.com/dns-query'),\n *\n *     // this can also be an array, resolvers will be shuffled and tried in\n *     // series\n *     'net.': [\n *       dnsJsonOverHttps('https://dns.google/resolve'),\n *       dnsJsonOverHttps('https://dns.pub/dns-query')\n *     ],\n *\n *     // will only be used to resolve all other addresses\n *     '.': dnsJsonOverHttps('https://dnsforge.de/dns-query'),\n *   }\n * })\n * ```\n *\n * @example Query for specific record types\n *\n * ```TypeScript\n * import { dns, RecordType } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // resolve only TXT records\n * const result = await dns.query('google.com', {\n *   types: [\n *     RecordType.TXT\n *   ]\n * })\n * ```\n *\n * ## Caching\n *\n * Individual Aanswers are cached so. If you make a request, for which all\n * record types are cached, all values will be pulled from the cache.\n *\n * If any of the record types are not cached, a new request will be resolved as\n * if none of the records were cached, and the cache will be updated to include\n * the new results.\n *\n * @example Ignoring the cache\n *\n * ```TypeScript\n * import { dns, RecordType } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // do not used cached results, always resolve a new query\n * const result = await dns.query('google.com', {\n *   cached: false\n * })\n * ```\n */\n\nimport { DNS as DNSClass } from './dns.js'\nimport type { DNSResolver } from './resolvers/index.js'\nimport type { ProgressEvent, ProgressOptions } from 'progress-events'\n\n/**\n * A subset of DNS Record Types\n *\n * @see https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4.\n */\nexport enum RecordType {\n  A = 1,\n  CNAME = 5,\n  TXT = 16,\n  AAAA = 28\n}\n\nexport interface Question {\n  /**\n   * The record name requested.\n   */\n  name: string\n\n  /**\n   * The type of DNS record requested.\n   *\n   * @see https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4.\n   */\n  type: RecordType\n}\n\nexport interface Answer {\n  /**\n   * The record owner.\n   */\n  name: string\n\n  /**\n   * The type of DNS record.\n   *\n   * @see https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4\n   */\n  type: RecordType\n\n  /**\n   * The number of seconds the answer can be stored in cache before it is\n   * considered stale.\n   */\n  TTL: number\n\n  /**\n   * The value of the DNS record for the given name and type. The data will be\n   * in text for standardized record types and in hex for unknown types.\n   */\n  data: string\n}\n\nexport interface DNSResponse {\n  /**\n   * The Response Code of the DNS Query.\n   *\n   * @see https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-6\n   */\n  Status: number\n\n  /**\n   * If true, it means the truncated bit was set. This happens when the DNS\n   * answer is larger than a single UDP or TCP packet.\n   */\n  TC: boolean\n\n  /**\n   * If true, it means the Recursive Desired bit was set.\n   */\n  RD: boolean\n\n  /**\n   * If true, it means the Recursion Available bit was set.\n   */\n  RA: boolean\n\n  /**\n   * If true, it means that every record in the answer was verified with DNSSEC.\n   */\n  AD: boolean\n\n  /**\n   * If true, the client asked to disable DNSSEC validation.\n   */\n  CD: boolean\n\n  /**\n   * The records that were requested.\n   */\n  Question: Question[]\n\n  /**\n   * Values for the records that were requested.\n   */\n  Answer: Answer[]\n}\n\n/**\n * The default maximum amount of recursion allowed during a query\n */\nexport const MAX_RECURSIVE_DEPTH = 32\n\nexport interface QueryOptions extends ProgressOptions<ResolveDnsProgressEvents> {\n  signal?: AbortSignal\n\n  /**\n   * Do not use cached DNS entries\n   *\n   * @default false\n   */\n  cached?: boolean\n\n  /**\n   * The type or types of DNS records to resolve\n   *\n   * @default [RecordType.A, RecordType.AAAA]\n   */\n  types?: RecordType | RecordType[]\n}\n\nexport interface DNS {\n  query(fqdn: string, options?: QueryOptions): Promise<DNSResponse>\n}\n\nexport type ResolveDnsProgressEvents =\n  ProgressEvent<'dns:cache', string> |\n  ProgressEvent<'dns:query', string> |\n  ProgressEvent<'dns:response', DNSResponse> |\n  ProgressEvent<'dns:error', Error>\n\nexport type DNSResolvers = Record<string, DNSResolver | DNSResolver[]>\n\nexport interface DNSInit {\n  /**\n   * A set of resolvers used to answer DNS queries\n   *\n   * String keys control which resolvers are used for which TLDs.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * import { dns } from '@multiformats/dns'\n   * import { dnsOverHttps } from '@multiformats/dns'\n   *\n   * const resolver = dns({\n   *   resolvers: {\n   *     // only used for .com domains\n   *     'com.': dnsOverHttps('https://example-1.com'),\n   *\n   *     // only used for .net domains, can be an array\n   *     'net.': [\n   *       dnsOverHttps('https://example-2.com'),\n   *       dnsOverHttps('https://example-3.com'),\n   *     ],\n   *\n   *     // used for everything else (can be an array)\n   *     '.': dnsOverHttps('https://example-4.com')\n   *   }\n   * })\n   * ```\n   */\n  resolvers?: DNSResolvers\n\n  /**\n   * To avoid repeating DNS lookups, successful answers are cached according to\n   * their TTL. To avoid exhausting memory, this option controls how many\n   * answers to cache.\n   *\n   * @default 1000\n   */\n  cacheSize?: number\n}\n\nexport function dns (init: DNSInit = {}): DNS {\n  return new DNSClass(init)\n}\n", "import { dns, RecordType } from '@multiformats/dns'\nimport { multiaddr } from '../index.js'\nimport { getProtocol } from '../protocols-table.js'\nimport type { Resolver } from './index.js'\nimport type { AbortOptions, Multiaddr } from '../index.js'\nimport type { DNS } from '@multiformats/dns'\n\nconst MAX_RECURSIVE_DEPTH = 32\nconst { code: dnsaddrCode } = getProtocol('dnsaddr')\n\nclass RecursionLimitError extends Error {\n  constructor (message = 'Max recursive depth reached') {\n    super(message)\n    this.name = 'RecursionLimitError'\n  }\n}\n\nexport interface DNSADDROptions extends AbortOptions {\n  /**\n   * An optional DNS resolver\n   */\n  dns?: DNS\n\n  /**\n   * When resolving DNSADDR Multiaddrs that resolve to other DNSADDR Multiaddrs,\n   * limit how many times we will recursively resolve them.\n   *\n   * @default 32\n   */\n  maxRecursiveDepth?: number\n}\n\nexport const dnsaddrResolver: Resolver<DNSADDROptions> = async function dnsaddrResolver (ma: Multiaddr, options: DNSADDROptions = {}): Promise<string[]> {\n  const recursionLimit = options.maxRecursiveDepth ?? MAX_RECURSIVE_DEPTH\n\n  if (recursionLimit === 0) {\n    throw new RecursionLimitError('Max recursive depth reached')\n  }\n\n  const [, hostname] = ma.stringTuples().find(([proto]) => proto === dnsaddrCode) ?? []\n\n  const resolver = options?.dns ?? dns()\n  const result = await resolver.query(`_dnsaddr.${hostname}`, {\n    signal: options?.signal,\n    types: [\n      RecordType.TXT\n    ]\n  })\n\n  const peerId = ma.getPeerId()\n  const output: string[] = []\n\n  for (const answer of result.Answer) {\n    const addr = answer.data\n      .replace(/[\"']/g, '')\n      .trim()\n      .split('=')[1]\n\n    if (addr == null) {\n      continue\n    }\n\n    if (peerId != null && !addr.includes(peerId)) {\n      continue\n    }\n\n    const ma = multiaddr(addr)\n\n    if (addr.startsWith('/dnsaddr')) {\n      const resolved = await ma.resolve({\n        ...options,\n        maxRecursiveDepth: recursionLimit - 1\n      })\n\n      output.push(...resolved.map(ma => ma.toString()))\n    } else {\n      output.push(ma.toString())\n    }\n  }\n\n  return output\n}\n", "/**\n * Thin ESM wrapper for CJS named exports.\n *\n * Ref: https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1\n */\n\nimport mergeOptions from './index.js';\nexport default mergeOptions;\n", "import { FaultTolerance, InvalidParametersError } from '@libp2p/interface'\nimport { dnsaddrResolver } from '@multiformats/multiaddr/resolvers'\nimport mergeOptions from 'merge-options'\nimport type { Libp2pInit } from './index.js'\nimport type { ServiceMap } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst DefaultConfig: Libp2pInit = {\n  addresses: {\n    listen: [],\n    announce: [],\n    noAnnounce: [],\n    announceFilter: (multiaddrs: Multiaddr[]) => multiaddrs\n  },\n  connectionManager: {\n    resolvers: {\n      dnsaddr: dnsaddrResolver\n    }\n  },\n  transportManager: {\n    faultTolerance: FaultTolerance.FATAL_ALL\n  }\n}\n\nexport async function validateConfig <T extends ServiceMap = Record<string, unknown>> (opts: Libp2pInit<T>): Promise<Libp2pInit<T>> {\n  const resultingOptions: Libp2pInit<T> = mergeOptions(DefaultConfig, opts)\n\n  if (resultingOptions.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null) { // eslint-disable-line no-undef\n    throw new InvalidParametersError('Private network is enforced, but no protector was provided')\n  }\n\n  return resultingOptions\n}\n", "// Helpers.\nconst s = 1000;\nconst m = s * 60;\nconst h = m * 60;\nconst d = h * 24;\nconst w = d * 7;\nconst y = d * 365.25;\nfunction ms(value, options) {\n    try {\n        if (typeof value === 'string' && value.length > 0) {\n            return parse(value);\n        }\n        else if (typeof value === 'number' && isFinite(value)) {\n            return options?.long ? fmtLong(value) : fmtShort(value);\n        }\n        throw new Error('Value is not a string or number.');\n    }\n    catch (error) {\n        const message = isError(error)\n            ? `${error.message}. value=${JSON.stringify(value)}`\n            : 'An unknown error has occured.';\n        throw new Error(message);\n    }\n}\n/**\n * Parse the given `str` and return milliseconds.\n */\nfunction parse(str) {\n    str = String(str);\n    if (str.length > 100) {\n        throw new Error('Value exceeds the maximum length of 100 characters.');\n    }\n    const match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n    if (!match) {\n        return NaN;\n    }\n    const n = parseFloat(match[1]);\n    const type = (match[2] || 'ms').toLowerCase();\n    switch (type) {\n        case 'years':\n        case 'year':\n        case 'yrs':\n        case 'yr':\n        case 'y':\n            return n * y;\n        case 'weeks':\n        case 'week':\n        case 'w':\n            return n * w;\n        case 'days':\n        case 'day':\n        case 'd':\n            return n * d;\n        case 'hours':\n        case 'hour':\n        case 'hrs':\n        case 'hr':\n        case 'h':\n            return n * h;\n        case 'minutes':\n        case 'minute':\n        case 'mins':\n        case 'min':\n        case 'm':\n            return n * m;\n        case 'seconds':\n        case 'second':\n        case 'secs':\n        case 'sec':\n        case 's':\n            return n * s;\n        case 'milliseconds':\n        case 'millisecond':\n        case 'msecs':\n        case 'msec':\n        case 'ms':\n            return n;\n        default:\n            // This should never occur.\n            throw new Error(`The unit ${type} was matched, but no matching case exists.`);\n    }\n}\nexport default ms;\n/**\n * Short format for `ms`.\n */\nfunction fmtShort(ms) {\n    const msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n        return `${Math.round(ms / d)}d`;\n    }\n    if (msAbs >= h) {\n        return `${Math.round(ms / h)}h`;\n    }\n    if (msAbs >= m) {\n        return `${Math.round(ms / m)}m`;\n    }\n    if (msAbs >= s) {\n        return `${Math.round(ms / s)}s`;\n    }\n    return `${ms}ms`;\n}\n/**\n * Long format for `ms`.\n */\nfunction fmtLong(ms) {\n    const msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n        return plural(ms, msAbs, d, 'day');\n    }\n    if (msAbs >= h) {\n        return plural(ms, msAbs, h, 'hour');\n    }\n    if (msAbs >= m) {\n        return plural(ms, msAbs, m, 'minute');\n    }\n    if (msAbs >= s) {\n        return plural(ms, msAbs, s, 'second');\n    }\n    return `${ms} ms`;\n}\n/**\n * Pluralization helper.\n */\nfunction plural(ms, msAbs, n, name) {\n    const isPlural = msAbs >= n * 1.5;\n    return `${Math.round(ms / n)} ${name}${isPlural ? 's' : ''}`;\n}\n/**\n * A type guard for errors.\n */\nfunction isError(error) {\n    return typeof error === 'object' && error !== null && 'message' in error;\n}\n", "/* eslint-disable no-console */\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nimport humanize from 'ms'\nimport type { Debug, Debugger } from './index.js'\n\nexport default function setup (env: any): Debug {\n  createDebug.debug = createDebug\n  createDebug.default = createDebug\n  createDebug.coerce = coerce\n  createDebug.disable = disable\n  createDebug.enable = enable\n  createDebug.enabled = enabled\n  createDebug.humanize = humanize\n  createDebug.destroy = destroy\n\n  Object.keys(env).forEach(key => {\n    // @ts-expect-error cannot use string to index type\n    createDebug[key] = env[key]\n  })\n\n  /**\n   * The currently active debug mode names, and names to skip.\n   */\n\n  createDebug.names = [] as any[]\n  createDebug.skips = [] as any[]\n\n  /**\n   * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n   *\n   * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n   */\n  createDebug.formatters = {} satisfies Record<string, any>\n\n  /**\n   * Selects a color for a debug namespace\n   *\n   * @param {string} namespace - The namespace string for the debug instance to be colored\n   * @returns {number | string} An ANSI color code for the given namespace\n   */\n  function selectColor (namespace: string): number | string {\n    let hash = 0\n\n    for (let i = 0; i < namespace.length; i++) {\n      hash = ((hash << 5) - hash) + namespace.charCodeAt(i)\n      hash |= 0 // Convert to 32bit integer\n    }\n\n    // @ts-expect-error colors is not in the types\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length]\n  }\n  createDebug.selectColor = selectColor\n\n  /**\n   * Create a debugger with the given `namespace`.\n   *\n   * @param {string} namespace\n   * @returns {Function}\n   */\n  function createDebug (namespace: string): Debugger {\n    let prevTime: any\n    let enableOverride: any = null\n    let namespacesCache: any\n    let enabledCache: any\n\n    function debug (...args: any[]): void {\n      // Disabled?\n      // @ts-expect-error enabled is not in the types\n      if (!debug.enabled) {\n        return\n      }\n\n      const self: any = debug\n\n      // Set `diff` timestamp\n      const curr = Number(new Date())\n      const ms = curr - (prevTime || curr)\n      self.diff = ms\n      self.prev = prevTime\n      self.curr = curr\n      prevTime = curr\n\n      args[0] = createDebug.coerce(args[0])\n\n      if (typeof args[0] !== 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O')\n      }\n\n      // Apply any `formatters` transformations\n      let index = 0\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match: any, format: any): any => {\n        // If we encounter an escaped % then don't increase the array index\n        if (match === '%%') {\n          return '%'\n        }\n        index++\n        // @ts-expect-error formatters is not in the types\n        const formatter = createDebug.formatters[format]\n        if (typeof formatter === 'function') {\n          const val = args[index]\n          match = formatter.call(self, val)\n\n          // Now we need to remove `args[index]` since it's inlined in the `format`\n          args.splice(index, 1)\n          index--\n        }\n        return match\n      })\n\n      // Apply env-specific formatting (colors, etc.)\n      // @ts-expect-error formatArgs is not in the types\n      createDebug.formatArgs.call(self, args)\n\n      // @ts-expect-error log is not in the types\n      const logFn = self.log || createDebug.log\n      logFn.apply(self, args)\n    }\n\n    debug.namespace = namespace\n    // @ts-expect-error useColors is not in the types\n    debug.useColors = createDebug.useColors()\n    debug.color = createDebug.selectColor(namespace)\n    debug.extend = extend\n    debug.destroy = createDebug.destroy // XXX Temporary. Will be removed in the next major release.\n\n    Object.defineProperty(debug, 'enabled', {\n      enumerable: true,\n      configurable: false,\n      get: () => {\n        if (enableOverride !== null) {\n          return enableOverride\n        }\n        // @ts-expect-error namespaces is not in the types\n        if (namespacesCache !== createDebug.namespaces) {\n          // @ts-expect-error namespaces is not in the types\n          namespacesCache = createDebug.namespaces\n          enabledCache = createDebug.enabled(namespace)\n        }\n\n        return enabledCache\n      },\n      set: v => {\n        enableOverride = v\n      }\n    })\n\n    // Env-specific initialization logic for debug instances\n    // @ts-expect-error init is not in the types\n    if (typeof createDebug.init === 'function') {\n      // @ts-expect-error init is not in the types\n      createDebug.init(debug)\n    }\n\n    // @ts-expect-error some properties are added dynamically\n    return debug\n  }\n\n  function extend (this: any, namespace: string, delimiter: string): any {\n    const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace)\n    newDebug.log = this.log\n    return newDebug\n  }\n\n  /**\n   * Enables a debug mode by namespaces. This can include modes\n   * separated by a colon and wildcards.\n   *\n   * @param {string} namespaces\n   */\n  function enable (namespaces: string): void {\n    // @ts-expect-error save is not in the types\n    createDebug.save(namespaces)\n    // @ts-expect-error namespaces is not in the types\n    createDebug.namespaces = namespaces\n\n    createDebug.names = []\n    createDebug.skips = []\n\n    let i\n    const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/)\n    const len = split.length\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?')\n\n      if (namespaces[0] === '-') {\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'))\n      } else {\n        createDebug.names.push(new RegExp('^' + namespaces + '$'))\n      }\n    }\n  }\n\n  /**\n   * Disable debug output.\n   *\n   * @returns {string} namespaces\n   */\n  function disable (): string {\n    const namespaces = [\n      ...createDebug.names.map(toNamespace),\n      ...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n    ].join(',')\n    createDebug.enable('')\n    return namespaces\n  }\n\n  /**\n   * Returns true if the given mode name is enabled, false otherwise.\n   *\n   * @param {string} name\n   * @returns {boolean}\n   */\n  function enabled (name: string): boolean {\n    if (name[name.length - 1] === '*') {\n      return true\n    }\n\n    let i\n    let len\n\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\n      if (createDebug.skips[i].test(name)) {\n        return false\n      }\n    }\n\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\n      if (createDebug.names[i].test(name)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Convert regexp to namespace\n   */\n  function toNamespace (regexp: RegExp): string {\n    return regexp.toString()\n      .substring(2, regexp.toString().length - 2)\n      .replace(/\\.\\*\\?$/, '*')\n  }\n\n  /**\n   * Coerce `val`.\n   */\n  function coerce (val: any): any {\n    if (val instanceof Error) {\n      return val.stack ?? val.message\n    }\n    return val\n  }\n\n  /**\n   * XXX DO NOT USE. This is a temporary stub function.\n   * XXX It WILL be removed in the next major release.\n   */\n  function destroy (): void {\n    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.')\n  }\n\n  // @ts-expect-error setupFormatters is not in the types\n  createDebug.setupFormatters(createDebug.formatters)\n\n  // @ts-expect-error load is not in the types\n  createDebug.enable(createDebug.load())\n\n  // @ts-expect-error some properties are added dynamically\n  return createDebug\n}\n", "/* eslint-disable no-console */\n/* eslint-disable @typescript-eslint/restrict-plus-operands */\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\nimport humanize from 'ms'\nimport setup from './common.js'\n\nconst storage = localstorage()\n\n/**\n * Colors.\n */\nconst colors = [\n  '#0000CC',\n  '#0000FF',\n  '#0033CC',\n  '#0033FF',\n  '#0066CC',\n  '#0066FF',\n  '#0099CC',\n  '#0099FF',\n  '#00CC00',\n  '#00CC33',\n  '#00CC66',\n  '#00CC99',\n  '#00CCCC',\n  '#00CCFF',\n  '#3300CC',\n  '#3300FF',\n  '#3333CC',\n  '#3333FF',\n  '#3366CC',\n  '#3366FF',\n  '#3399CC',\n  '#3399FF',\n  '#33CC00',\n  '#33CC33',\n  '#33CC66',\n  '#33CC99',\n  '#33CCCC',\n  '#33CCFF',\n  '#6600CC',\n  '#6600FF',\n  '#6633CC',\n  '#6633FF',\n  '#66CC00',\n  '#66CC33',\n  '#9900CC',\n  '#9900FF',\n  '#9933CC',\n  '#9933FF',\n  '#99CC00',\n  '#99CC33',\n  '#CC0000',\n  '#CC0033',\n  '#CC0066',\n  '#CC0099',\n  '#CC00CC',\n  '#CC00FF',\n  '#CC3300',\n  '#CC3333',\n  '#CC3366',\n  '#CC3399',\n  '#CC33CC',\n  '#CC33FF',\n  '#CC6600',\n  '#CC6633',\n  '#CC9900',\n  '#CC9933',\n  '#CCCC00',\n  '#CCCC33',\n  '#FF0000',\n  '#FF0033',\n  '#FF0066',\n  '#FF0099',\n  '#FF00CC',\n  '#FF00FF',\n  '#FF3300',\n  '#FF3333',\n  '#FF3366',\n  '#FF3399',\n  '#FF33CC',\n  '#FF33FF',\n  '#FF6600',\n  '#FF6633',\n  '#FF9900',\n  '#FF9933',\n  '#FFCC00',\n  '#FFCC33'\n]\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors (): boolean {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  // @ts-expect-error window.process.type and window.process.__nwjs are not in the types\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n    return true\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && (navigator.userAgent?.toLowerCase().match(/(edge|trident)\\/(\\d+)/) != null)) {\n    return false\n  }\n\n  // Is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  // @ts-expect-error document.documentElement.style.WebkitAppearance is not in the types\n  return (typeof document !== 'undefined' && document.documentElement?.style?.WebkitAppearance) ||\n    // Is firebug? http://stackoverflow.com/a/398120/376773\n    // @ts-expect-error window.console.firebug and window.console.exception are not in the types\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // Is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && (navigator.userAgent?.toLowerCase().match(/firefox\\/(\\d+)/) != null) && parseInt(RegExp.$1, 10) >= 31) ||\n    // Double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent?.toLowerCase().match(/applewebkit\\/(\\d+)/))\n}\n\n/**\n * Colorize log arguments if enabled.\n */\nfunction formatArgs (this: any, args: any[]): void {\n  args[0] = (this.useColors ? '%c' : '') +\n    this.namespace +\n    (this.useColors ? ' %c' : ' ') +\n    args[0] +\n    (this.useColors ? '%c ' : ' ') +\n    '+' + humanize(this.diff)\n\n  if (!this.useColors) {\n    return\n  }\n\n  const c = 'color: ' + this.color\n  args.splice(1, 0, c, 'color: inherit')\n\n  // The final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  let index = 0\n  let lastC = 0\n  args[0].replace(/%[a-zA-Z%]/g, (match: string) => {\n    if (match === '%%') {\n      return\n    }\n    index++\n    if (match === '%c') {\n      // We only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index\n    }\n  })\n\n  args.splice(lastC, 0, c)\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n */\nconst log = console.debug ?? console.log ?? (() => { })\n\n/**\n * Save `namespaces`.\n *\n * @param {string} namespaces\n */\nfunction save (namespaces: string): void {\n  try {\n    if (namespaces) {\n      storage?.setItem('debug', namespaces)\n    } else {\n      storage?.removeItem('debug')\n    }\n  } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @returns {string} returns the previously persisted debug modes\n */\nfunction load (): string | null | undefined {\n  let r\n  try {\n    r = storage?.getItem('debug')\n  } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof globalThis.process !== 'undefined' && 'env' in globalThis.process) {\n    r = globalThis.process.env.DEBUG\n  }\n\n  return r\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n */\nfunction localstorage (): Storage | undefined {\n  try {\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n    // The Browser also has localStorage in the global context.\n    return localStorage\n  } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\nfunction setupFormatters (formatters: any): void {\n  /**\n   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n   */\n  formatters.j = function (v: any) {\n    try {\n      return JSON.stringify(v)\n    } catch (error: any) {\n      return '[UnexpectedJSONParseError]: ' + error.message\n    }\n  }\n}\n\nexport default setup({ formatArgs, save, load, useColors, setupFormatters, colors, storage, log })\n", "/**\n * @packageDocumentation\n *\n * This module is a fork of the [debug](https://www.npmjs.com/package/debug) module. It has been converted to TypeScript and the output is ESM.\n *\n * It is API compatible with no extra features or bug fixes, it should only be used if you want a 100% ESM application.\n *\n * ESM should be arriving in `debug@5.x.x` so this module can be retired after that.\n *\n * Please see [debug](https://www.npmjs.com/package/debug) for API details.\n */\n\n/**\n * Module dependencies.\n */\nimport weald from './node.js'\nimport type ms from 'ms'\n\nexport interface Debug {\n  (namespace: string): Debugger\n  coerce(val: any): any\n  disable(...args: string[]): string\n  enable(namespaces: string | boolean): void\n  enabled(namespaces: string): boolean\n  formatArgs(this: Debugger, args: any[]): void\n  log(...args: any[]): any\n  selectColor(namespace: string): string | number\n  humanize: typeof ms\n\n  names: RegExp[]\n  skips: RegExp[]\n\n  formatters: Formatters\n\n  inspectOpts?: {\n    hideDate?: boolean | number | null\n    colors?: boolean | number | null\n    depth?: boolean | number | null\n    showHidden?: boolean | number | null\n  }\n}\n\nexport type Formatters = Record<string, (v: any) => string>\n\nexport interface Debugger {\n  (formatter: any, ...args: any[]): void\n\n  color: string\n  diff: number\n  enabled: boolean\n  log(...args: any[]): any\n  namespace: string\n  destroy(): boolean\n  extend(namespace: string, delimiter?: string): Debugger\n}\n\nexport default weald\n", "/**\n * @packageDocumentation\n *\n * A logger for libp2p based on [weald](https://www.npmjs.com/package/weald), a TypeScript port of the venerable [debug](https://www.npmjs.com/package/debug) module.\n *\n * @example\n *\n * ```TypeScript\n * import { logger } from '@libp2p/logger'\n *\n * const log = logger('libp2p:my:component:name')\n *\n * try {\n *   // an operation\n *   log('something happened: %s', 'it was ok')\n * } catch (err) {\n *   log.error('something bad happened: %o', err)\n * }\n *\n * log('with this peer: %p', {})\n * log('and this base58btc: %b', Uint8Array.from([0, 1, 2, 3]))\n * log('and this base32: %t', Uint8Array.from([4, 5, 6, 7]))\n * ```\n *\n * ```console\n * $ DEBUG=libp2p:* node index.js\n * something happened: it was ok\n * something bad happened: <stack trace>\n * with this peer: 12D3Foo\n * with this base58btc: Qmfoo\n * with this base32: bafyfoo\n * ```\n */\n\nimport { base32 } from 'multiformats/bases/base32'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { base64 } from 'multiformats/bases/base64'\nimport debug from 'weald'\nimport { truncatePeerId } from './utils.js'\nimport type { PeerId } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Key } from 'interface-datastore'\nimport type { CID } from 'multiformats/cid'\n\n// Add a formatter for converting to a base58 string\ndebug.formatters.b = (v?: Uint8Array): string => {\n  return v == null ? 'undefined' : base58btc.baseEncode(v)\n}\n\n// Add a formatter for converting to a base32 string\ndebug.formatters.t = (v?: Uint8Array): string => {\n  return v == null ? 'undefined' : base32.baseEncode(v)\n}\n\n// Add a formatter for converting to a base64 string\ndebug.formatters.m = (v?: Uint8Array): string => {\n  return v == null ? 'undefined' : base64.baseEncode(v)\n}\n\n// Add a formatter for stringifying peer ids\ndebug.formatters.p = (v?: PeerId): string => {\n  return v == null ? 'undefined' : v.toString()\n}\n\n// Add a formatter for stringifying CIDs\ndebug.formatters.c = (v?: CID): string => {\n  return v == null ? 'undefined' : v.toString()\n}\n\n// Add a formatter for stringifying Datastore keys\ndebug.formatters.k = (v: Key): string => {\n  return v == null ? 'undefined' : v.toString()\n}\n\n// Add a formatter for stringifying Multiaddrs\ndebug.formatters.a = (v?: Multiaddr): string => {\n  return v == null ? 'undefined' : v.toString()\n}\n\n// Add a formatter for stringifying Errors\ndebug.formatters.e = (v?: Error): string => {\n  return v == null ? 'undefined' : notEmpty(v.stack) ?? notEmpty(v.message) ?? v.toString()\n}\n\nexport interface Logger {\n  (formatter: any, ...args: any[]): void\n  error(formatter: any, ...args: any[]): void\n  trace(formatter: any, ...args: any[]): void\n  enabled: boolean\n}\n\nexport interface ComponentLogger {\n  forComponent(name: string): Logger\n}\n\nfunction createDisabledLogger (namespace: string): debug.Debugger {\n  const logger = (): void => {}\n  logger.enabled = false\n  logger.color = ''\n  logger.diff = 0\n  logger.log = (): void => {}\n  logger.namespace = namespace\n  logger.destroy = () => true\n  logger.extend = () => logger\n\n  return logger\n}\n\nexport interface PeerLoggerOptions {\n  prefixLength: number\n  suffixLength: number\n}\n\n/**\n * Create a component logger that will prefix any log messages with a truncated\n * peer id.\n *\n * @example\n *\n * ```TypeScript\n * import { peerLogger } from '@libp2p/logger'\n * import { peerIdFromString } from '@libp2p/peer-id'\n *\n * const peerId = peerIdFromString('12D3FooBar')\n * const logger = peerLogger(peerId)\n *\n * const log = logger.forComponent('my-component')\n * log.info('hello world')\n * // logs \"12…oBar:my-component hello world\"\n * ```\n */\nexport function peerLogger (peerId: PeerId, options: Partial<PeerLoggerOptions> = {}): ComponentLogger {\n  return prefixLogger(truncatePeerId(peerId, options))\n}\n\n/**\n * Create a component logger that will prefix any log messages with the passed\n * string.\n *\n * @example\n *\n * ```TypeScript\n * import { prefixLogger } from '@libp2p/logger'\n *\n * const logger = prefixLogger('my-node')\n *\n * const log = logger.forComponent('my-component')\n * log.info('hello world')\n * // logs \"my-node:my-component hello world\"\n * ```\n */\nexport function prefixLogger (prefix: string): ComponentLogger {\n  return {\n    forComponent (name: string) {\n      return logger(`${prefix}:${name}`)\n    }\n  }\n}\n\n/**\n * Create a component logger\n *\n * @example\n *\n * ```TypeScript\n * import { defaultLogger } from '@libp2p/logger'\n * import { peerIdFromString } from '@libp2p/peer-id'\n *\n * const logger = defaultLogger()\n *\n * const log = logger.forComponent('my-component')\n * log.info('hello world')\n * // logs \"my-component hello world\"\n * ```\n */\nexport function defaultLogger (): ComponentLogger {\n  return {\n    forComponent (name: string) {\n      return logger(name)\n    }\n  }\n}\n\n/**\n * Creates a logger for the passed component name.\n *\n * @example\n *\n * ```TypeScript\n * import { logger } from '@libp2p/logger'\n *\n * const log = logger('my-component')\n * log.info('hello world')\n * // logs \"my-component hello world\"\n * ```\n */\nexport function logger (name: string): Logger {\n  // trace logging is a no-op by default\n  let trace: debug.Debugger = createDisabledLogger(`${name}:trace`)\n\n  // look at all the debug names and see if trace logging has explicitly been enabled\n  if (debug.enabled(`${name}:trace`) && debug.names.map((r: any) => r.toString()).find((n: string) => n.includes(':trace')) != null) {\n    trace = debug(`${name}:trace`)\n  }\n\n  return Object.assign(debug(name), {\n    error: debug(`${name}:error`),\n    trace\n  })\n}\n\nexport function disable (): void {\n  debug.disable()\n}\n\nexport function enable (namespaces: string): void {\n  debug.enable(namespaces)\n}\n\nexport function enabled (namespaces: string): boolean {\n  return debug.enabled(namespaces)\n}\n\nfunction notEmpty (str?: string): string | undefined {\n  if (str == null) {\n    return\n  }\n\n  str = str.trim()\n\n  if (str.length === 0) {\n    return\n  }\n\n  return str\n}\n", "import { peerIdFromMultihash } from '@libp2p/peer-id'\nimport { base58btc } from 'multiformats/bases/base58'\nimport * as Digest from 'multiformats/hashes/digest'\nimport type { PeerId } from '@libp2p/interface'\n\n/**\n * Calls the passed map function on every entry of the passed iterable iterator\n */\nexport function mapIterable <T, R> (iter: IterableIterator<T>, map: (val: T) => R): IterableIterator<R> {\n  const iterator: IterableIterator<R> = {\n    [Symbol.iterator]: () => {\n      return iterator\n    },\n    next: () => {\n      const next = iter.next()\n      const val = next.value\n\n      if (next.done === true || val == null) {\n        const result: IteratorReturnResult<any> = {\n          done: true,\n          value: undefined\n        }\n\n        return result\n      }\n\n      return {\n        done: false,\n        value: map(val)\n      }\n    }\n  }\n\n  return iterator\n}\n\nexport function peerIdFromString (str: string): PeerId {\n  const multihash = Digest.decode(base58btc.decode(`z${str}`))\n  return peerIdFromMultihash(multihash)\n}\n", "import { mapIterable } from './util.js'\nimport type { PeerId } from '@libp2p/interface'\n\n/**\n * We can't use PeerIds as map keys because map keys are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```TypeScript\n * import { peerMap } from '@libp2p/peer-collections'\n *\n * const map = peerMap<string>()\n * map.set(peerId, 'value')\n * ```\n */\nexport class PeerMap <T> {\n  private readonly map: Map<string, { key: PeerId, value: T }>\n\n  constructor (map?: PeerMap<T>) {\n    this.map = new Map()\n\n    if (map != null) {\n      for (const [key, value] of map.entries()) {\n        this.map.set(key.toString(), { key, value })\n      }\n    }\n  }\n\n  [Symbol.iterator] (): IterableIterator<[PeerId, T]> {\n    return this.entries()\n  }\n\n  clear (): void {\n    this.map.clear()\n  }\n\n  delete (peer: PeerId): boolean {\n    return this.map.delete(peer.toString())\n  }\n\n  entries (): IterableIterator<[PeerId, T]> {\n    return mapIterable<[string, { key: PeerId, value: T }], [PeerId, T]>(\n      this.map.entries(),\n      (val) => {\n        return [val[1].key, val[1].value]\n      }\n    )\n  }\n\n  forEach (fn: (value: T, key: PeerId, map: PeerMap<T>) => void): void {\n    this.map.forEach((value, key) => {\n      fn(value.value, value.key, this)\n    })\n  }\n\n  get (peer: PeerId): T | undefined {\n    return this.map.get(peer.toString())?.value\n  }\n\n  has (peer: PeerId): boolean {\n    return this.map.has(peer.toString())\n  }\n\n  set (peer: PeerId, value: T): void {\n    this.map.set(peer.toString(), { key: peer, value })\n  }\n\n  keys (): IterableIterator<PeerId> {\n    return mapIterable<{ key: PeerId, value: T }, PeerId>(\n      this.map.values(),\n      (val) => {\n        return val.key\n      }\n    )\n  }\n\n  values (): IterableIterator<T> {\n    return mapIterable(this.map.values(), (val) => val.value)\n  }\n\n  get size (): number {\n    return this.map.size\n  }\n}\n\nexport function peerMap <T> (): PeerMap<T> {\n  return new PeerMap<T>()\n}\n", "import { mapIterable, peerIdFromString } from './util.js'\nimport type { PeerId } from '@libp2p/interface'\n\n/**\n * We can't use PeerIds as set entries because set entries are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```TypeScript\n * import { peerSet } from '@libp2p/peer-collections'\n *\n * const set = peerSet()\n * set.add(peerId)\n * ```\n */\nexport class PeerSet {\n  private readonly set: Set<string>\n\n  constructor (set?: PeerSet | Iterable<PeerId>) {\n    this.set = new Set()\n\n    if (set != null) {\n      for (const key of set) {\n        this.set.add(key.toString())\n      }\n    }\n  }\n\n  get size (): number {\n    return this.set.size\n  }\n\n  [Symbol.iterator] (): IterableIterator<PeerId> {\n    return this.values()\n  }\n\n  add (peer: PeerId): void {\n    this.set.add(peer.toString())\n  }\n\n  clear (): void {\n    this.set.clear()\n  }\n\n  delete (peer: PeerId): void {\n    this.set.delete(peer.toString())\n  }\n\n  entries (): IterableIterator<[PeerId, PeerId]> {\n    return mapIterable<[string, string], [PeerId, PeerId]>(\n      this.set.entries(),\n      (val) => {\n        const peerId = peerIdFromString(val[0])\n\n        return [peerId, peerId]\n      }\n    )\n  }\n\n  forEach (predicate: (peerId: PeerId, index: PeerId, set: PeerSet) => void): void {\n    this.set.forEach((str) => {\n      const peerId = peerIdFromString(str)\n\n      predicate(peerId, peerId, this)\n    })\n  }\n\n  has (peer: PeerId): boolean {\n    return this.set.has(peer.toString())\n  }\n\n  values (): IterableIterator<PeerId> {\n    return mapIterable<string, PeerId>(\n      this.set.values(),\n      (val) => {\n        return peerIdFromString(val)\n      }\n    )\n  }\n\n  intersection (other: PeerSet): PeerSet {\n    const output = new PeerSet()\n\n    for (const peerId of other) {\n      if (this.has(peerId)) {\n        output.add(peerId)\n      }\n    }\n\n    return output\n  }\n\n  difference (other: PeerSet): PeerSet {\n    const output = new PeerSet()\n\n    for (const peerId of this) {\n      if (!other.has(peerId)) {\n        output.add(peerId)\n      }\n    }\n\n    return output\n  }\n\n  union (other: PeerSet): PeerSet {\n    const output = new PeerSet()\n\n    for (const peerId of other) {\n      output.add(peerId)\n    }\n\n    for (const peerId of this) {\n      output.add(peerId)\n    }\n\n    return output\n  }\n}\n\nexport function peerSet (): PeerSet {\n  return new PeerSet()\n}\n", "// FNV_PRIMES and FNV_OFFSETS from\n// http://www.isthe.com/chongo/tech/comp/fnv/index.html#FNV-param\n\nconst FNV_PRIMES = {\n\t32: 16_777_619n,\n\t64: 1_099_511_628_211n,\n\t128: 309_485_009_821_345_068_724_781_371n,\n\t256: 374_144_419_156_711_147_060_143_317_175_368_453_031_918_731_002_211n,\n\t512: 35_835_915_874_844_867_368_919_076_489_095_108_449_946_327_955_754_392_558_399_825_615_420_669_938_882_575_126_094_039_892_345_713_852_759n,\n\t1024: 5_016_456_510_113_118_655_434_598_811_035_278_955_030_765_345_404_790_744_303_017_523_831_112_055_108_147_451_509_157_692_220_295_382_716_162_651_878_526_895_249_385_292_291_816_524_375_083_746_691_371_804_094_271_873_160_484_737_966_720_260_389_217_684_476_157_468_082_573n,\n};\n\nconst FNV_OFFSETS = {\n\t32: 2_166_136_261n,\n\t64: 14_695_981_039_346_656_037n,\n\t128: 144_066_263_297_769_815_596_495_629_667_062_367_629n,\n\t256: 100_029_257_958_052_580_907_070_968_620_625_704_837_092_796_014_241_193_945_225_284_501_741_471_925_557n,\n\t512: 9_659_303_129_496_669_498_009_435_400_716_310_466_090_418_745_672_637_896_108_374_329_434_462_657_994_582_932_197_716_438_449_813_051_892_206_539_805_784_495_328_239_340_083_876_191_928_701_583_869_517_785n,\n\t1024: 14_197_795_064_947_621_068_722_070_641_403_218_320_880_622_795_441_933_960_878_474_914_617_582_723_252_296_732_303_717_722_150_864_096_521_202_355_549_365_628_174_669_108_571_814_760_471_015_076_148_029_755_969_804_077_320_157_692_458_563_003_215_304_957_150_157_403_644_460_363_550_505_412_711_285_966_361_610_267_868_082_893_823_963_790_439_336_411_086_884_584_107_735_010_676_915n,\n};\n\nconst cachedEncoder = new globalThis.TextEncoder();\n\nfunction fnv1aUint8Array(uint8Array, size) {\n\tconst fnvPrime = FNV_PRIMES[size];\n\tlet hash = FNV_OFFSETS[size];\n\n\t// eslint-disable-next-line unicorn/no-for-loop -- This is a performance-sensitive loop\n\tfor (let index = 0; index < uint8Array.length; index++) {\n\t\thash ^= BigInt(uint8Array[index]);\n\t\thash = BigInt.asUintN(size, hash * fnvPrime);\n\t}\n\n\treturn hash;\n}\n\nfunction fnv1aEncodeInto(string, size, utf8Buffer) {\n\tif (utf8Buffer.length === 0) {\n\t\tthrow new Error('The `utf8Buffer` option must have a length greater than zero');\n\t}\n\n\tconst fnvPrime = FNV_PRIMES[size];\n\tlet hash = FNV_OFFSETS[size];\n\tlet remaining = string;\n\n\twhile (remaining.length > 0) {\n\t\tconst result = cachedEncoder.encodeInto(remaining, utf8Buffer);\n\t\tremaining = remaining.slice(result.read);\n\t\tfor (let index = 0; index < result.written; index++) {\n\t\t\thash ^= BigInt(utf8Buffer[index]);\n\t\t\thash = BigInt.asUintN(size, hash * fnvPrime);\n\t\t}\n\t}\n\n\treturn hash;\n}\n\nexport default function fnv1a(value, {size = 32, utf8Buffer} = {}) {\n\tif (!FNV_PRIMES[size]) {\n\t\tthrow new Error('The `size` option must be one of 32, 64, 128, 256, 512, or 1024');\n\t}\n\n\tif (typeof value === 'string') {\n\t\tif (utf8Buffer) {\n\t\t\treturn fnv1aEncodeInto(value, size, utf8Buffer);\n\t\t}\n\n\t\tvalue = cachedEncoder.encode(value);\n\t}\n\n\treturn fnv1aUint8Array(value, size);\n}\n", "import fnv1aHash from '@sindresorhus/fnv1a'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\n\nexport interface Hash {\n  hash(input: Uint8Array, seed: number): number\n  hashV(input: Uint8Array, seed: number): Uint8Array\n}\n\nexport const fnv1a: Hash = {\n  hash: (input) => {\n    return Number(fnv1aHash(input, {\n      size: 32\n    }))\n  },\n  hashV: (input, seed) => {\n    return numberToBuffer(fnv1a.hash(input, seed))\n  }\n}\n\nexport function numberToBuffer (num: bigint | number): Uint8Array {\n  let hex = num.toString(16)\n\n  if (hex.length % 2 === 1) {\n    hex = `0${hex}`\n  }\n\n  return uint8ArrayFromString(hex, 'base16')\n}\n", "// ported from xxbloom - https://github.com/ceejbot/xxbloom/blob/master/LICENSE\nimport { randomBytes } from '@libp2p/crypto'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { alloc } from 'uint8arrays/alloc'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { fnv1a } from './hashes.js'\nimport type { Filter } from './index.js'\n\nconst LN2_SQUARED = Math.LN2 * Math.LN2\n\nexport interface BloomFilterOptions {\n  seeds?: number[]\n  hashes?: number\n  bits?: number\n}\n\nexport class BloomFilter implements Filter {\n  public readonly seeds: number[]\n  public readonly bits: number\n  public buffer: Uint8Array\n\n  constructor (options: BloomFilterOptions = {}) {\n    if (options.seeds != null) {\n      this.seeds = options.seeds\n    } else {\n      this.seeds = generateSeeds(options.hashes ?? 8)\n    }\n\n    this.bits = options.bits ?? 1024\n    this.buffer = alloc(Math.ceil(this.bits / 8))\n  }\n\n  /**\n   * Add an item to the filter\n   */\n  add (item: Uint8Array | string): void {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    for (let i = 0; i < this.seeds.length; i++) {\n      const hash = fnv1a.hash(item, this.seeds[i])\n      const bit = hash % this.bits\n\n      this.setbit(bit)\n    }\n  }\n\n  /**\n   * Test if the filter has an item. If it returns false it definitely does not\n   * have the item. If it returns true, it probably has the item but there's\n   * an `errorRate` chance it doesn't.\n   */\n  has (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    for (let i = 0; i < this.seeds.length; i++) {\n      const hash = fnv1a.hash(item, this.seeds[i])\n      const bit = hash % this.bits\n\n      const isSet = this.getbit(bit)\n\n      if (!isSet) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Reset the filter\n   */\n  clear (): void {\n    this.buffer.fill(0)\n  }\n\n  setbit (bit: number): void {\n    const pos = Math.floor(bit / 8)\n    const shift = bit % 8\n\n    let bitField = this.buffer[pos]\n    bitField |= (0x1 << shift)\n    this.buffer[pos] = bitField\n  }\n\n  getbit (bit: number): boolean {\n    const pos = Math.floor(bit / 8)\n    const shift = bit % 8\n\n    const bitField = this.buffer[pos]\n    return (bitField & (0x1 << shift)) !== 0\n  }\n}\n\n/**\n * Create a `BloomFilter` with the smallest `bits` and `hashes` value for the\n * specified item count and error rate.\n */\nexport function createBloomFilter (itemCount: number, errorRate: number = 0.005): Filter {\n  const opts = optimize(itemCount, errorRate)\n  return new BloomFilter(opts)\n}\n\nfunction optimize (itemCount: number, errorRate: number = 0.005): { bits: number, hashes: number } {\n  const bits = Math.round(-1 * itemCount * Math.log(errorRate) / LN2_SQUARED)\n  const hashes = Math.round((bits / itemCount) * Math.LN2)\n\n  return { bits, hashes }\n}\n\nfunction generateSeeds (count: number): number[] {\n  let buf: Uint8ArrayList\n  let j: number\n  const seeds = []\n\n  for (let i = 0; i < count; i++) {\n    buf = new Uint8ArrayList(randomBytes(4))\n    seeds[i] = buf.getUint32(0, true)\n\n    // Make sure we don't end up with two identical seeds,\n    // which is unlikely but possible.\n    for (j = 0; j < i; j++) {\n      if (seeds[i] === seeds[j]) {\n        i--\n        break\n      }\n    }\n  }\n\n  return seeds\n}\n", "import { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport type { Hash } from './hashes'\n\nexport const MAX_FINGERPRINT_SIZE = 64\n\nexport class Fingerprint {\n  private readonly fp: Uint8Array\n  private readonly h: Hash\n  private readonly seed: number\n\n  constructor (buf: Uint8Array, hash: Hash, seed: number, fingerprintSize: number = 2) {\n    if (fingerprintSize > MAX_FINGERPRINT_SIZE) {\n      throw new TypeError('Invalid Fingerprint Size')\n    }\n\n    const fnv = hash.hashV(buf, seed)\n    const fp = uint8ArrayAlloc(fingerprintSize)\n\n    for (let i = 0; i < fp.length; i++) {\n      fp[i] = fnv[i]\n    }\n\n    if (fp.length === 0) {\n      fp[0] = 7\n    }\n\n    this.fp = fp\n    this.h = hash\n    this.seed = seed\n  }\n\n  hash (): number {\n    return this.h.hash(this.fp, this.seed)\n  }\n\n  equals (other?: any): boolean {\n    if (!(other?.fp instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.fp, other.fp)\n  }\n}\n", "export function getRandomInt (min: number, max: number): number {\n  return Math.floor(Math.random() * (max - min)) + min\n}\n", "import { Fingerprint } from './fingerprint.js'\nimport { getRandomInt } from './utils.js'\n\nexport class Bucket {\n  private readonly contents: Array<Fingerprint | null>\n\n  constructor (size: number) {\n    this.contents = new Array(size).fill(null)\n  }\n\n  has (fingerprint: Fingerprint): boolean {\n    if (!(fingerprint instanceof Fingerprint)) {\n      throw new TypeError('Invalid Fingerprint')\n    }\n\n    return this.contents.some((fp) => {\n      return fingerprint.equals(fp)\n    })\n  }\n\n  add (fingerprint: Fingerprint): boolean {\n    if (!(fingerprint instanceof Fingerprint)) {\n      throw new TypeError('Invalid Fingerprint')\n    }\n\n    for (let i = 0; i < this.contents.length; i++) {\n      if (this.contents[i] == null) {\n        this.contents[i] = fingerprint\n        return true\n      }\n    }\n\n    return true\n  }\n\n  swap (fingerprint: Fingerprint): Fingerprint | null {\n    if (!(fingerprint instanceof Fingerprint)) {\n      throw new TypeError('Invalid Fingerprint')\n    }\n\n    const i = getRandomInt(0, this.contents.length - 1)\n    const current = this.contents[i]\n    this.contents[i] = fingerprint\n\n    return current\n  }\n\n  remove (fingerprint: Fingerprint): boolean {\n    if (!(fingerprint instanceof Fingerprint)) {\n      throw new TypeError('Invalid Fingerprint')\n    }\n\n    const found = this.contents.findIndex((fp) => {\n      return fingerprint.equals(fp)\n    })\n\n    if (found > -1) {\n      this.contents[found] = null\n      return true\n    } else {\n      return false\n    }\n  }\n}\n", "import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { Bucket } from './bucket.js'\nimport { Fingerprint, MAX_FINGERPRINT_SIZE } from './fingerprint.js'\nimport { fnv1a, type Hash } from './hashes.js'\nimport { getRandomInt } from './utils.js'\nimport type { Filter } from './index.js'\n\nconst maxCuckooCount = 500\n\nexport interface CuckooFilterInit {\n  /**\n   * How many items the filter is expected to contain\n   */\n  filterSize: number\n\n  /**\n   * How many items to put in each bucket\n   */\n  bucketSize?: number\n\n  /**\n   * How many bytes the fingerprint is expected to be\n   */\n  fingerprintSize?: number\n\n  /**\n   * A non-cryptographic hash implementation\n   */\n  hash?: Hash\n\n  /**\n   * A number used to seed the hash\n   */\n  seed?: number\n}\n\nexport class CuckooFilter implements Filter {\n  private readonly bucketSize: number\n  private readonly filterSize: number\n  private readonly fingerprintSize: number\n  private readonly buckets: Bucket[]\n  public count: number\n  private readonly hash: Hash\n  private readonly seed: number\n\n  constructor (init: CuckooFilterInit) {\n    this.filterSize = init.filterSize\n    this.bucketSize = init.bucketSize ?? 4\n    this.fingerprintSize = init.fingerprintSize ?? 2\n    this.count = 0\n    this.buckets = []\n    this.hash = init.hash ?? fnv1a\n    this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10))\n  }\n\n  add (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize)\n    const j = this.hash.hash(item, this.seed) % this.filterSize\n    const k = (j ^ fingerprint.hash()) % this.filterSize\n\n    if (this.buckets[j] == null) {\n      this.buckets[j] = new Bucket(this.bucketSize)\n    }\n\n    if (this.buckets[k] == null) {\n      this.buckets[k] = new Bucket(this.bucketSize)\n    }\n\n    if (this.buckets[j].add(fingerprint) || this.buckets[k].add(fingerprint)) {\n      this.count++\n      return true\n    }\n\n    const rand = [j, k]\n    let i = rand[getRandomInt(0, rand.length - 1)]\n\n    if (this.buckets[i] == null) {\n      this.buckets[i] = new Bucket(this.bucketSize)\n    }\n\n    for (let n = 0; n < maxCuckooCount; n++) {\n      const swapped = this.buckets[i].swap(fingerprint)\n\n      if (swapped == null) {\n        continue\n      }\n\n      i = (i ^ swapped.hash()) % this.filterSize\n\n      if (this.buckets[i] == null) {\n        this.buckets[i] = new Bucket(this.bucketSize)\n      }\n\n      if (this.buckets[i].add(swapped)) {\n        this.count++\n\n        return true\n      } else {\n        continue\n      }\n    }\n\n    return false\n  }\n\n  has (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize)\n    const j = this.hash.hash(item, this.seed) % this.filterSize\n    const inJ = this.buckets[j]?.has(fingerprint) ?? false\n\n    if (inJ) {\n      return inJ\n    }\n\n    const k = (j ^ fingerprint.hash()) % this.filterSize\n\n    return this.buckets[k]?.has(fingerprint) ?? false\n  }\n\n  remove (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize)\n    const j = this.hash.hash(item, this.seed) % this.filterSize\n    const inJ = this.buckets[j]?.remove(fingerprint) ?? false\n\n    if (inJ) {\n      this.count--\n      return inJ\n    }\n\n    const k = (j ^ fingerprint.hash()) % this.filterSize\n    const inK = this.buckets[k]?.remove(fingerprint) ?? false\n\n    if (inK) {\n      this.count--\n    }\n\n    return inK\n  }\n\n  get reliable (): boolean {\n    return Math.floor(100 * (this.count / this.filterSize)) <= 90\n  }\n}\n\n// max load constants, defined in the cuckoo paper\nconst MAX_LOAD = {\n  1: 0.5,\n  2: 0.84,\n  4: 0.95,\n  8: 0.98\n}\n\nfunction calculateBucketSize (errorRate: number = 0.001): 2 | 4 | 8 {\n  if (errorRate > 0.002) {\n    return 2\n  }\n\n  if (errorRate > 0.00001) {\n    return 4\n  }\n\n  return 8\n}\n\nexport function optimize (maxItems: number, errorRate: number = 0.001): CuckooFilterInit {\n  // https://www.eecs.harvard.edu/~michaelm/postscripts/cuckoo-conext2014.pdf\n  // Section 5.1 Optimal Bucket Size\n  const bucketSize = calculateBucketSize(errorRate)\n  const load = MAX_LOAD[bucketSize]\n\n  // https://stackoverflow.com/questions/57555236/how-to-size-a-cuckoo-filter/57617208#57617208\n  const filterSize = Math.round(maxItems / load)\n  const fingerprintSize = Math.min(Math.ceil(Math.log2(1 / errorRate) + Math.log2(2 * bucketSize)), MAX_FINGERPRINT_SIZE)\n\n  return {\n    filterSize,\n    bucketSize,\n    fingerprintSize\n  }\n}\n\nexport function createCuckooFilter (maxItems: number, errorRate: number = 0.005): Filter {\n  const opts = optimize(maxItems, errorRate)\n  return new CuckooFilter(opts)\n}\n", "import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { CuckooFilter, optimize, type CuckooFilterInit } from './cuckoo-filter.js'\nimport { fnv1a, type Hash } from './hashes.js'\nimport { getRandomInt } from './utils.js'\nimport type { Filter } from './index.js'\n\nexport interface ScalableCuckooFilterInit extends CuckooFilterInit {\n  /**\n   * A number to multiply maxItems by when adding new sub-filters\n   */\n  scale?: number\n}\n\nexport class ScalableCuckooFilter implements Filter {\n  private readonly filterSize: number\n  private readonly bucketSize: number\n  private readonly fingerprintSize: number\n  private readonly scale: number\n  private readonly filterSeries: CuckooFilter[]\n  private readonly hash: Hash\n  private readonly seed: number\n\n  constructor (init: ScalableCuckooFilterInit) {\n    this.bucketSize = init.bucketSize ?? 4\n    this.filterSize = init.filterSize ?? (1 << 18) / this.bucketSize\n    this.fingerprintSize = init.fingerprintSize ?? 2\n    this.scale = init.scale ?? 2\n    this.hash = init.hash ?? fnv1a\n    this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10))\n    this.filterSeries = [\n      new CuckooFilter({\n        filterSize: this.filterSize,\n        bucketSize: this.bucketSize,\n        fingerprintSize: this.fingerprintSize,\n        hash: this.hash,\n        seed: this.seed\n      })\n    ]\n  }\n\n  add (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    if (this.has(item)) {\n      return true\n    }\n\n    let current = this.filterSeries.find((cuckoo) => {\n      return cuckoo.reliable\n    })\n\n    if (current == null) {\n      const curSize = this.filterSize * Math.pow(this.scale, this.filterSeries.length)\n\n      current = new CuckooFilter({\n        filterSize: curSize,\n        bucketSize: this.bucketSize,\n        fingerprintSize: this.fingerprintSize,\n        hash: this.hash,\n        seed: this.seed\n      })\n\n      this.filterSeries.push(current)\n    }\n\n    return current.add(item)\n  }\n\n  has (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    for (let i = 0; i < this.filterSeries.length; i++) {\n      if (this.filterSeries[i].has(item)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  remove (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    for (let i = 0; i < this.filterSeries.length; i++) {\n      if (this.filterSeries[i].remove(item)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  get count (): number {\n    return this.filterSeries.reduce((acc, curr) => {\n      return acc + curr.count\n    }, 0)\n  }\n}\n\nexport function createScalableCuckooFilter (maxItems: number, errorRate: number = 0.001, options?: Pick<ScalableCuckooFilterInit, 'hash' | 'seed' | 'scale'>): Filter {\n  return new ScalableCuckooFilter({\n    ...optimize(maxItems, errorRate),\n    ...(options ?? {})\n  })\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { type Codec, decodeMessage, type DecodeOptions, encodeMessage, message } from 'protons-runtime'\nimport { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Envelope {\n  publicKey: Uint8Array\n  payloadType: Uint8Array\n  payload: Uint8Array\n  signature: Uint8Array\n}\n\nexport namespace Envelope {\n  let _codec: Codec<Envelope>\n\n  export const codec = (): Codec<Envelope> => {\n    if (_codec == null) {\n      _codec = message<Envelope>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.publicKey != null && obj.publicKey.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.publicKey)\n        }\n\n        if ((obj.payloadType != null && obj.payloadType.byteLength > 0)) {\n          w.uint32(18)\n          w.bytes(obj.payloadType)\n        }\n\n        if ((obj.payload != null && obj.payload.byteLength > 0)) {\n          w.uint32(26)\n          w.bytes(obj.payload)\n        }\n\n        if ((obj.signature != null && obj.signature.byteLength > 0)) {\n          w.uint32(42)\n          w.bytes(obj.signature)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          publicKey: uint8ArrayAlloc(0),\n          payloadType: uint8ArrayAlloc(0),\n          payload: uint8ArrayAlloc(0),\n          signature: uint8ArrayAlloc(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.publicKey = reader.bytes()\n              break\n            }\n            case 2: {\n              obj.payloadType = reader.bytes()\n              break\n            }\n            case 3: {\n              obj.payload = reader.bytes()\n              break\n            }\n            case 5: {\n              obj.signature = reader.bytes()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Envelope>): Uint8Array => {\n    return encodeMessage(obj, Envelope.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Envelope>): Envelope => {\n    return decodeMessage(buf, Envelope.codec(), opts)\n  }\n}\n", "/**\n * The key in the record is not valid for the domain\n */\nexport class InvalidSignatureError extends Error {\n  constructor (message = 'Invalid signature') {\n    super(message)\n    this.name = 'InvalidSignatureError'\n  }\n}\n", "import { publicKeyFromProtobuf, publicKeyToProtobuf } from '@libp2p/crypto/keys'\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { fromString as uint8arraysFromString } from 'uint8arrays/from-string'\nimport { Envelope as Protobuf } from './envelope.js'\nimport { InvalidSignatureError } from './errors.js'\nimport type { Record, Envelope, PrivateKey, PublicKey } from '@libp2p/interface'\n\nexport interface RecordEnvelopeInit {\n  publicKey: PublicKey\n  payloadType: Uint8Array\n  payload: Uint8Array\n  signature: Uint8Array\n}\n\nexport class RecordEnvelope implements Envelope {\n  /**\n   * Unmarshal a serialized Envelope protobuf message\n   */\n  static createFromProtobuf = async (data: Uint8Array | Uint8ArrayList): Promise<RecordEnvelope> => {\n    const envelopeData = Protobuf.decode(data)\n    const publicKey = publicKeyFromProtobuf(envelopeData.publicKey)\n\n    return new RecordEnvelope({\n      publicKey,\n      payloadType: envelopeData.payloadType,\n      payload: envelopeData.payload,\n      signature: envelopeData.signature\n    })\n  }\n\n  /**\n   * Seal marshals the given Record, places the marshaled bytes inside an Envelope\n   * and signs it with the given peerId's private key\n   */\n  static seal = async (record: Record, privateKey: PrivateKey): Promise<RecordEnvelope> => {\n    if (privateKey == null) {\n      throw new Error('Missing private key')\n    }\n\n    const domain = record.domain\n    const payloadType = record.codec\n    const payload = record.marshal()\n    const signData = formatSignaturePayload(domain, payloadType, payload)\n    const signature = await privateKey.sign(signData.subarray())\n\n    return new RecordEnvelope({\n      publicKey: privateKey.publicKey,\n      payloadType,\n      payload,\n      signature\n    })\n  }\n\n  /**\n   * Open and certify a given marshaled envelope.\n   * Data is unmarshaled and the signature validated for the given domain.\n   */\n  static openAndCertify = async (data: Uint8Array | Uint8ArrayList, domain: string): Promise<RecordEnvelope> => {\n    const envelope = await RecordEnvelope.createFromProtobuf(data)\n    const valid = await envelope.validate(domain)\n\n    if (!valid) {\n      throw new InvalidSignatureError('Envelope signature is not valid for the given domain')\n    }\n\n    return envelope\n  }\n\n  public publicKey: PublicKey\n  public payloadType: Uint8Array\n  public payload: Uint8Array\n  public signature: Uint8Array\n  public marshaled?: Uint8Array\n\n  /**\n   * The Envelope is responsible for keeping an arbitrary signed record\n   * by a libp2p peer.\n   */\n  constructor (init: RecordEnvelopeInit) {\n    const { publicKey, payloadType, payload, signature } = init\n\n    this.publicKey = publicKey\n    this.payloadType = payloadType\n    this.payload = payload\n    this.signature = signature\n  }\n\n  /**\n   * Marshal the envelope content\n   */\n  marshal (): Uint8Array {\n    if (this.marshaled == null) {\n      this.marshaled = Protobuf.encode({\n        publicKey: publicKeyToProtobuf(this.publicKey),\n        payloadType: this.payloadType,\n        payload: this.payload.subarray(),\n        signature: this.signature\n      })\n    }\n\n    return this.marshaled\n  }\n\n  /**\n   * Verifies if the other Envelope is identical to this one\n   */\n  equals (other: Envelope): boolean {\n    return uint8ArrayEquals(this.marshal(), other.marshal())\n  }\n\n  /**\n   * Validate envelope data signature for the given domain\n   */\n  async validate (domain: string): Promise<boolean> {\n    const signData = formatSignaturePayload(domain, this.payloadType, this.payload)\n\n    return this.publicKey.verify(signData.subarray(), this.signature)\n  }\n}\n\n/**\n * Helper function that prepares a Uint8Array to sign or verify a signature\n */\nconst formatSignaturePayload = (domain: string, payloadType: Uint8Array, payload: Uint8Array | Uint8ArrayList): Uint8ArrayList => {\n  // When signing, a peer will prepare a Uint8Array by concatenating the following:\n  // - The length of the domain separation string string in bytes\n  // - The domain separation string, encoded as UTF-8\n  // - The length of the payload_type field in bytes\n  // - The value of the payload_type field\n  // - The length of the payload field in bytes\n  // - The value of the payload field\n\n  const domainUint8Array = uint8arraysFromString(domain)\n  const domainLength = varint.encode(domainUint8Array.byteLength)\n  const payloadTypeLength = varint.encode(payloadType.length)\n  const payloadLength = varint.encode(payload.length)\n\n  return new Uint8ArrayList(\n    domainLength,\n    domainUint8Array,\n    payloadTypeLength,\n    payloadType,\n    payloadLength,\n    payload\n  )\n}\n", "/**\n * @packageDocumentation\n *\n * Provides strategies ensure arrays are equivalent.\n *\n * @example\n *\n * ```typescript\n * import { arrayEquals } from '@libp2p/utils/array-equals'\n * import { multiaddr } from '@multformats/multiaddr'\n *\n * const ma1 = multiaddr('/ip4/127.0.0.1/tcp/9000'),\n * const ma2 = multiaddr('/ip4/82.41.53.1/tcp/9000')\n *\n * console.info(arrayEquals([ma1], [ma1])) // true\n * console.info(arrayEquals([ma1], [ma2])) // false\n * ```\n */\n\n/**\n * Verify if two arrays of non primitive types with the \"equals\" function are equal.\n * Compatible with multiaddr, peer-id and others.\n */\nexport function arrayEquals (a: any[], b: any[]): boolean {\n  const sort = (a: any, b: any): number => a.toString().localeCompare(b.toString())\n\n  if (a.length !== b.length) {\n    return false\n  }\n\n  b.sort(sort)\n\n  return a.sort(sort).every((item, index) => b[index].equals(item))\n}\n", "// The domain string used for peer records contained in a Envelope.\nexport const ENVELOPE_DOMAIN_PEER_RECORD = 'libp2p-peer-record'\n\n// The type hint used to identify peer records in a Envelope.\n// Defined in https://github.com/multiformats/multicodec/blob/master/table.csv\n// with name \"libp2p-peer-record\"\nexport const ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1])\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { type Codec, decodeMessage, type DecodeOptions, encodeMessage, MaxLengthError, message } from 'protons-runtime'\nimport { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface PeerRecord {\n  peerId: Uint8Array\n  seq: bigint\n  addresses: PeerRecord.AddressInfo[]\n}\n\nexport namespace PeerRecord {\n  export interface AddressInfo {\n    multiaddr: Uint8Array\n  }\n\n  export namespace AddressInfo {\n    let _codec: Codec<AddressInfo>\n\n    export const codec = (): Codec<AddressInfo> => {\n      if (_codec == null) {\n        _codec = message<AddressInfo>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if ((obj.multiaddr != null && obj.multiaddr.byteLength > 0)) {\n            w.uint32(10)\n            w.bytes(obj.multiaddr)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {\n            multiaddr: uint8ArrayAlloc(0)\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.multiaddr = reader.bytes()\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<AddressInfo>): Uint8Array => {\n      return encodeMessage(obj, AddressInfo.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<AddressInfo>): AddressInfo => {\n      return decodeMessage(buf, AddressInfo.codec(), opts)\n    }\n  }\n\n  let _codec: Codec<PeerRecord>\n\n  export const codec = (): Codec<PeerRecord> => {\n    if (_codec == null) {\n      _codec = message<PeerRecord>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.peerId != null && obj.peerId.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.peerId)\n        }\n\n        if ((obj.seq != null && obj.seq !== 0n)) {\n          w.uint32(16)\n          w.uint64(obj.seq)\n        }\n\n        if (obj.addresses != null) {\n          for (const value of obj.addresses) {\n            w.uint32(26)\n            PeerRecord.AddressInfo.codec().encode(value, w)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          peerId: uint8ArrayAlloc(0),\n          seq: 0n,\n          addresses: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.peerId = reader.bytes()\n              break\n            }\n            case 2: {\n              obj.seq = reader.uint64()\n              break\n            }\n            case 3: {\n              if (opts.limits?.addresses != null && obj.addresses.length === opts.limits.addresses) {\n                throw new MaxLengthError('Decode error - map field \"addresses\" had too many elements')\n              }\n\n              obj.addresses.push(PeerRecord.AddressInfo.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.addresses$\n              }))\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PeerRecord>): Uint8Array => {\n    return encodeMessage(obj, PeerRecord.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<PeerRecord>): PeerRecord => {\n    return decodeMessage(buf, PeerRecord.codec(), opts)\n  }\n}\n", "import { peerIdFromMultihash } from '@libp2p/peer-id'\nimport { arrayEquals } from '@libp2p/utils/array-equals'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport * as Digest from 'multiformats/hashes/digest'\nimport {\n  ENVELOPE_DOMAIN_PEER_RECORD,\n  ENVELOPE_PAYLOAD_TYPE_PEER_RECORD\n} from './consts.js'\nimport { PeerRecord as Protobuf } from './peer-record.js'\nimport type { PeerId } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface PeerRecordInit {\n  peerId: PeerId\n\n  /**\n   * Addresses of the associated peer.\n   */\n  multiaddrs?: Multiaddr[]\n\n  /**\n   * Monotonically-increasing sequence counter that's used to order PeerRecords in time.\n   */\n  seqNumber?: bigint\n}\n\n/**\n * The PeerRecord is used for distributing peer routing records across the network.\n * It contains the peer's reachable listen addresses.\n */\nexport class PeerRecord {\n  /**\n   * Unmarshal Peer Record Protobuf\n   */\n  static createFromProtobuf = (buf: Uint8Array | Uint8ArrayList): PeerRecord => {\n    const peerRecord = Protobuf.decode(buf)\n    const peerId = peerIdFromMultihash(Digest.decode(peerRecord.peerId))\n    const multiaddrs = (peerRecord.addresses ?? []).map((a) => multiaddr(a.multiaddr))\n    const seqNumber = peerRecord.seq\n\n    return new PeerRecord({ peerId, multiaddrs, seqNumber })\n  }\n\n  static DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD\n  static CODEC = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD\n\n  public peerId: PeerId\n  public multiaddrs: Multiaddr[]\n  public seqNumber: bigint\n  public domain = PeerRecord.DOMAIN\n  public codec = PeerRecord.CODEC\n  private marshaled?: Uint8Array\n\n  constructor (init: PeerRecordInit) {\n    const { peerId, multiaddrs, seqNumber } = init\n\n    this.peerId = peerId\n    this.multiaddrs = multiaddrs ?? []\n    this.seqNumber = seqNumber ?? BigInt(Date.now())\n  }\n\n  /**\n   * Marshal a record to be used in an envelope\n   */\n  marshal (): Uint8Array {\n    if (this.marshaled == null) {\n      this.marshaled = Protobuf.encode({\n        peerId: this.peerId.toMultihash().bytes,\n        seq: BigInt(this.seqNumber),\n        addresses: this.multiaddrs.map((m) => ({\n          multiaddr: m.bytes\n        }))\n      })\n    }\n\n    return this.marshaled\n  }\n\n  /**\n   * Returns true if `this` record equals the `other`\n   */\n  equals (other: unknown): boolean {\n    if (!(other instanceof PeerRecord)) {\n      return false\n    }\n\n    // Validate PeerId\n    if (!this.peerId.equals(other.peerId)) {\n      return false\n    }\n\n    // Validate seqNumber\n    if (this.seqNumber !== other.seqNumber) {\n      return false\n    }\n\n    // Validate multiaddrs\n    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {\n      return false\n    }\n\n    return true\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * For when you need a one-liner to collect iterable values.\n *\n * @example\n *\n * ```javascript\n * import all from 'it-all'\n *\n * // This can also be an iterator, etc\n * const values = function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = all(values)\n *\n * console.info(arr) // 0, 1, 2, 3, 4\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = await all(values())\n *\n * console.info(arr) // 0, 1, 2, 3, 4\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Collects all values from an (async) iterable and returns them as an array\n */\nfunction all <T> (source: Iterable<T>): T[]\nfunction all <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T[]>\nfunction all <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T[]> | T[] {\n  if (isAsyncIterable(source)) {\n    return (async () => {\n      const arr = []\n\n      for await (const entry of source) {\n        arr.push(entry)\n      }\n\n      return arr\n    })()\n  }\n\n  const arr = []\n\n  for (const entry of source) {\n    arr.push(entry)\n  }\n\n  return arr\n}\n\nexport default all\n", "export interface WebworkerEventListener <T = any> {\n  (worker: Worker, event: MessageEvent<T>): void\n}\n\nconst events: Record<string, WebworkerEventListener[]> = {}\n\nconst observable = (worker: Worker & { port?: any }) => {\n  worker.addEventListener('message', (event) => {\n    observable.dispatchEvent('message', worker, event)\n  })\n\n  if (worker.port != null) {\n    worker.port.addEventListener('message', (event: any) => {\n      observable.dispatchEvent('message', worker, event)\n    })\n  }\n}\n\nobservable.addEventListener = (type: string, fn: WebworkerEventListener) => {\n  if (events[type] == null) {\n    events[type] = []\n  }\n\n  events[type].push(fn)\n}\n\nobservable.removeEventListener = (type: string, fn: WebworkerEventListener) => {\n  if (events[type] == null) {\n    return\n  }\n\n  events[type] = events[type]\n    .filter(listener => listener === fn)\n}\n\nobservable.dispatchEvent = function (type: string, worker: Worker, event: MessageEvent<any>) {\n  if (events[type] == null) {\n    return\n  }\n\n  events[type].forEach(fn => fn(worker, event))\n}\n\nexport default observable\n", "export const WORKER_REQUEST_READ_LOCK = 'lock:worker:request-read'\nexport const WORKER_RELEASE_READ_LOCK = 'lock:worker:release-read'\nexport const MASTER_GRANT_READ_LOCK = 'lock:master:grant-read'\n\nexport const WORKER_REQUEST_WRITE_LOCK = 'lock:worker:request-write'\nexport const WORKER_RELEASE_WRITE_LOCK = 'lock:worker:release-write'\nexport const MASTER_GRANT_WRITE_LOCK = 'lock:master:grant-write'\n", "export const nanoid = (size: number = 21): string => {\n  return Math.random().toString().substring(2)\n}\n", "import observer from 'observable-webworkers'\nimport {\n  WORKER_REQUEST_READ_LOCK,\n  WORKER_RELEASE_READ_LOCK,\n  MASTER_GRANT_READ_LOCK,\n  WORKER_REQUEST_WRITE_LOCK,\n  WORKER_RELEASE_WRITE_LOCK,\n  MASTER_GRANT_WRITE_LOCK\n} from './constants.js'\nimport { nanoid } from './utils.js'\nimport type { MorticeImplementation, MorticeOptions, Release } from './index.js'\n\nconst handleWorkerLockRequest = (emitter: EventTarget, masterEvent: string, requestType: string, releaseType: string, grantType: string) => {\n  return (worker: Worker, event: MessageEvent) => {\n    if (event.data.type !== requestType) {\n      return\n    }\n\n    const requestEvent = {\n      type: event.data.type,\n      name: event.data.name,\n      identifier: event.data.identifier\n    }\n\n    emitter.dispatchEvent(new MessageEvent(masterEvent, {\n      data: {\n        name: requestEvent.name,\n        handler: async (): Promise<void> => {\n          // grant lock to worker\n          worker.postMessage({\n            type: grantType,\n            name: requestEvent.name,\n            identifier: requestEvent.identifier\n          })\n\n          // wait for worker to finish\n          await new Promise<void>((resolve) => {\n            const releaseEventListener = (event: MessageEvent): void => {\n              if (event?.data == null) {\n                return\n              }\n\n              const releaseEvent = {\n                type: event.data.type,\n                name: event.data.name,\n                identifier: event.data.identifier\n              }\n\n              if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {\n                worker.removeEventListener('message', releaseEventListener)\n                resolve()\n              }\n            }\n\n            worker.addEventListener('message', releaseEventListener)\n          })\n        }\n      }\n    }))\n  }\n}\n\nconst makeWorkerLockRequest = (name: string, requestType: string, grantType: string, releaseType: string) => {\n  return async () => {\n    const id = nanoid()\n\n    globalThis.postMessage({\n      type: requestType,\n      identifier: id,\n      name\n    })\n\n    return new Promise<Release>((resolve) => {\n      const listener = (event: MessageEvent): void => {\n        if (event?.data == null) {\n          return\n        }\n\n        const responseEvent = {\n          type: event.data.type,\n          identifier: event.data.identifier\n        }\n\n        if (responseEvent.type === grantType && responseEvent.identifier === id) {\n          globalThis.removeEventListener('message', listener)\n\n          // grant lock\n          resolve(() => {\n            // release lock\n            globalThis.postMessage({\n              type: releaseType,\n              identifier: id,\n              name\n            })\n          })\n        }\n      }\n\n      globalThis.addEventListener('message', listener)\n    })\n  }\n}\n\nconst defaultOptions = {\n  singleProcess: false\n}\n\nexport default (options: Required<MorticeOptions>): MorticeImplementation | EventTarget => {\n  options = Object.assign({}, defaultOptions, options)\n  const isPrimary = Boolean(globalThis.document) || options.singleProcess\n\n  if (isPrimary) {\n    const emitter = new EventTarget()\n\n    observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestReadLock', WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK))\n    observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestWriteLock', WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK))\n\n    return emitter\n  }\n\n  return {\n    isWorker: true,\n    readLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),\n    writeLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * - Reads occur concurrently\n * - Writes occur one at a time\n * - No reads occur while a write operation is in progress\n * - Locks can be created with different names\n * - Reads/writes can time out\n *\n * ## Usage\n *\n * ```javascript\n * import mortice from 'mortice'\n * import delay from 'delay'\n *\n * // the lock name & options objects are both optional\n * const mutex = mortice('my-lock', {\n *\n *   // how long before write locks time out (default: 24 hours)\n *   timeout: 30000,\n *\n *    // control how many read operations are executed concurrently (default: Infinity)\n *   concurrency: 5,\n *\n *   // by default the the lock will be held on the main thread, set this to true if the\n *   // a lock should reside on each worker (default: false)\n *   singleProcess: false\n * })\n *\n * Promise.all([\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 1')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 2')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.writeLock()\n *\n *     try {\n *       await delay(1000)\n *\n *       console.info('write 1')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 3')\n *     } finally {\n *       release()\n *     }\n *   })()\n * ])\n * ```\n *\n *     read 1\n *     read 2\n *     <small pause>\n *     write 1\n *     read 3\n *\n * ## Browser\n *\n * Because there's no global way to evesdrop on messages sent by Web Workers, please pass all created Web Workers to the [`observable-webworkers`](https://npmjs.org/package/observable-webworkers) module:\n *\n * ```javascript\n * // main.js\n * import mortice from 'mortice'\n * import observe from 'observable-webworkers'\n *\n * // create our lock on the main thread, it will be held here\n * const mutex = mortice()\n *\n * const worker = new Worker('worker.js')\n *\n * observe(worker)\n * ```\n *\n * ```javascript\n * // worker.js\n * import mortice from 'mortice'\n * import delay from 'delay'\n *\n * const mutex = mortice()\n *\n * let release = await mutex.readLock()\n * // read something\n * release()\n *\n * release = await mutex.writeLock()\n * // write something\n * release()\n * ```\n */\n\nimport PQueue from 'p-queue'\nimport pTimeout from 'p-timeout'\nimport impl from './node.js'\n\nexport interface MorticeOptions {\n  name?: string\n  timeout?: number\n  concurrency?: number\n  singleProcess?: boolean\n}\n\nexport interface Mortice {\n  readLock(): Promise<Release>\n  writeLock(): Promise<Release>\n}\n\nexport interface Release {\n  (): void\n}\n\nexport interface MorticeImplementation {\n  isWorker: boolean\n  readLock(name: string, options: MorticeOptions): Mortice['readLock']\n  writeLock(name: string, options: MorticeOptions): Mortice['writeLock']\n}\n\nconst mutexes: Record<string, Mortice> = {}\nlet implementation: any\n\nasync function createReleaseable (queue: PQueue, options: Required<MorticeOptions>): Promise<Release> {\n  let res: (release: Release) => void\n\n  const p = new Promise<Release>((resolve) => {\n    res = resolve\n  })\n\n  void queue.add(async () => pTimeout((async () => {\n    await new Promise<void>((resolve) => {\n      res(() => {\n        resolve()\n      })\n    })\n  })(), {\n    milliseconds: options.timeout\n  }))\n\n  return p\n}\n\nconst createMutex = (name: string, options: Required<MorticeOptions>): Mortice => {\n  if (implementation.isWorker === true) {\n    return {\n      readLock: implementation.readLock(name, options),\n      writeLock: implementation.writeLock(name, options)\n    }\n  }\n\n  const masterQueue = new PQueue({ concurrency: 1 })\n  let readQueue: PQueue | null\n\n  return {\n    async readLock () {\n      // If there's already a read queue, just add the task to it\n      if (readQueue != null) {\n        return createReleaseable(readQueue, options)\n      }\n\n      // Create a new read queue\n      readQueue = new PQueue({\n        concurrency: options.concurrency,\n        autoStart: false\n      })\n      const localReadQueue = readQueue\n\n      // Add the task to the read queue\n      const readPromise = createReleaseable(readQueue, options)\n\n      void masterQueue.add(async () => {\n        // Start the task only once the master queue has completed processing\n        // any previous tasks\n        localReadQueue.start()\n\n        // Once all the tasks in the read queue have completed, remove it so\n        // that the next read lock will occur after any write locks that were\n        // started in the interim\n        await localReadQueue.onIdle()\n          .then(() => {\n            if (readQueue === localReadQueue) {\n              readQueue = null\n            }\n          })\n      })\n\n      return readPromise\n    },\n    async writeLock () {\n      // Remove the read queue reference, so that any later read locks will be\n      // added to a new queue that starts after this write lock has been\n      // released\n      readQueue = null\n\n      return createReleaseable(masterQueue, options)\n    }\n  }\n}\n\nconst defaultOptions = {\n  name: 'lock',\n  concurrency: Infinity,\n  timeout: 84600000,\n  singleProcess: false\n}\n\ninterface EventData {\n  name: string\n  handler(): Promise<void>\n}\n\nexport default function createMortice (options?: MorticeOptions): Mortice {\n  const opts: Required<MorticeOptions> = Object.assign({}, defaultOptions, options)\n\n  if (implementation == null) {\n    implementation = impl(opts)\n\n    if (implementation.isWorker !== true) {\n      // we are master, set up worker requests\n      implementation.addEventListener('requestReadLock', (event: MessageEvent<EventData>) => {\n        if (mutexes[event.data.name] == null) {\n          return\n        }\n\n        void mutexes[event.data.name].readLock()\n          .then(async release => event.data.handler().finally(() => { release() }))\n      })\n\n      implementation.addEventListener('requestWriteLock', async (event: MessageEvent<EventData>) => {\n        if (mutexes[event.data.name] == null) {\n          return\n        }\n\n        void mutexes[event.data.name].writeLock()\n          .then(async release => event.data.handler().finally(() => { release() }))\n      })\n    }\n  }\n\n  if (mutexes[opts.name] == null) {\n    mutexes[opts.name] = createMutex(opts.name, opts)\n  }\n\n  return mutexes[opts.name]\n}\n", "export const MAX_ADDRESS_AGE = 3_600_000\nexport const MAX_PEER_AGE = 21_600_000\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { type Codec, decodeMessage, type DecodeOptions, encodeMessage, MaxLengthError, MaxSizeError, message } from 'protons-runtime'\nimport { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Peer {\n  addresses: Address[]\n  protocols: string[]\n  publicKey?: Uint8Array\n  peerRecordEnvelope?: Uint8Array\n  metadata: Map<string, Uint8Array>\n  tags: Map<string, Tag>\n  updated?: number\n}\n\nexport namespace Peer {\n  export interface Peer$metadataEntry {\n    key: string\n    value: Uint8Array\n  }\n\n  export namespace Peer$metadataEntry {\n    let _codec: Codec<Peer$metadataEntry>\n\n    export const codec = (): Codec<Peer$metadataEntry> => {\n      if (_codec == null) {\n        _codec = message<Peer$metadataEntry>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if ((obj.key != null && obj.key !== '')) {\n            w.uint32(10)\n            w.string(obj.key)\n          }\n\n          if ((obj.value != null && obj.value.byteLength > 0)) {\n            w.uint32(18)\n            w.bytes(obj.value)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {\n            key: '',\n            value: uint8ArrayAlloc(0)\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.key = reader.string()\n                break\n              }\n              case 2: {\n                obj.value = reader.bytes()\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<Peer$metadataEntry>): Uint8Array => {\n      return encodeMessage(obj, Peer$metadataEntry.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Peer$metadataEntry>): Peer$metadataEntry => {\n      return decodeMessage(buf, Peer$metadataEntry.codec(), opts)\n    }\n  }\n\n  export interface Peer$tagsEntry {\n    key: string\n    value?: Tag\n  }\n\n  export namespace Peer$tagsEntry {\n    let _codec: Codec<Peer$tagsEntry>\n\n    export const codec = (): Codec<Peer$tagsEntry> => {\n      if (_codec == null) {\n        _codec = message<Peer$tagsEntry>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if ((obj.key != null && obj.key !== '')) {\n            w.uint32(10)\n            w.string(obj.key)\n          }\n\n          if (obj.value != null) {\n            w.uint32(18)\n            Tag.codec().encode(obj.value, w)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {\n            key: ''\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.key = reader.string()\n                break\n              }\n              case 2: {\n                obj.value = Tag.codec().decode(reader, reader.uint32(), {\n                  limits: opts.limits?.value\n                })\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<Peer$tagsEntry>): Uint8Array => {\n      return encodeMessage(obj, Peer$tagsEntry.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Peer$tagsEntry>): Peer$tagsEntry => {\n      return decodeMessage(buf, Peer$tagsEntry.codec(), opts)\n    }\n  }\n\n  let _codec: Codec<Peer>\n\n  export const codec = (): Codec<Peer> => {\n    if (_codec == null) {\n      _codec = message<Peer>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.addresses != null) {\n          for (const value of obj.addresses) {\n            w.uint32(10)\n            Address.codec().encode(value, w)\n          }\n        }\n\n        if (obj.protocols != null) {\n          for (const value of obj.protocols) {\n            w.uint32(18)\n            w.string(value)\n          }\n        }\n\n        if (obj.publicKey != null) {\n          w.uint32(34)\n          w.bytes(obj.publicKey)\n        }\n\n        if (obj.peerRecordEnvelope != null) {\n          w.uint32(42)\n          w.bytes(obj.peerRecordEnvelope)\n        }\n\n        if (obj.metadata != null && obj.metadata.size !== 0) {\n          for (const [key, value] of obj.metadata.entries()) {\n            w.uint32(50)\n            Peer.Peer$metadataEntry.codec().encode({ key, value }, w)\n          }\n        }\n\n        if (obj.tags != null && obj.tags.size !== 0) {\n          for (const [key, value] of obj.tags.entries()) {\n            w.uint32(58)\n            Peer.Peer$tagsEntry.codec().encode({ key, value }, w)\n          }\n        }\n\n        if (obj.updated != null) {\n          w.uint32(64)\n          w.uint64Number(obj.updated)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          addresses: [],\n          protocols: [],\n          metadata: new Map<string, Uint8Array>(),\n          tags: new Map<string, undefined>()\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              if (opts.limits?.addresses != null && obj.addresses.length === opts.limits.addresses) {\n                throw new MaxLengthError('Decode error - map field \"addresses\" had too many elements')\n              }\n\n              obj.addresses.push(Address.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.addresses$\n              }))\n              break\n            }\n            case 2: {\n              if (opts.limits?.protocols != null && obj.protocols.length === opts.limits.protocols) {\n                throw new MaxLengthError('Decode error - map field \"protocols\" had too many elements')\n              }\n\n              obj.protocols.push(reader.string())\n              break\n            }\n            case 4: {\n              obj.publicKey = reader.bytes()\n              break\n            }\n            case 5: {\n              obj.peerRecordEnvelope = reader.bytes()\n              break\n            }\n            case 6: {\n              if (opts.limits?.metadata != null && obj.metadata.size === opts.limits.metadata) {\n                throw new MaxSizeError('Decode error - map field \"metadata\" had too many elements')\n              }\n\n              const entry = Peer.Peer$metadataEntry.codec().decode(reader, reader.uint32())\n              obj.metadata.set(entry.key, entry.value)\n              break\n            }\n            case 7: {\n              if (opts.limits?.tags != null && obj.tags.size === opts.limits.tags) {\n                throw new MaxSizeError('Decode error - map field \"tags\" had too many elements')\n              }\n\n              const entry = Peer.Peer$tagsEntry.codec().decode(reader, reader.uint32(), {\n                limits: {\n                  value: opts.limits?.tags$value\n                }\n              })\n              obj.tags.set(entry.key, entry.value)\n              break\n            }\n            case 8: {\n              obj.updated = reader.uint64Number()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Peer>): Uint8Array => {\n    return encodeMessage(obj, Peer.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Peer>): Peer => {\n    return decodeMessage(buf, Peer.codec(), opts)\n  }\n}\n\nexport interface Address {\n  multiaddr: Uint8Array\n  isCertified?: boolean\n  observed?: number\n}\n\nexport namespace Address {\n  let _codec: Codec<Address>\n\n  export const codec = (): Codec<Address> => {\n    if (_codec == null) {\n      _codec = message<Address>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.multiaddr != null && obj.multiaddr.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.multiaddr)\n        }\n\n        if (obj.isCertified != null) {\n          w.uint32(16)\n          w.bool(obj.isCertified)\n        }\n\n        if (obj.observed != null) {\n          w.uint32(24)\n          w.uint64Number(obj.observed)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          multiaddr: uint8ArrayAlloc(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.multiaddr = reader.bytes()\n              break\n            }\n            case 2: {\n              obj.isCertified = reader.bool()\n              break\n            }\n            case 3: {\n              obj.observed = reader.uint64Number()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Address>): Uint8Array => {\n    return encodeMessage(obj, Address.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Address>): Address => {\n    return decodeMessage(buf, Address.codec(), opts)\n  }\n}\n\nexport interface Tag {\n  value: number\n  expiry?: bigint\n}\n\nexport namespace Tag {\n  let _codec: Codec<Tag>\n\n  export const codec = (): Codec<Tag> => {\n    if (_codec == null) {\n      _codec = message<Tag>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.value != null && obj.value !== 0)) {\n          w.uint32(8)\n          w.uint32(obj.value)\n        }\n\n        if (obj.expiry != null) {\n          w.uint32(16)\n          w.uint64(obj.expiry)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          value: 0\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.value = reader.uint32()\n              break\n            }\n            case 2: {\n              obj.expiry = reader.uint64()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Tag>): Uint8Array => {\n    return encodeMessage(obj, Tag.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Tag>): Tag => {\n    return decodeMessage(buf, Tag.codec(), opts)\n  }\n}\n", "import { publicKeyFromProtobuf } from '@libp2p/crypto/keys'\nimport { peerIdFromPublicKey } from '@libp2p/peer-id'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { base58btc } from 'multiformats/bases/base58'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { Peer as PeerPB } from '../pb/peer.js'\nimport type { PeerId, Peer, Tag } from '@libp2p/interface'\n\nfunction populatePublicKey (peerId: PeerId, protobuf: PeerPB): PeerId {\n  if (peerId.publicKey != null || protobuf.publicKey == null) {\n    return peerId\n  }\n\n  let digest: any\n\n  if (peerId.type === 'RSA') {\n    // avoid hashing public key\n    const multihash = base58btc.decode(`z${peerId}`)\n    digest = Digest.decode(multihash)\n  }\n\n  const publicKey = publicKeyFromProtobuf(protobuf.publicKey, digest)\n  return peerIdFromPublicKey(publicKey)\n}\n\nexport function bytesToPeer (peerId: PeerId, buf: Uint8Array, maxAddressAge: number): Peer {\n  const peer = PeerPB.decode(buf)\n\n  return pbToPeer(peerId, peer, maxAddressAge)\n}\n\nexport function pbToPeer (peerId: PeerId, peer: PeerPB, maxAddressAge: number): Peer {\n  const tags = new Map<string, Tag>()\n\n  // remove any expired tags\n  const now = BigInt(Date.now())\n\n  for (const [key, tag] of peer.tags.entries()) {\n    if (tag.expiry != null && tag.expiry < now) {\n      continue\n    }\n\n    tags.set(key, tag)\n  }\n\n  return {\n    ...peer,\n    id: populatePublicKey(peerId, peer),\n    addresses: peer.addresses\n      // remove any expired multiaddrs\n      .filter(({ observed }) => observed != null && observed > (Date.now() - maxAddressAge))\n      .map(({ multiaddr: ma, isCertified }) => {\n        return {\n          multiaddr: multiaddr(ma),\n          isCertified: isCertified ?? false\n        }\n      }),\n    metadata: peer.metadata,\n    peerRecordEnvelope: peer.peerRecordEnvelope ?? undefined,\n    tags\n  }\n}\n", "import { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport type { Peer, Address, Tag } from '../pb/peer.js'\n\nexport function peerEquals (peerA: Peer, peerB: Peer): boolean {\n  return addressesEqual(peerA.addresses, peerB.addresses) &&\n    protocolsEqual(peerA.protocols, peerB.protocols) &&\n    publicKeyEqual(peerA.publicKey, peerB.publicKey) &&\n    peerRecordEnvelope(peerA.peerRecordEnvelope, peerB.peerRecordEnvelope) &&\n    metadataEqual(peerA.metadata, peerB.metadata) &&\n    tagsEqual(peerA.tags, peerB.tags)\n}\n\nfunction addressesEqual (addressesA: Address[], addressesB: Address[]): boolean {\n  return compareArrays(addressesA, addressesB, (a, b) => {\n    if (a.isCertified !== b.isCertified) {\n      return false\n    }\n\n    if (!uint8ArrayEquals(a.multiaddr, b.multiaddr)) {\n      return false\n    }\n\n    return true\n  })\n}\n\nfunction protocolsEqual (protocolsA: string[], protocolsB: string[]): boolean {\n  return compareArrays(protocolsA, protocolsB, (a, b) => a === b)\n}\n\nfunction publicKeyEqual (publicKeyA?: Uint8Array, publicKeyB?: Uint8Array): boolean {\n  return compareOptionalUint8Arrays(publicKeyA, publicKeyB)\n}\n\nfunction peerRecordEnvelope (envelopeA?: Uint8Array, envelopeB?: Uint8Array): boolean {\n  return compareOptionalUint8Arrays(envelopeA, envelopeB)\n}\n\nfunction metadataEqual (metadataA: Map<string, Uint8Array>, metadataB: Map<string, Uint8Array>): boolean {\n  return compareMaps(metadataA, metadataB, (a, b) => uint8ArrayEquals(a, b))\n}\n\nfunction tagsEqual (metadataA: Map<string, Tag>, metadataB: Map<string, Tag>): boolean {\n  return compareMaps(metadataA, metadataB, (a, b) => a.value === b.value && a.expiry === b.expiry)\n}\n\nfunction compareOptionalUint8Arrays (arrA?: Uint8Array, arrB?: Uint8Array): boolean {\n  if (arrA == null && arrB == null) {\n    return true\n  }\n\n  if (arrA != null && arrB != null) {\n    return uint8ArrayEquals(arrA, arrB)\n  }\n\n  return false\n}\n\nfunction compareArrays <T> (arrA: T[], arrB: T[], compare: (a: T, b: T) => boolean): boolean {\n  if (arrA.length !== arrB.length) {\n    return false\n  }\n\n  for (let i = 0; i < arrA.length; i++) {\n    if (!compare(arrA[i], arrB[i])) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction compareMaps <K, V> (mapA: Map<K, V>, mapB: Map<K, V>, compare: (a: V, b: V) => boolean): boolean {\n  if (mapA.size !== mapB.size) {\n    return false\n  }\n\n  for (const [key, value] of mapA.entries()) {\n    const valueB = mapB.get(key)\n\n    if (valueB == null) {\n      return false\n    }\n\n    if (!compare(value, valueB)) {\n      return false\n    }\n  }\n\n  return true\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { isPeerId, type PeerId } from '@libp2p/interface'\nimport { Key } from 'interface-datastore/key'\n\nexport const NAMESPACE_COMMON = '/peers/'\n\nexport function peerIdToDatastoreKey (peerId: PeerId): Key {\n  if (!isPeerId(peerId) || peerId.type == null) {\n    throw new InvalidParametersError('Invalid PeerId')\n  }\n\n  const b32key = peerId.toCID().toString()\n  return new Key(`${NAMESPACE_COMMON}${b32key}`)\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\nimport type { AddressFilter } from '../index.js'\nimport type { Address as AddressPB } from '../pb/peer.js'\nimport type { PeerId, Address } from '@libp2p/interface'\n\nexport async function dedupeFilterAndSortAddresses (peerId: PeerId, filter: AddressFilter, addresses: Array<Address | AddressPB | undefined>, existingAddresses?: AddressPB[]): Promise<AddressPB[]> {\n  const addressMap = new Map<string, Address>()\n\n  for (const addr of addresses) {\n    if (addr == null) {\n      continue\n    }\n\n    if (addr.multiaddr instanceof Uint8Array) {\n      addr.multiaddr = multiaddr(addr.multiaddr)\n    }\n\n    if (!isMultiaddr(addr.multiaddr)) {\n      throw new InvalidParametersError('Multiaddr was invalid')\n    }\n\n    if (!(await filter(peerId, addr.multiaddr))) {\n      continue\n    }\n\n    const isCertified = addr.isCertified ?? false\n    const maStr = addr.multiaddr.toString()\n    const existingAddr = addressMap.get(maStr)\n\n    if (existingAddr != null) {\n      addr.isCertified = existingAddr.isCertified || isCertified\n    } else {\n      addressMap.set(maStr, {\n        multiaddr: addr.multiaddr,\n        isCertified\n      })\n    }\n  }\n\n  return [...addressMap.values()]\n    .sort((a, b) => {\n      return a.multiaddr.toString().localeCompare(b.multiaddr.toString())\n    })\n    .map(({ isCertified, multiaddr }) => ({\n      isCertified,\n      multiaddr: multiaddr.bytes\n    }))\n}\n", "/* eslint-disable complexity */\nimport { publicKeyToProtobuf } from '@libp2p/crypto/keys'\nimport { InvalidParametersError } from '@libp2p/interface'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { dedupeFilterAndSortAddresses } from './dedupe-addresses.js'\nimport type { AddressFilter } from '../index.js'\nimport type { Tag, Peer as PeerPB } from '../pb/peer.js'\nimport type { ExistingPeer } from '../store.js'\nimport type { PeerId, Address, PeerData, TagOptions } from '@libp2p/interface'\n\nexport interface ToPBPeerOptions {\n  addressFilter?: AddressFilter\n  existingPeer?: ExistingPeer\n}\n\nexport async function toPeerPB (peerId: PeerId, data: Partial<PeerData>, strategy: 'merge' | 'patch', options: ToPBPeerOptions): Promise<PeerPB> {\n  if (data == null) {\n    throw new InvalidParametersError('Invalid PeerData')\n  }\n\n  if (data.publicKey != null && peerId.publicKey != null && !data.publicKey.equals(peerId.publicKey)) {\n    throw new InvalidParametersError('publicKey bytes do not match peer id publicKey bytes')\n  }\n\n  const existingPeer = options.existingPeer?.peer\n\n  if (existingPeer != null && !peerId.equals(existingPeer.id)) {\n    throw new InvalidParametersError('peer id did not match existing peer id')\n  }\n\n  let addresses: Address[] = existingPeer?.addresses ?? []\n  let protocols = new Set<string>(existingPeer?.protocols ?? [])\n  let metadata: Map<string, Uint8Array> = existingPeer?.metadata ?? new Map()\n  let tags: Map<string, Tag> = existingPeer?.tags ?? new Map()\n  let peerRecordEnvelope: Uint8Array | undefined = existingPeer?.peerRecordEnvelope\n\n  // when patching, we replace the original fields with passed values\n  if (strategy === 'patch') {\n    if (data.multiaddrs != null || data.addresses != null) {\n      addresses = []\n\n      if (data.multiaddrs != null) {\n        addresses.push(...data.multiaddrs.map(multiaddr => ({\n          isCertified: false,\n          multiaddr\n        })))\n      }\n\n      if (data.addresses != null) {\n        addresses.push(...data.addresses)\n      }\n    }\n\n    if (data.protocols != null) {\n      protocols = new Set(data.protocols)\n    }\n\n    if (data.metadata != null) {\n      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata)\n\n      metadata = createSortedMap(metadataEntries, {\n        validate: validateMetadata\n      })\n    }\n\n    if (data.tags != null) {\n      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags)\n\n      tags = createSortedMap(tagsEntries, {\n        validate: validateTag,\n        map: mapTag\n      })\n    }\n\n    if (data.peerRecordEnvelope != null) {\n      peerRecordEnvelope = data.peerRecordEnvelope\n    }\n  }\n\n  // when merging, we join the original fields with passed values\n  if (strategy === 'merge') {\n    if (data.multiaddrs != null) {\n      addresses.push(...data.multiaddrs.map(multiaddr => ({\n        isCertified: false,\n        multiaddr\n      })))\n    }\n\n    if (data.addresses != null) {\n      addresses.push(...data.addresses)\n    }\n\n    if (data.protocols != null) {\n      protocols = new Set([...protocols, ...data.protocols])\n    }\n\n    if (data.metadata != null) {\n      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata)\n\n      for (const [key, value] of metadataEntries) {\n        if (value == null) {\n          metadata.delete(key)\n        } else {\n          metadata.set(key, value)\n        }\n      }\n\n      metadata = createSortedMap([...metadata.entries()], {\n        validate: validateMetadata\n      })\n    }\n\n    if (data.tags != null) {\n      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags)\n      const mergedTags = new Map<string, Tag | TagOptions>(tags)\n\n      for (const [key, value] of tagsEntries) {\n        if (value == null) {\n          mergedTags.delete(key)\n        } else {\n          mergedTags.set(key, value)\n        }\n      }\n\n      tags = createSortedMap([...mergedTags.entries()], {\n        validate: validateTag,\n        map: mapTag\n      })\n    }\n\n    if (data.peerRecordEnvelope != null) {\n      peerRecordEnvelope = data.peerRecordEnvelope\n    }\n  }\n\n  let publicKey: Uint8Array | undefined\n\n  if (existingPeer?.id.publicKey != null) {\n    publicKey = publicKeyToProtobuf(existingPeer.id.publicKey)\n  } else if (data.publicKey != null) {\n    publicKey = publicKeyToProtobuf(data.publicKey)\n  } else if (peerId.publicKey != null) {\n    publicKey = publicKeyToProtobuf(peerId.publicKey)\n  }\n\n  const output: PeerPB = {\n    addresses: await dedupeFilterAndSortAddresses(\n      peerId,\n      options.addressFilter ?? (async () => true),\n      addresses,\n      options.existingPeer?.peerPB.addresses\n    ),\n    protocols: [...protocols.values()].sort((a, b) => {\n      return a.localeCompare(b)\n    }),\n    metadata,\n    tags,\n    publicKey,\n    peerRecordEnvelope\n  }\n\n  // add observed addresses to multiaddrs\n  output.addresses.forEach(addr => {\n    addr.observed = options.existingPeer?.peerPB.addresses?.find(addr => uint8ArrayEquals(addr.multiaddr, addr.multiaddr))?.observed ?? Date.now()\n  })\n\n  // Ed25519 and secp256k1 have their public key embedded in them so no need to duplicate it\n  if (peerId.type !== 'RSA') {\n    delete output.publicKey\n  }\n\n  return output\n}\n\ninterface CreateSortedMapOptions <V, R = V> {\n  validate(key: string, value: V): void\n  map?(key: string, value: V): R\n}\n\n/**\n * In JS maps are ordered by insertion order so create a new map with the\n * keys inserted in alphabetical order.\n */\nfunction createSortedMap <V, R = V> (entries: Array<[string, V | undefined]>, options: CreateSortedMapOptions<V, R>): Map<string, R> {\n  const output = new Map()\n\n  for (const [key, value] of entries) {\n    if (value == null) {\n      continue\n    }\n\n    options.validate(key, value)\n  }\n\n  for (const [key, value] of entries.sort(([a], [b]) => {\n    return a.localeCompare(b)\n  })) {\n    if (value != null) {\n      output.set(key, options.map?.(key, value) ?? value)\n    }\n  }\n\n  return output\n}\n\nfunction validateMetadata (key: string, value: Uint8Array): void {\n  if (typeof key !== 'string') {\n    throw new InvalidParametersError('Metadata key must be a string')\n  }\n\n  if (!(value instanceof Uint8Array)) {\n    throw new InvalidParametersError('Metadata value must be a Uint8Array')\n  }\n}\n\nfunction validateTag (key: string, tag: TagOptions): void {\n  if (typeof key !== 'string') {\n    throw new InvalidParametersError('Tag name must be a string')\n  }\n\n  if (tag.value != null) {\n    if (parseInt(`${tag.value}`, 10) !== tag.value) {\n      throw new InvalidParametersError('Tag value must be an integer')\n    }\n\n    if (tag.value < 0 || tag.value > 100) {\n      throw new InvalidParametersError('Tag value must be between 0-100')\n    }\n  }\n\n  if (tag.ttl != null) {\n    if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) {\n      throw new InvalidParametersError('Tag ttl must be an integer')\n    }\n\n    if (tag.ttl < 0) {\n      throw new InvalidParametersError('Tag ttl must be between greater than 0')\n    }\n  }\n}\n\nfunction mapTag (key: string, tag: any): Tag {\n  let expiry: bigint | undefined\n\n  if (tag.expiry != null) {\n    expiry = tag.expiry\n  }\n\n  if (tag.ttl != null) {\n    expiry = BigInt(Date.now() + Number(tag.ttl))\n  }\n\n  return {\n    value: tag.value ?? 0,\n    expiry\n  }\n}\n", "import { NotFoundError } from '@libp2p/interface'\nimport { peerIdFromCID } from '@libp2p/peer-id'\nimport mortice, { type Mortice } from 'mortice'\nimport { base32 } from 'multiformats/bases/base32'\nimport { CID } from 'multiformats/cid'\nimport { MAX_ADDRESS_AGE, MAX_PEER_AGE } from './constants.js'\nimport { Peer as PeerPB } from './pb/peer.js'\nimport { bytesToPeer, pbToPeer } from './utils/bytes-to-peer.js'\nimport { peerEquals } from './utils/peer-equals.js'\nimport { NAMESPACE_COMMON, peerIdToDatastoreKey } from './utils/peer-id-to-datastore-key.js'\nimport { toPeerPB } from './utils/to-peer-pb.js'\nimport type { AddressFilter, PersistentPeerStoreComponents, PersistentPeerStoreInit } from './index.js'\nimport type { PeerUpdate as PeerUpdateExternal, PeerId, Peer, PeerData, PeerQuery, Logger } from '@libp2p/interface'\nimport type { Datastore, Key, Query } from 'interface-datastore'\n\n/**\n * Event detail emitted when peer data changes\n */\nexport interface PeerUpdate extends PeerUpdateExternal {\n  updated: boolean\n}\n\nexport interface ExistingPeer {\n  peerPB: PeerPB\n  peer: Peer\n}\n\nfunction keyToPeerId (key: Key): PeerId {\n  // /peers/${peer-id-as-libp2p-key-cid-string-in-base-32}\n  const base32Str = key.toString().split('/')[2]\n  const buf = CID.parse(base32Str, base32)\n\n  return peerIdFromCID(buf)\n}\n\nfunction decodePeer (key: Key, value: Uint8Array, maxAddressAge: number): Peer {\n  const peerId = keyToPeerId(key)\n\n  return bytesToPeer(peerId, value, maxAddressAge)\n}\n\nfunction mapQuery (query: PeerQuery, maxAddressAge: number): Query {\n  return {\n    prefix: NAMESPACE_COMMON,\n    filters: (query.filters ?? []).map(fn => ({ key, value }) => {\n      return fn(decodePeer(key, value, maxAddressAge))\n    }),\n    orders: (query.orders ?? []).map(fn => (a, b) => {\n      return fn(decodePeer(a.key, a.value, maxAddressAge), decodePeer(b.key, b.value, maxAddressAge))\n    })\n  }\n}\n\nexport class PersistentStore {\n  private readonly peerId: PeerId\n  private readonly datastore: Datastore\n  public readonly lock: Mortice\n  private readonly addressFilter?: AddressFilter\n  private readonly log: Logger\n  private readonly maxAddressAge: number\n  private readonly maxPeerAge: number\n\n  constructor (components: PersistentPeerStoreComponents, init: PersistentPeerStoreInit = {}) {\n    this.log = components.logger.forComponent('libp2p:peer-store')\n    this.peerId = components.peerId\n    this.datastore = components.datastore\n    this.addressFilter = init.addressFilter\n    this.lock = mortice({\n      name: 'peer-store',\n      singleProcess: true\n    })\n    this.maxAddressAge = init.maxAddressAge ?? MAX_ADDRESS_AGE\n    this.maxPeerAge = init.maxPeerAge ?? MAX_PEER_AGE\n  }\n\n  async has (peerId: PeerId): Promise<boolean> {\n    try {\n      await this.load(peerId)\n\n      return true\n    } catch (err: any) {\n      if (err.name !== 'NotFoundError') {\n        throw err\n      }\n    }\n\n    return false\n  }\n\n  async delete (peerId: PeerId): Promise<void> {\n    if (this.peerId.equals(peerId)) {\n      return\n    }\n\n    await this.datastore.delete(peerIdToDatastoreKey(peerId))\n  }\n\n  async load (peerId: PeerId): Promise<Peer> {\n    const key = peerIdToDatastoreKey(peerId)\n    const buf = await this.datastore.get(key)\n    const peer = PeerPB.decode(buf)\n\n    if (this.#peerIsExpired(peerId, peer)) {\n      await this.datastore.delete(key)\n      throw new NotFoundError()\n    }\n\n    return pbToPeer(peerId, peer, this.peerId.equals(peerId) ? Infinity : this.maxAddressAge)\n  }\n\n  async save (peerId: PeerId, data: PeerData): Promise<PeerUpdate> {\n    const existingPeer = await this.#findExistingPeer(peerId)\n\n    const peerPb: PeerPB = await toPeerPB(peerId, data, 'patch', {\n      addressFilter: this.addressFilter\n    })\n\n    return this.#saveIfDifferent(peerId, peerPb, existingPeer)\n  }\n\n  async patch (peerId: PeerId, data: Partial<PeerData>): Promise<PeerUpdate> {\n    const existingPeer = await this.#findExistingPeer(peerId)\n\n    const peerPb: PeerPB = await toPeerPB(peerId, data, 'patch', {\n      addressFilter: this.addressFilter,\n      existingPeer\n    })\n\n    return this.#saveIfDifferent(peerId, peerPb, existingPeer)\n  }\n\n  async merge (peerId: PeerId, data: PeerData): Promise<PeerUpdate> {\n    const existingPeer = await this.#findExistingPeer(peerId)\n\n    const peerPb: PeerPB = await toPeerPB(peerId, data, 'merge', {\n      addressFilter: this.addressFilter,\n      existingPeer\n    })\n\n    return this.#saveIfDifferent(peerId, peerPb, existingPeer)\n  }\n\n  async * all (query?: PeerQuery): AsyncGenerator<Peer, void, unknown> {\n    for await (const { key, value } of this.datastore.query(mapQuery(query ?? {}, this.maxAddressAge))) {\n      const peerId = keyToPeerId(key)\n\n      // skip self peer if present\n      if (peerId.equals(this.peerId)) {\n        continue\n      }\n\n      const peer = PeerPB.decode(value)\n\n      // remove expired peer\n      if (this.#peerIsExpired(peerId, peer)) {\n        await this.datastore.delete(key)\n        continue\n      }\n\n      yield pbToPeer(peerId, peer, this.peerId.equals(peerId) ? Infinity : this.maxAddressAge)\n    }\n  }\n\n  async #findExistingPeer (peerId: PeerId): Promise<ExistingPeer | undefined> {\n    try {\n      const key = peerIdToDatastoreKey(peerId)\n      const buf = await this.datastore.get(key)\n      const peerPB = PeerPB.decode(buf)\n\n      // remove expired peer\n      if (this.#peerIsExpired(peerId, peerPB)) {\n        await this.datastore.delete(key)\n        throw new NotFoundError()\n      }\n\n      return {\n        peerPB,\n        peer: bytesToPeer(peerId, buf, this.maxAddressAge)\n      }\n    } catch (err: any) {\n      if (err.name !== 'NotFoundError') {\n        this.log.error('invalid peer data found in peer store - %e', err)\n      }\n    }\n  }\n\n  async #saveIfDifferent (peerId: PeerId, peer: PeerPB, existingPeer?: ExistingPeer): Promise<PeerUpdate> {\n    // record last update\n    peer.updated = Date.now()\n    const buf = PeerPB.encode(peer)\n\n    await this.datastore.put(peerIdToDatastoreKey(peerId), buf)\n\n    return {\n      peer: bytesToPeer(peerId, buf, this.maxAddressAge),\n      previous: existingPeer?.peer,\n      updated: existingPeer == null || !peerEquals(peer, existingPeer.peerPB)\n    }\n  }\n\n  #peerIsExpired (peerId: PeerId, peer: PeerPB): boolean {\n    if (peer.updated == null) {\n      return true\n    }\n\n    if (this.peerId.equals(peerId)) {\n      return false\n    }\n\n    const expired = peer.updated < (Date.now() - this.maxPeerAge)\n    const minAddressObserved = Date.now() - this.maxAddressAge\n    const addrs = peer.addresses.filter(addr => {\n      return addr.observed != null && addr.observed > minAddressObserved\n    })\n\n    return expired && addrs.length === 0\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * The peer store is where libp2p stores data about the peers it has encountered on the network.\n */\n\nimport { peerIdFromCID } from '@libp2p/peer-id'\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record'\nimport all from 'it-all'\nimport { PersistentStore, type PeerUpdate } from './store.js'\nimport type { ComponentLogger, Libp2pEvents, Logger, TypedEventTarget, PeerId, PeerStore, Peer, PeerData, PeerQuery } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Datastore } from 'interface-datastore'\n\nexport interface PersistentPeerStoreComponents {\n  peerId: PeerId\n  datastore: Datastore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\n/**\n * Return true to allow storing the passed multiaddr for the passed peer\n */\nexport interface AddressFilter {\n  (peerId: PeerId, multiaddr: Multiaddr): Promise<boolean> | boolean\n}\n\nexport interface PersistentPeerStoreInit {\n  /**\n   * Used to remove multiaddrs of peers before storing them. The default is to\n   * store all addresses\n   */\n  addressFilter?: AddressFilter\n\n  /**\n   * The multiaddrs for a given peer will expire after this number of ms after\n   * which they must be re-fetched using the peer routing.\n   *\n   * Defaults to one hour.\n   *\n   * @default 3_600_000\n   */\n  maxAddressAge?: number\n\n  /**\n   * Any peer without multiaddrs that has not been updated after this number of\n   * ms will be evicted from the peer store.\n   *\n   * Defaults to six hours.\n   *\n   * @default 21_600_000\n   */\n  maxPeerAge?: number\n}\n\n/**\n * An implementation of PeerStore that stores data in a Datastore\n */\nclass PersistentPeerStore implements PeerStore {\n  private readonly store: PersistentStore\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly peerId: PeerId\n  private readonly log: Logger\n\n  constructor (components: PersistentPeerStoreComponents, init: PersistentPeerStoreInit = {}) {\n    this.log = components.logger.forComponent('libp2p:peer-store')\n    this.events = components.events\n    this.peerId = components.peerId\n    this.store = new PersistentStore(components, init)\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/peer-store'\n\n  async forEach (fn: (peer: Peer,) => void, query?: PeerQuery): Promise<void> {\n    this.log.trace('forEach await read lock')\n    const release = await this.store.lock.readLock()\n    this.log.trace('forEach got read lock')\n\n    try {\n      for await (const peer of this.store.all(query)) {\n        fn(peer)\n      }\n    } finally {\n      this.log.trace('forEach release read lock')\n      release()\n    }\n  }\n\n  async all (query?: PeerQuery): Promise<Peer[]> {\n    this.log.trace('all await read lock')\n    const release = await this.store.lock.readLock()\n    this.log.trace('all got read lock')\n\n    try {\n      return await all(this.store.all(query))\n    } finally {\n      this.log.trace('all release read lock')\n      release()\n    }\n  }\n\n  async delete (peerId: PeerId): Promise<void> {\n    this.log.trace('delete await write lock')\n    const release = await this.store.lock.writeLock()\n    this.log.trace('delete got write lock')\n\n    try {\n      await this.store.delete(peerId)\n    } finally {\n      this.log.trace('delete release write lock')\n      release()\n    }\n  }\n\n  async has (peerId: PeerId): Promise<boolean> {\n    this.log.trace('has await read lock')\n    const release = await this.store.lock.readLock()\n    this.log.trace('has got read lock')\n\n    try {\n      return await this.store.has(peerId)\n    } finally {\n      this.log.trace('has release read lock')\n      release()\n    }\n  }\n\n  async get (peerId: PeerId): Promise<Peer> {\n    this.log.trace('get await read lock')\n    const release = await this.store.lock.readLock()\n    this.log.trace('get got read lock')\n\n    try {\n      return await this.store.load(peerId)\n    } finally {\n      this.log.trace('get release read lock')\n      release()\n    }\n  }\n\n  async save (id: PeerId, data: PeerData): Promise<Peer> {\n    this.log.trace('save await write lock')\n    const release = await this.store.lock.writeLock()\n    this.log.trace('save got write lock')\n\n    try {\n      const result = await this.store.save(id, data)\n\n      this.#emitIfUpdated(id, result)\n\n      return result.peer\n    } finally {\n      this.log.trace('save release write lock')\n      release()\n    }\n  }\n\n  async patch (id: PeerId, data: PeerData): Promise<Peer> {\n    this.log.trace('patch await write lock')\n    const release = await this.store.lock.writeLock()\n    this.log.trace('patch got write lock')\n\n    try {\n      const result = await this.store.patch(id, data)\n\n      this.#emitIfUpdated(id, result)\n\n      return result.peer\n    } finally {\n      this.log.trace('patch release write lock')\n      release()\n    }\n  }\n\n  async merge (id: PeerId, data: PeerData): Promise<Peer> {\n    this.log.trace('merge await write lock')\n    const release = await this.store.lock.writeLock()\n    this.log.trace('merge got write lock')\n\n    try {\n      const result = await this.store.merge(id, data)\n\n      this.#emitIfUpdated(id, result)\n\n      return result.peer\n    } finally {\n      this.log.trace('merge release write lock')\n      release()\n    }\n  }\n\n  async consumePeerRecord (buf: Uint8Array, expectedPeer?: PeerId): Promise<boolean> {\n    const envelope = await RecordEnvelope.openAndCertify(buf, PeerRecord.DOMAIN)\n    const peerId = peerIdFromCID(envelope.publicKey.toCID())\n\n    if (expectedPeer?.equals(peerId) === false) {\n      this.log('envelope peer id was not the expected peer id - expected: %p received: %p', expectedPeer, peerId)\n      return false\n    }\n\n    const peerRecord = PeerRecord.createFromProtobuf(envelope.payload)\n    let peer: Peer | undefined\n\n    try {\n      peer = await this.get(peerId)\n    } catch (err: any) {\n      if (err.name !== 'NotFoundError') {\n        throw err\n      }\n    }\n\n    // ensure seq is greater than, or equal to, the last received\n    if (peer?.peerRecordEnvelope != null) {\n      const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope)\n      const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload)\n\n      if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n        this.log('sequence number was lower or equal to existing sequence number - stored: %d received: %d', storedRecord.seqNumber, peerRecord.seqNumber)\n        return false\n      }\n    }\n\n    await this.patch(peerRecord.peerId, {\n      peerRecordEnvelope: buf,\n      addresses: peerRecord.multiaddrs.map(multiaddr => ({\n        isCertified: true,\n        multiaddr\n      }))\n    })\n\n    return true\n  }\n\n  #emitIfUpdated (id: PeerId, result: PeerUpdate): void {\n    if (!result.updated) {\n      return\n    }\n\n    if (this.peerId.equals(id)) {\n      this.events.safeDispatchEvent('self:peer:update', { detail: result })\n    } else {\n      this.events.safeDispatchEvent('peer:update', { detail: result })\n    }\n  }\n}\n\nexport function persistentPeerStore (components: PersistentPeerStoreComponents, init: PersistentPeerStoreInit = {}): PeerStore {\n  return new PersistentPeerStore(components, init)\n}\n", "export class OpenFailedError extends Error {\n  static name = 'OpenFailedError'\n  static code = 'ERR_OPEN_FAILED'\n  name = OpenFailedError.name\n  code = OpenFailedError.code\n\n  constructor (message = 'Open failed') {\n    super(message)\n  }\n}\n\nexport class CloseFailedError extends Error {\n  static name = 'CloseFailedError'\n  static code = 'ERR_CLOSE_FAILED'\n  name = CloseFailedError.name\n  code = CloseFailedError.code\n\n  constructor (message = 'Close failed') {\n    super(message)\n  }\n}\n\nexport class PutFailedError extends Error {\n  static name = 'PutFailedError'\n  static code = 'ERR_PUT_FAILED'\n  name = PutFailedError.name\n  code = PutFailedError.code\n\n  constructor (message = 'Put failed') {\n    super(message)\n  }\n}\n\nexport class GetFailedError extends Error {\n  static name = 'GetFailedError'\n  static code = 'ERR_GET_FAILED'\n  name = GetFailedError.name\n  code = GetFailedError.code\n\n  constructor (message = 'Get failed') {\n    super(message)\n  }\n}\n\nexport class DeleteFailedError extends Error {\n  static name = 'DeleteFailedError'\n  static code = 'ERR_DELETE_FAILED'\n  name = DeleteFailedError.name\n  code = DeleteFailedError.code\n\n  constructor (message = 'Delete failed') {\n    super(message)\n  }\n}\n\nexport class HasFailedError extends Error {\n  static name = 'HasFailedError'\n  static code = 'ERR_HAS_FAILED'\n  name = HasFailedError.name\n  code = HasFailedError.code\n\n  constructor (message = 'Has failed') {\n    super(message)\n  }\n}\n\nexport class NotFoundError extends Error {\n  static name = 'NotFoundError'\n  static code = 'ERR_NOT_FOUND'\n  name = NotFoundError.name\n  code = NotFoundError.code\n\n  constructor (message = 'Not Found') {\n    super(message)\n  }\n}\n\nexport class AbortError extends Error {\n  static name = 'AbortError'\n  static code = 'ERR_ABORTED'\n  name = AbortError.name\n  code = AbortError.code\n\n  constructor (message = 'Aborted') {\n    super(message)\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Filter values out of an (async)iterable\n *\n * @example\n *\n * ```javascript\n * import all from 'it-all'\n * import filter from 'it-filter'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const fn = (val, index) => val > 2 // Return boolean to keep item\n *\n * const arr = all(filter(values, fn))\n *\n * console.info(arr) // 3, 4\n * ```\n *\n * Async sources and filter functions must be awaited:\n *\n * ```javascript\n * import all from 'it-all'\n * import filter from 'it-filter'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const fn = async val => (val, index) > 2 // Return boolean or promise of boolean to keep item\n *\n * const arr = await all(filter(values, fn))\n *\n * console.info(arr) // 3, 4\n * ```\n */\n\nimport peek from 'it-peekable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Filters the passed (async) iterable by using the filter function\n */\nfunction filter <T> (source: Iterable<T>, fn: (val: T, index: number) => Promise<boolean>): AsyncGenerator<T, void, undefined>\nfunction filter <T> (source: Iterable<T>, fn: (val: T, index: number) => boolean): Generator<T, void, undefined>\nfunction filter <T> (source: Iterable<T> | AsyncIterable<T>, fn: (val: T, index: number) => boolean | Promise<boolean>): AsyncGenerator<T, void, undefined>\nfunction filter <T> (source: Iterable<T> | AsyncIterable<T>, fn: (val: T, index: number) => boolean | Promise<boolean>): Generator<T, void, undefined> | AsyncGenerator<T, void, undefined> {\n  let index = 0\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const entry of source) {\n        if (await fn(entry, index++)) {\n          yield entry\n        }\n      }\n    })()\n  }\n\n  // if mapping function returns a promise we have to return an async generator\n  const peekable = peek(source)\n  const { value, done } = peekable.next()\n\n  if (done === true) {\n    return (function * () {}())\n  }\n\n  const res = fn(value, index++)\n\n  // @ts-expect-error .then is not present on O\n  if (typeof res.then === 'function') {\n    return (async function * () {\n      if (await res) {\n        yield value\n      }\n\n      for await (const entry of peekable) {\n        if (await fn(entry, index++)) {\n          yield entry\n        }\n      }\n    })()\n  }\n\n  const func = fn as (val: T, index: number) => boolean\n\n  return (function * () {\n    if (res === true) {\n      yield value\n    }\n\n    for (const entry of peekable) {\n      if (func(entry, index++)) {\n        yield entry\n      }\n    }\n  })()\n}\n\nexport default filter\n", "/**\n * @packageDocumentation\n *\n * Consumes all values from an (async)iterable and returns them sorted by the passed sort function.\n *\n * @example\n *\n * ```javascript\n * import sort from 'it-sort'\n * import all from 'it-all'\n *\n * const sorter = (a, b) => {\n *   return a.localeCompare(b)\n * }\n *\n * // This can also be an iterator, generator, etc\n * const values = ['foo', 'bar']\n *\n * const arr = all(sort(values, sorter))\n *\n * console.info(arr) // 'bar', 'foo'\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import sort from 'it-sort'\n * import all from 'it-all'\n *\n * const sorter = (a, b) => {\n *   return a.localeCompare(b)\n * }\n *\n * const values = async function * () {\n *   yield * ['foo', 'bar']\n * }\n *\n * const arr = await all(sort(values, sorter))\n *\n * console.info(arr) // 'bar', 'foo'\n * ```\n */\n\nimport all from 'it-all'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\nexport interface CompareFunction<T> {\n  (a: T, b: T): number\n}\n\n/**\n * Collects all values from an async iterator, sorts them\n * using the passed function and yields them\n */\nfunction sort <T> (source: Iterable<T>, sorter: CompareFunction<T>): Generator<T, void, undefined>\nfunction sort <T> (source: Iterable<T> | AsyncIterable<T>, sorter: CompareFunction<T>): AsyncGenerator<T, void, undefined>\nfunction sort <T> (source: Iterable<T> | AsyncIterable<T>, sorter: CompareFunction<T>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      const arr = await all(source)\n\n      yield * arr.sort(sorter)\n    })()\n  }\n\n  return (function * () {\n    const arr = all(source)\n\n    yield * arr.sort(sorter)\n  })()\n}\n\nexport default sort\n", "/**\n * @packageDocumentation\n *\n * For when you only want a few values out of an (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import take from 'it-take'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const arr = all(take(values, 2))\n *\n * console.info(arr) // 0, 1\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import take from 'it-take'\n * import all from 'it-all'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = await all(take(values(), 2))\n *\n * console.info(arr) // 0, 1\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Stop iteration after n items have been received\n */\nfunction take <T> (source: Iterable<T>, limit: number): Generator<T, void, undefined>\nfunction take <T> (source: Iterable<T> | AsyncIterable<T>, limit: number): AsyncGenerator<T, void, undefined>\nfunction take <T> (source: Iterable<T> | AsyncIterable<T>, limit: number): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      let items = 0\n\n      if (limit < 1) {\n        return\n      }\n\n      for await (const entry of source) {\n        yield entry\n\n        items++\n\n        if (items === limit) {\n          return\n        }\n      }\n    })()\n  }\n\n  return (function * () {\n    let items = 0\n\n    if (limit < 1) {\n      return\n    }\n\n    for (const entry of source) {\n      yield entry\n\n      items++\n\n      if (items === limit) {\n        return\n      }\n    }\n  })()\n}\n\nexport default take\n", "import drain from 'it-drain'\nimport filter from 'it-filter'\nimport sort from 'it-sort'\nimport take from 'it-take'\nimport type { Batch, Datastore, Key, KeyQuery, Pair, Query } from 'interface-datastore'\nimport type { AbortOptions, Await, AwaitIterable } from 'interface-store'\n\nexport class BaseDatastore implements Datastore {\n  put (key: Key, val: Uint8Array, options?: AbortOptions): Await<Key> {\n    return Promise.reject(new Error('.put is not implemented'))\n  }\n\n  get (key: Key, options?: AbortOptions): Await<Uint8Array> {\n    return Promise.reject(new Error('.get is not implemented'))\n  }\n\n  has (key: Key, options?: AbortOptions): Await<boolean> {\n    return Promise.reject(new Error('.has is not implemented'))\n  }\n\n  delete (key: Key, options?: AbortOptions): Await<void> {\n    return Promise.reject(new Error('.delete is not implemented'))\n  }\n\n  async * putMany (source: AwaitIterable<Pair>, options: AbortOptions = {}): AwaitIterable<Key> {\n    for await (const { key, value } of source) {\n      await this.put(key, value, options)\n      yield key\n    }\n  }\n\n  async * getMany (source: AwaitIterable<Key>, options: AbortOptions = {}): AwaitIterable<Pair> {\n    for await (const key of source) {\n      yield {\n        key,\n        value: await this.get(key, options)\n      }\n    }\n  }\n\n  async * deleteMany (source: AwaitIterable<Key>, options: AbortOptions = {}): AwaitIterable<Key> {\n    for await (const key of source) {\n      await this.delete(key, options)\n      yield key\n    }\n  }\n\n  batch (): Batch {\n    let puts: Pair[] = []\n    let dels: Key[] = []\n\n    return {\n      put (key, value) {\n        puts.push({ key, value })\n      },\n\n      delete (key) {\n        dels.push(key)\n      },\n      commit: async (options) => {\n        await drain(this.putMany(puts, options))\n        puts = []\n        await drain(this.deleteMany(dels, options))\n        dels = []\n      }\n    }\n  }\n\n  /**\n   * Extending classes should override `query` or implement this method\n   */\n  // eslint-disable-next-line require-yield\n  async * _all (q: Query, options?: AbortOptions): AwaitIterable<Pair> {\n    throw new Error('._all is not implemented')\n  }\n\n  /**\n   * Extending classes should override `queryKeys` or implement this method\n   */\n  // eslint-disable-next-line require-yield\n  async * _allKeys (q: KeyQuery, options?: AbortOptions): AwaitIterable<Key> {\n    throw new Error('._allKeys is not implemented')\n  }\n\n  query (q: Query, options?: AbortOptions): AwaitIterable<Pair> {\n    let it = this._all(q, options)\n\n    if (q.prefix != null) {\n      const prefix = q.prefix\n      it = filter(it, (e) => e.key.toString().startsWith(prefix))\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sort(it, f), it)\n    }\n\n    if (q.offset != null) {\n      let i = 0\n      const offset = q.offset\n      it = filter(it, () => i++ >= offset)\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit)\n    }\n\n    return it\n  }\n\n  queryKeys (q: KeyQuery, options?: AbortOptions): AwaitIterable<Key> {\n    let it = this._allKeys(q, options)\n\n    if (q.prefix != null) {\n      const prefix = q.prefix\n      it = filter(it, (key) =>\n        key.toString().startsWith(prefix)\n      )\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sort(it, f), it)\n    }\n\n    if (q.offset != null) {\n      const offset = q.offset\n      let i = 0\n      it = filter(it, () => i++ >= offset)\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit)\n    }\n\n    return it\n  }\n}\n", "import { Key } from 'interface-datastore/key'\nimport { NotFoundError } from 'interface-store'\nimport { BaseDatastore } from './base.js'\nimport type { Pair } from 'interface-datastore'\nimport type { Await, AwaitIterable } from 'interface-store'\n\nexport class MemoryDatastore extends BaseDatastore {\n  private readonly data: Map<string, Uint8Array>\n\n  constructor () {\n    super()\n\n    this.data = new Map()\n  }\n\n  put (key: Key, val: Uint8Array): Await<Key> { // eslint-disable-line require-await\n    this.data.set(key.toString(), val)\n\n    return key\n  }\n\n  get (key: Key): Await<Uint8Array> {\n    const result = this.data.get(key.toString())\n\n    if (result == null) {\n      throw new NotFoundError()\n    }\n\n    return result\n  }\n\n  has (key: Key): Await<boolean> { // eslint-disable-line require-await\n    return this.data.has(key.toString())\n  }\n\n  delete (key: Key): Await<void> { // eslint-disable-line require-await\n    this.data.delete(key.toString())\n  }\n\n  * _all (): AwaitIterable<Pair> {\n    for (const [key, value] of this.data.entries()) {\n      yield { key: new Key(key), value }\n    }\n  }\n\n  * _allKeys (): AwaitIterable<Key> {\n    for (const key of this.data.keys()) {\n      yield new Key(key)\n    }\n  }\n}\n", "import type { Startable } from '@libp2p/interface'\n\nexport interface DebouncedFunction extends Startable {\n  (): void\n}\n\n/**\n * Returns a function wrapper that will only call the passed function once\n *\n * Important - the passed function should not throw or reject\n */\nexport function debounce (func: () => void | Promise<void>, wait: number): DebouncedFunction {\n  let timeout: ReturnType<typeof setTimeout> | undefined\n\n  const output = function (): void {\n    const later = function (): void {\n      timeout = undefined\n      void func()\n    }\n\n    clearTimeout(timeout)\n    timeout = setTimeout(later, wait)\n  }\n  output.start = () => {}\n  output.stop = () => {\n    clearTimeout(timeout)\n  }\n\n  return output\n}\n", "import { isIPv4, isIPv6 } from '@chainsafe/is-ip'\nimport { Netmask } from 'netmask'\n\nconst PRIVATE_IP_RANGES = [\n  '0.0.0.0/8',\n  '10.0.0.0/8',\n  '100.64.0.0/10',\n  '127.0.0.0/8',\n  '169.254.0.0/16',\n  '172.16.0.0/12',\n  '192.0.0.0/24',\n  '192.0.0.0/29',\n  '192.0.0.8/32',\n  '192.0.0.9/32',\n  '192.0.0.10/32',\n  '192.0.0.170/32',\n  '192.0.0.171/32',\n  '192.0.2.0/24',\n  '192.31.196.0/24',\n  '192.52.193.0/24',\n  '192.88.99.0/24',\n  '192.168.0.0/16',\n  '192.175.48.0/24',\n  '198.18.0.0/15',\n  '198.51.100.0/24',\n  '203.0.113.0/24',\n  '240.0.0.0/4',\n  '255.255.255.255/32'\n]\n\nconst NETMASK_RANGES = PRIVATE_IP_RANGES.map(ipRange => new Netmask(ipRange))\n\nfunction ipv4Check (ipAddr: string): boolean {\n  for (const r of NETMASK_RANGES) {\n    if (r.contains(ipAddr)) return true\n  }\n\n  return false\n}\n\nfunction isIpv4MappedIpv6 (ipAddr: string): boolean {\n  return /^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(ipAddr)\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc4291#section-2.5.5.2\n */\nfunction ipv4MappedIpv6Check (ipAddr: string): boolean {\n  const parts = ipAddr.split(':')\n\n  if (parts.length < 2) {\n    return false\n  }\n\n  const octet34 = parts[parts.length - 1].padStart(4, '0')\n  const octet12 = parts[parts.length - 2].padStart(4, '0')\n\n  const ip4 = `${parseInt(octet12.substring(0, 2), 16)}.${parseInt(octet12.substring(2), 16)}.${parseInt(octet34.substring(0, 2), 16)}.${parseInt(octet34.substring(2), 16)}`\n\n  return ipv4Check(ip4)\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc4291#section-2.2 example 3\n */\nfunction isIpv4EmbeddedIpv6 (ipAddr: string): boolean {\n  return /^::ffff:([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/.test(ipAddr)\n}\n\nfunction ipv4EmbeddedIpv6Check (ipAddr: string): boolean {\n  const parts = ipAddr.split(':')\n  const ip4 = parts[parts.length - 1]\n\n  return ipv4Check(ip4)\n}\n\nfunction ipv6Check (ipAddr: string): boolean {\n  return /^::$/.test(ipAddr) ||\n    /^::1$/.test(ipAddr) ||\n    /^64:ff9b::([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/.test(ipAddr) ||\n    /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n    /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n    /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n    /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n    /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n    /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ipAddr) ||\n    /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ipAddr) ||\n    /^ff([0-9a-fA-F]{2,2}):/i.test(ipAddr)\n}\n\nexport function isPrivateIp (ip: string): boolean | undefined {\n  if (isIPv4(ip)) return ipv4Check(ip)\n  else if (isIpv4MappedIpv6(ip)) return ipv4MappedIpv6Check(ip)\n  else if (isIpv4EmbeddedIpv6(ip)) return ipv4EmbeddedIpv6Check(ip)\n  else if (isIPv6(ip)) return ipv6Check(ip)\n  else return undefined\n}\n", "import { isPrivateIp } from '@libp2p/utils/private-ip'\nimport { multiaddr, protocols } from '@multiformats/multiaddr'\nimport type { AddressManagerComponents, AddressManagerInit } from './index.js'\nimport type { Logger } from '@libp2p/interface'\nimport type { NodeAddress } from '@libp2p/interface-internal'\nimport type { Multiaddr, StringTuple } from '@multiformats/multiaddr'\n\nconst MAX_DATE = 8_640_000_000_000_000\n\nexport const defaultValues = {\n  maxObservedAddresses: 10\n}\n\ninterface DNSMapping {\n  domain: string\n  verified: boolean\n  expires: number\n  lastVerified?: number\n}\n\nconst CODEC_TLS = 0x01c0\nconst CODEC_SNI = 0x01c1\nconst CODEC_DNS = 0x35\nconst CODEC_DNS4 = 0x36\nconst CODEC_DNS6 = 0x37\nconst CODEC_DNSADDR = 0x38\n\nexport class DNSMappings {\n  private readonly log: Logger\n  private readonly mappings: Map<string, DNSMapping>\n\n  constructor (components: AddressManagerComponents, init: AddressManagerInit = {}) {\n    this.log = components.logger.forComponent('libp2p:address-manager:dns-mappings')\n    this.mappings = new Map()\n  }\n\n  has (ma: Multiaddr): boolean {\n    const host = this.findHost(ma)\n\n    for (const mapping of this.mappings.values()) {\n      if (mapping.domain === host) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  add (domain: string, addresses: string[]): void {\n    addresses.forEach(ip => {\n      this.log('add DNS mapping %s to %s', ip, domain)\n      // we are only confident if this is an local domain mapping, otherwise\n      // we will require external validation\n      const verified = isPrivateIp(ip) === true\n\n      this.mappings.set(ip, {\n        domain,\n        verified,\n        expires: verified ? MAX_DATE - Date.now() : 0,\n        lastVerified: verified ? MAX_DATE - Date.now() : undefined\n      })\n    })\n  }\n\n  remove (ma: Multiaddr): boolean {\n    const host = this.findHost(ma)\n    let wasConfident = false\n\n    for (const [ip, mapping] of this.mappings.entries()) {\n      if (mapping.domain === host) {\n        this.log('removing %s to %s DNS mapping %e', ip, mapping.domain, new Error('where'))\n        this.mappings.delete(ip)\n        wasConfident = wasConfident || mapping.verified\n      }\n    }\n\n    return wasConfident\n  }\n\n  getAll (addresses: NodeAddress[]): NodeAddress[] {\n    const dnsMappedAddresses: NodeAddress[] = []\n\n    for (let i = 0; i < addresses.length; i++) {\n      const address = addresses[i]\n      const tuples = address.multiaddr.stringTuples()\n      const host = tuples[0][1]\n\n      if (host == null) {\n        continue\n      }\n\n      for (const [ip, mapping] of this.mappings.entries()) {\n        if (host !== ip) {\n          continue\n        }\n\n        // insert SNI tuple after TLS tuple, if one is present\n        const mappedIp = this.maybeAddSNITuple(tuples, mapping.domain)\n\n        if (mappedIp) {\n          // remove the address and replace it with the version that includes\n          // the SNI tuple\n          addresses.splice(i, 1)\n          i--\n\n          dnsMappedAddresses.push({\n            multiaddr: multiaddr(`/${\n              tuples.map(tuple => {\n                return [\n                  protocols(tuple[0]).name,\n                  tuple[1]\n                ].join('/')\n              }).join('/')\n            }`),\n            verified: mapping.verified,\n            type: 'dns-mapping',\n            expires: mapping.expires,\n            lastVerified: mapping.lastVerified\n          })\n        }\n      }\n    }\n\n    return dnsMappedAddresses\n  }\n\n  private maybeAddSNITuple (tuples: StringTuple[], domain: string): boolean {\n    for (let j = 0; j < tuples.length; j++) {\n      if (tuples[j][0] === CODEC_TLS && tuples[j + 1]?.[0] !== CODEC_SNI) {\n        tuples.splice(j + 1, 0, [CODEC_SNI, domain])\n        return true\n      }\n    }\n\n    return false\n  }\n\n  confirm (ma: Multiaddr, ttl: number): boolean {\n    const host = this.findHost(ma)\n    let startingConfidence = false\n\n    for (const [ip, mapping] of this.mappings.entries()) {\n      if (mapping.domain === host) {\n        this.log('marking %s to %s DNS mapping as verified', ip, mapping.domain)\n        startingConfidence = mapping.verified\n        mapping.verified = true\n        mapping.expires = Date.now() + ttl\n        mapping.lastVerified = Date.now()\n      }\n    }\n\n    return startingConfidence\n  }\n\n  unconfirm (ma: Multiaddr, ttl: number): boolean {\n    const host = this.findHost(ma)\n    let wasConfident = false\n\n    for (const [ip, mapping] of this.mappings.entries()) {\n      if (mapping.domain === host) {\n        this.log('removing verification of %s to %s DNS mapping', ip, mapping.domain)\n        wasConfident = wasConfident || mapping.verified\n        mapping.verified = false\n        mapping.expires = Date.now() + ttl\n      }\n    }\n\n    return wasConfident\n  }\n\n  private findHost (ma: Multiaddr): string | undefined {\n    for (const tuple of ma.stringTuples()) {\n      if (tuple[0] === CODEC_SNI) {\n        return tuple[1]\n      }\n\n      if (tuple[0] === CODEC_DNS || tuple[0] === CODEC_DNS4 || tuple[0] === CODEC_DNS6 || tuple[0] === CODEC_DNSADDR) {\n        return tuple[1]\n      }\n    }\n  }\n}\n", "import { isIPv4 } from '@chainsafe/is-ip'\nimport { multiaddr, protocols } from '@multiformats/multiaddr'\nimport type { AddressManagerComponents, AddressManagerInit } from './index.js'\nimport type { Logger } from '@libp2p/interface'\nimport type { NodeAddress } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport const defaultValues = {\n  maxObservedAddresses: 10\n}\n\ninterface PublicAddressMapping {\n  internalIp: string\n  internalPort: number\n  externalIp: string\n  externalPort: number\n  externalFamily: 4 | 6\n  protocol: 'tcp' | 'udp'\n  verified: boolean\n  expires: number\n  lastVerified?: number\n}\n\nconst CODEC_IP4 = 0x04\nconst CODEC_IP6 = 0x29\nconst CODEC_TCP = 0x06\nconst CODEC_UDP = 0x0111\n\nexport class IPMappings {\n  private readonly log: Logger\n  private readonly mappings: Map<string, PublicAddressMapping[]>\n\n  constructor (components: AddressManagerComponents, init: AddressManagerInit = {}) {\n    this.log = components.logger.forComponent('libp2p:address-manager:ip-mappings')\n    this.mappings = new Map()\n  }\n\n  has (ma: Multiaddr): boolean {\n    const tuples = ma.stringTuples()\n\n    for (const mappings of this.mappings.values()) {\n      for (const mapping of mappings) {\n        if (mapping.externalIp === tuples[0][1]) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  add (internalIp: string, internalPort: number, externalIp: string, externalPort: number = internalPort, protocol: 'tcp' | 'udp' = 'tcp'): void {\n    const key = `${internalIp}-${internalPort}-${protocol}`\n    const mappings = this.mappings.get(key) ?? []\n    const mapping: PublicAddressMapping = {\n      internalIp,\n      internalPort,\n      externalIp,\n      externalPort,\n      externalFamily: isIPv4(externalIp) ? 4 : 6,\n      protocol,\n      verified: false,\n      expires: 0\n    }\n    mappings.push(mapping)\n\n    this.mappings.set(key, mappings)\n  }\n\n  remove (ma: Multiaddr): boolean {\n    const tuples = ma.stringTuples()\n    const host = tuples[0][1] ?? ''\n    const protocol = tuples[1][0] === CODEC_TCP ? 'tcp' : 'udp'\n    const port = parseInt(tuples[1][1] ?? '0')\n    let wasConfident = false\n\n    for (const [key, mappings] of this.mappings.entries()) {\n      for (let i = 0; i < mappings.length; i++) {\n        const mapping = mappings[i]\n\n        if (mapping.externalIp === host && mapping.externalPort === port && mapping.protocol === protocol) {\n          this.log('removing %s:%s to %s:%s %s IP mapping', mapping.externalIp, mapping.externalPort, host, port, protocol)\n\n          wasConfident = wasConfident || mapping.verified\n          mappings.splice(i, 1)\n          i--\n        }\n      }\n\n      if (mappings.length === 0) {\n        this.mappings.delete(key)\n      }\n    }\n\n    return wasConfident\n  }\n\n  getAll (addresses: NodeAddress[]): NodeAddress[] {\n    const ipMappedAddresses: NodeAddress[] = []\n\n    for (const { multiaddr: ma } of addresses) {\n      const tuples = ma.stringTuples()\n      let tuple: string | undefined\n\n      // see if the internal host/port/protocol tuple has been mapped externally\n      if ((tuples[0][0] === CODEC_IP4 || tuples[0][0] === CODEC_IP6) && tuples[1][0] === CODEC_TCP) {\n        tuple = `${tuples[0][1]}-${tuples[1][1]}-tcp`\n      } else if ((tuples[0][0] === CODEC_IP4 || tuples[0][0] === CODEC_IP6) && tuples[1][0] === CODEC_UDP) {\n        tuple = `${tuples[0][1]}-${tuples[1][1]}-udp`\n      }\n\n      if (tuple == null) {\n        continue\n      }\n\n      const mappings = this.mappings.get(tuple)\n\n      if (mappings == null) {\n        continue\n      }\n\n      for (const mapping of mappings) {\n        tuples[0][0] = mapping.externalFamily === 4 ? CODEC_IP4 : CODEC_IP6\n        tuples[0][1] = mapping.externalIp\n        tuples[1][1] = `${mapping.externalPort}`\n\n        ipMappedAddresses.push({\n          multiaddr: multiaddr(`/${\n            tuples.map(tuple => {\n              return [\n                protocols(tuple[0]).name,\n                tuple[1]\n              ].join('/')\n            }).join('/')\n          }`),\n          verified: mapping.verified,\n          type: 'ip-mapping',\n          expires: mapping.expires,\n          lastVerified: mapping.lastVerified\n        })\n      }\n    }\n\n    return ipMappedAddresses\n  }\n\n  confirm (ma: Multiaddr, ttl: number): boolean {\n    const tuples = ma.stringTuples()\n    const host = tuples[0][1]\n    let startingConfidence = false\n\n    for (const mappings of this.mappings.values()) {\n      for (const mapping of mappings) {\n        // eslint-disable-next-line max-depth\n        if (mapping.externalIp === host) {\n          this.log('marking %s to %s IP mapping as verified', mapping.internalIp, mapping.externalIp)\n          startingConfidence = mapping.verified\n          mapping.verified = true\n          mapping.expires = Date.now() + ttl\n          mapping.lastVerified = Date.now()\n        }\n      }\n    }\n\n    return startingConfidence\n  }\n\n  unconfirm (ma: Multiaddr, ttl: number): boolean {\n    const tuples = ma.stringTuples()\n    const host = tuples[0][1] ?? ''\n    const protocol = tuples[1][0] === CODEC_TCP ? 'tcp' : 'udp'\n    const port = parseInt(tuples[1][1] ?? '0')\n    let wasConfident = false\n\n    for (const mappings of this.mappings.values()) {\n      for (let i = 0; i < mappings.length; i++) {\n        const mapping = mappings[i]\n\n        if (mapping.externalIp === host && mapping.externalPort === port && mapping.protocol === protocol) {\n          this.log('removing verification of %s:%s to %s:%s %s IP mapping', mapping.externalIp, mapping.externalPort, host, port, protocol)\n\n          wasConfident = wasConfident || mapping.verified\n          mapping.verified = false\n          mapping.expires = Date.now() + ttl\n        }\n      }\n    }\n\n    return wasConfident\n  }\n}\n", "import type { Multiaddr } from '@multiformats/multiaddr'\n\nconst CODEC_IP4 = 0x04\nconst CODEC_IP6 = 0x29\n\n/**\n * Check if a given multiaddr is a link-local address\n */\nexport function isLinkLocal (ma: Multiaddr): boolean {\n  try {\n    const [[codec, value]] = ma.stringTuples()\n\n    if (value == null) {\n      return false\n    }\n\n    if (codec === CODEC_IP4) {\n      return value.startsWith('169.254.')\n    }\n\n    if (codec === CODEC_IP6) {\n      return value.toLowerCase().startsWith('fe80')\n    }\n  } catch {\n\n  }\n\n  return false\n}\n", "import type { Multiaddr } from '@multiformats/multiaddr'\n\nconst CODEC_IP4 = 0x04\nconst CODEC_IP6 = 0x29\n\n/**\n * Check if a given multiaddr is IP-based\n */\nexport function isIpBased (ma: Multiaddr): boolean {\n  try {\n    const [[codec]] = ma.stringTuples()\n\n    return codec === CODEC_IP4 || codec === CODEC_IP6\n  } catch {\n\n  }\n\n  return false\n}\n", "import { isPrivateIp } from '../private-ip.js'\nimport { isIpBased } from './is-ip-based.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n/**\n * Check if a given multiaddr starts with a private address\n */\nexport function isPrivate (ma: Multiaddr): boolean {\n  try {\n    if (!isIpBased(ma)) {\n      // not an IP based multiaddr, cannot be private\n      return false\n    }\n\n    const [[, value]] = ma.stringTuples()\n\n    if (value == null) {\n      return false\n    }\n\n    return isPrivateIp(value) ?? false\n  } catch {\n\n  }\n\n  return true\n}\n", "import { isLinkLocal } from '@libp2p/utils/multiaddr/is-link-local'\nimport { isPrivate } from '@libp2p/utils/multiaddr/is-private'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport type { AddressManagerComponents, AddressManagerInit } from './index.js'\nimport type { Logger } from '@libp2p/interface'\nimport type { NodeAddress } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport const defaultValues = {\n  maxObservedAddresses: 10\n}\n\ninterface ObservedAddressMetadata {\n  verified: boolean\n  expires: number\n  lastVerified?: number\n}\n\nexport class ObservedAddresses {\n  private readonly log: Logger\n  private readonly addresses: Map<string, ObservedAddressMetadata>\n  private readonly maxObservedAddresses: number\n\n  constructor (components: AddressManagerComponents, init: AddressManagerInit = {}) {\n    this.log = components.logger.forComponent('libp2p:address-manager:observed-addresses')\n    this.addresses = new Map()\n    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses\n  }\n\n  has (ma: Multiaddr): boolean {\n    return this.addresses.has(ma.toString())\n  }\n\n  removePrefixed (prefix: string): void {\n    for (const key of this.addresses.keys()) {\n      if (key.toString().startsWith(prefix)) {\n        this.addresses.delete(key)\n      }\n    }\n  }\n\n  add (ma: Multiaddr): void {\n    if (this.addresses.size === this.maxObservedAddresses) {\n      return\n    }\n\n    if (isPrivate(ma) || isLinkLocal(ma)) {\n      return\n    }\n\n    this.log('adding observed address %a', ma)\n    this.addresses.set(ma.toString(), {\n      verified: false,\n      expires: 0\n    })\n  }\n\n  getAll (): NodeAddress[] {\n    return Array.from(this.addresses)\n      .map(([ma, metadata]) => ({\n        multiaddr: multiaddr(ma),\n        verified: metadata.verified,\n        type: 'observed',\n        expires: metadata.expires,\n        lastVerified: metadata.lastVerified\n      }))\n  }\n\n  remove (ma: Multiaddr): boolean {\n    const startingConfidence = this.addresses.get(ma.toString())?.verified ?? false\n\n    this.log('removing observed address %a', ma)\n    this.addresses.delete(ma.toString())\n\n    return startingConfidence\n  }\n\n  confirm (ma: Multiaddr, ttl: number): boolean {\n    const addrString = ma.toString()\n    const metadata = this.addresses.get(addrString) ?? {\n      verified: false,\n      expires: Date.now() + ttl,\n      lastVerified: Date.now()\n    }\n    const startingConfidence = metadata.verified\n    metadata.verified = true\n    metadata.expires = Date.now() + ttl\n    metadata.lastVerified = Date.now()\n\n    this.log('marking observed address %a as verified', addrString)\n    this.addresses.set(addrString, metadata)\n\n    return startingConfidence\n  }\n}\n", "import type { Multiaddr } from '@multiformats/multiaddr'\n\nconst CODEC_IP4 = 0x04\nconst CODEC_IP6 = 0x29\nconst CODEC_DNS = 0x35\nconst CODEC_DNS4 = 0x36\nconst CODEC_DNS6 = 0x37\nconst CODEC_DNSADDR = 0x38\n\nconst NETWORK_CODECS = [\n  CODEC_IP4,\n  CODEC_IP6,\n  CODEC_DNS,\n  CODEC_DNS4,\n  CODEC_DNS6,\n  CODEC_DNSADDR\n]\n\n/**\n * Check if a given multiaddr is a network address\n */\nexport function isNetworkAddress (ma: Multiaddr): boolean {\n  try {\n    const [[codec]] = ma.stringTuples()\n\n    return NETWORK_CODECS.includes(codec)\n  } catch {\n\n  }\n\n  return false\n}\n", "import { isNetworkAddress } from '@libp2p/utils/multiaddr/is-network-address'\nimport { isPrivate } from '@libp2p/utils/multiaddr/is-private'\nimport type { AddressManagerComponents, AddressManagerInit } from './index.js'\nimport type { Logger } from '@libp2p/interface'\nimport type { NodeAddress } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport const defaultValues = {\n  maxObservedAddresses: 10\n}\n\ninterface TransportAddressMetadata {\n  verified: boolean\n  expires: number\n  lastVerified?: number\n}\n\nexport class TransportAddresses {\n  private readonly log: Logger\n  private readonly addresses: Map<string, TransportAddressMetadata>\n  private readonly maxObservedAddresses: number\n\n  constructor (components: AddressManagerComponents, init: AddressManagerInit = {}) {\n    this.log = components.logger.forComponent('libp2p:address-manager:observed-addresses')\n    this.addresses = new Map()\n    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses\n  }\n\n  get (multiaddr: Multiaddr, ttl: number): NodeAddress {\n    if (isPrivate(multiaddr)) {\n      return {\n        multiaddr,\n        verified: true,\n        type: 'transport',\n        expires: Date.now() + ttl,\n        lastVerified: Date.now()\n      }\n    }\n\n    const key = this.toKey(multiaddr)\n    let metadata = this.addresses.get(key)\n\n    if (metadata == null) {\n      metadata = {\n        verified: !isNetworkAddress(multiaddr),\n        expires: 0\n      }\n\n      this.addresses.set(key, metadata)\n    }\n\n    return {\n      multiaddr,\n      verified: metadata.verified,\n      type: 'transport',\n      expires: metadata.expires,\n      lastVerified: metadata.lastVerified\n    }\n  }\n\n  has (ma: Multiaddr): boolean {\n    const key = this.toKey(ma)\n    return this.addresses.has(key)\n  }\n\n  remove (ma: Multiaddr): boolean {\n    const key = this.toKey(ma)\n    const startingConfidence = this.addresses.get(key)?.verified ?? false\n\n    this.log('removing observed address %a', ma)\n    this.addresses.delete(key)\n\n    return startingConfidence\n  }\n\n  confirm (ma: Multiaddr, ttl: number): boolean {\n    const key = this.toKey(ma)\n    const metadata = this.addresses.get(key) ?? {\n      verified: false,\n      expires: 0,\n      lastVerified: 0\n    }\n\n    const startingConfidence = metadata.verified\n\n    metadata.verified = true\n    metadata.expires = Date.now() + ttl\n    metadata.lastVerified = Date.now()\n\n    this.addresses.set(key, metadata)\n\n    return startingConfidence\n  }\n\n  unconfirm (ma: Multiaddr, ttl: number): boolean {\n    const key = this.toKey(ma)\n    const metadata = this.addresses.get(key) ?? {\n      verified: false,\n      expires: 0\n    }\n\n    const startingConfidence = metadata.verified\n\n    metadata.verified = false\n    metadata.expires = Date.now() + ttl\n\n    this.addresses.set(key, metadata)\n\n    return startingConfidence\n  }\n\n  private toKey (ma: Multiaddr): string {\n    if (isNetworkAddress(ma)) {\n      // only works for dns/ip based addresses\n      const options = ma.toOptions()\n\n      return `${options.host}-${options.port}-${options.transport}`\n    }\n\n    return ma.toString()\n  }\n}\n", "/* eslint-disable complexity */\nimport { isIPv4 } from '@chainsafe/is-ip'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { debounce } from '@libp2p/utils/debounce'\nimport { createScalableCuckooFilter } from '@libp2p/utils/filters'\nimport { isPrivateIp } from '@libp2p/utils/private-ip'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { QUICV1, TCP, WebSockets, WebSocketsSecure } from '@multiformats/multiaddr-matcher'\nimport { DNSMappings } from './dns-mappings.js'\nimport { IPMappings } from './ip-mappings.js'\nimport { ObservedAddresses } from './observed-addresses.js'\nimport { TransportAddresses } from './transport-addresses.js'\nimport type { ComponentLogger, Libp2pEvents, Logger, TypedEventTarget, PeerId, PeerStore } from '@libp2p/interface'\nimport type { AddressManager as AddressManagerInterface, TransportManager, NodeAddress, ConfirmAddressOptions } from '@libp2p/interface-internal'\nimport type { Filter } from '@libp2p/utils/filters'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst ONE_MINUTE = 60_000\n\nexport const defaultValues = {\n  maxObservedAddresses: 10,\n  addressVerificationTTL: ONE_MINUTE * 10,\n  addressVerificationRetry: ONE_MINUTE * 5\n}\n\nexport interface AddressManagerInit {\n  /**\n   * Pass an function in this field to override the list of addresses\n   * that are announced to the network\n   */\n  announceFilter?: AddressFilter\n\n  /**\n   * A list of string multiaddrs to listen on\n   */\n  listen?: string[]\n\n  /**\n   * A list of string multiaddrs to use instead of those reported by transports\n   */\n  announce?: string[]\n\n  /**\n   * A list of string multiaddrs string to never announce\n   */\n  noAnnounce?: string[]\n\n  /**\n   * A list of string multiaddrs to add to the list of announced addresses\n   */\n  appendAnnounce?: string[]\n\n  /**\n   * Limits the number of observed addresses we will store\n   */\n  maxObservedAddresses?: number\n\n  /**\n   * How long before each public address should be reverified in ms.\n   *\n   * Requires `@libp2p/autonat` or some other verification method to be\n   * configured.\n   *\n   * @default 600_000\n   */\n  addressVerificationTTL?: number\n\n  /**\n   * After a transport or mapped address has failed to verify, how long to wait\n   * before retrying it in ms\n   *\n   * Requires `@libp2p/autonat` or some other verification method to be\n   * configured.\n   *\n   * @default 300_000\n   */\n  addressVerificationRetry?: number\n}\n\nexport interface AddressManagerComponents {\n  peerId: PeerId\n  transportManager: TransportManager\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\n/**\n * A function that takes a list of multiaddrs and returns a list\n * to announce\n */\nexport interface AddressFilter {\n  (addrs: Multiaddr[]): Multiaddr[]\n}\n\nconst defaultAddressFilter = (addrs: Multiaddr[]): Multiaddr[] => addrs\n\n/**\n * If the passed multiaddr contains the passed peer id, remove it\n */\nfunction stripPeerId (ma: Multiaddr, peerId: PeerId): Multiaddr {\n  const observedPeerIdStr = ma.getPeerId()\n\n  // strip our peer id if it has been passed\n  if (observedPeerIdStr != null) {\n    const observedPeerId = peerIdFromString(observedPeerIdStr)\n\n    // use same encoding for comparison\n    if (observedPeerId.equals(peerId)) {\n      ma = ma.decapsulate(multiaddr(`/p2p/${peerId.toString()}`))\n    }\n  }\n\n  return ma\n}\n\nexport class AddressManager implements AddressManagerInterface {\n  private readonly log: Logger\n  private readonly components: AddressManagerComponents\n  // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`\n  private readonly listen: string[]\n  private readonly announce: Set<string>\n  private readonly appendAnnounce: Set<string>\n  private readonly announceFilter: AddressFilter\n  private readonly observed: ObservedAddresses\n  private readonly dnsMappings: DNSMappings\n  private readonly ipMappings: IPMappings\n  private readonly transportAddresses: TransportAddresses\n  private readonly observedAddressFilter: Filter\n  private readonly addressVerificationTTL: number\n  private readonly addressVerificationRetry: number\n\n  /**\n   * Responsible for managing the peer addresses.\n   * Peers can specify their listen and announce addresses.\n   * The listen addresses will be used by the libp2p transports to listen for new connections,\n   * while the announce addresses will be used for the peer addresses' to other peers in the network.\n   */\n  constructor (components: AddressManagerComponents, init: AddressManagerInit = {}) {\n    const { listen = [], announce = [], appendAnnounce = [] } = init\n\n    this.components = components\n    this.log = components.logger.forComponent('libp2p:address-manager')\n    this.listen = listen.map(ma => ma.toString())\n    this.announce = new Set(announce.map(ma => ma.toString()))\n    this.appendAnnounce = new Set(appendAnnounce.map(ma => ma.toString()))\n    this.observed = new ObservedAddresses(components, init)\n    this.dnsMappings = new DNSMappings(components, init)\n    this.ipMappings = new IPMappings(components, init)\n    this.transportAddresses = new TransportAddresses(components, init)\n    this.announceFilter = init.announceFilter ?? defaultAddressFilter\n    this.observedAddressFilter = createScalableCuckooFilter(1024)\n    this.addressVerificationTTL = init.addressVerificationTTL ?? defaultValues.addressVerificationTTL\n    this.addressVerificationRetry = init.addressVerificationRetry ?? defaultValues.addressVerificationRetry\n\n    // this method gets called repeatedly on startup when transports start listening so\n    // debounce it so we don't cause multiple self:peer:update events to be emitted\n    this._updatePeerStoreAddresses = debounce(this._updatePeerStoreAddresses.bind(this), 1000)\n\n    // update our stored addresses when new transports listen\n    components.events.addEventListener('transport:listening', () => {\n      this._updatePeerStoreAddresses()\n    })\n    // update our stored addresses when existing transports stop listening\n    components.events.addEventListener('transport:close', () => {\n      this._updatePeerStoreAddresses()\n    })\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/address-manager'\n\n  _updatePeerStoreAddresses (): void {\n    // if announce addresses have been configured, ensure they make it into our peer\n    // record for things like identify\n    const addrs = this.getAddresses()\n      .map(ma => {\n        // strip our peer id if it is present\n        if (ma.getPeerId() === this.components.peerId.toString()) {\n          return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`)\n        }\n\n        return ma\n      })\n\n    this.components.peerStore.patch(this.components.peerId, {\n      multiaddrs: addrs\n    })\n      .catch(err => {\n        this.log.error('error updating addresses', err)\n      })\n  }\n\n  /**\n   * Get peer listen multiaddrs\n   */\n  getListenAddrs (): Multiaddr[] {\n    return Array.from(this.listen).map((a) => multiaddr(a))\n  }\n\n  /**\n   * Get peer announcing multiaddrs\n   */\n  getAnnounceAddrs (): Multiaddr[] {\n    return Array.from(this.announce).map((a) => multiaddr(a))\n  }\n\n  /**\n   * Get peer announcing multiaddrs\n   */\n  getAppendAnnounceAddrs (): Multiaddr[] {\n    return Array.from(this.appendAnnounce).map((a) => multiaddr(a))\n  }\n\n  /**\n   * Get observed multiaddrs\n   */\n  getObservedAddrs (): Multiaddr[] {\n    return this.observed.getAll().map(addr => addr.multiaddr)\n  }\n\n  /**\n   * Add peer observed addresses\n   */\n  addObservedAddr (addr: Multiaddr): void {\n    const tuples = addr.stringTuples()\n    const socketAddress = `${tuples[0][1]}:${tuples[1][1]}`\n\n    // ignore if this address if it's been observed before\n    if (this.observedAddressFilter.has(socketAddress)) {\n      return\n    }\n\n    this.observedAddressFilter.add(socketAddress)\n\n    addr = stripPeerId(addr, this.components.peerId)\n\n    // ignore observed address if it is an IP mapping\n    if (this.ipMappings.has(addr)) {\n      return\n    }\n\n    // ignore observed address if it is a DNS mapping\n    if (this.dnsMappings.has(addr)) {\n      return\n    }\n\n    this.observed.add(addr)\n  }\n\n  confirmObservedAddr (addr: Multiaddr, options?: ConfirmAddressOptions): void {\n    addr = stripPeerId(addr, this.components.peerId)\n    let startingConfidence = true\n\n    if (options?.type === 'transport' || this.transportAddresses.has(addr)) {\n      const transportStartingConfidence = this.transportAddresses.confirm(addr, options?.ttl ?? this.addressVerificationTTL)\n\n      if (!transportStartingConfidence && startingConfidence) {\n        startingConfidence = false\n      }\n    }\n\n    if (options?.type === 'dns-mapping' || this.dnsMappings.has(addr)) {\n      const dnsMappingStartingConfidence = this.dnsMappings.confirm(addr, options?.ttl ?? this.addressVerificationTTL)\n\n      if (!dnsMappingStartingConfidence && startingConfidence) {\n        startingConfidence = false\n      }\n    }\n\n    if (options?.type === 'ip-mapping' || this.ipMappings.has(addr)) {\n      const ipMappingStartingConfidence = this.ipMappings.confirm(addr, options?.ttl ?? this.addressVerificationTTL)\n\n      if (!ipMappingStartingConfidence && startingConfidence) {\n        startingConfidence = false\n      }\n    }\n\n    if (options?.type === 'observed' || this.observed.has(addr)) {\n      // try to match up observed address with local transport listener\n      if (this.maybeUpgradeToIPMapping(addr)) {\n        this.ipMappings.confirm(addr, options?.ttl ?? this.addressVerificationTTL)\n        startingConfidence = false\n      } else {\n        const observedStartingConfidence = this.observed.confirm(addr, options?.ttl ?? this.addressVerificationTTL)\n\n        if (!observedStartingConfidence && startingConfidence) {\n          startingConfidence = false\n        }\n      }\n    }\n\n    // only trigger the 'self:peer:update' event if our confidence in an address has changed\n    if (!startingConfidence) {\n      this._updatePeerStoreAddresses()\n    }\n  }\n\n  removeObservedAddr (addr: Multiaddr, options?: ConfirmAddressOptions): void {\n    addr = stripPeerId(addr, this.components.peerId)\n\n    let startingConfidence = false\n\n    if (this.observed.has(addr)) {\n      const observedStartingConfidence = this.observed.remove(addr)\n\n      if (!observedStartingConfidence && startingConfidence) {\n        startingConfidence = false\n      }\n    }\n\n    if (this.transportAddresses.has(addr)) {\n      const transportStartingConfidence = this.transportAddresses.unconfirm(addr, options?.ttl ?? this.addressVerificationRetry)\n\n      if (!transportStartingConfidence && startingConfidence) {\n        startingConfidence = false\n      }\n    }\n\n    if (this.dnsMappings.has(addr)) {\n      const dnsMappingStartingConfidence = this.dnsMappings.unconfirm(addr, options?.ttl ?? this.addressVerificationRetry)\n\n      if (!dnsMappingStartingConfidence && startingConfidence) {\n        startingConfidence = false\n      }\n    }\n\n    if (this.ipMappings.has(addr)) {\n      const ipMappingStartingConfidence = this.ipMappings.unconfirm(addr, options?.ttl ?? this.addressVerificationRetry)\n\n      if (!ipMappingStartingConfidence && startingConfidence) {\n        startingConfidence = false\n      }\n    }\n\n    // only trigger the 'self:peer:update' event if our confidence in an address has changed\n    if (startingConfidence) {\n      this._updatePeerStoreAddresses()\n    }\n  }\n\n  getAddresses (): Multiaddr[] {\n    const addresses = new Set<string>()\n\n    const multiaddrs = this.getAddressesWithMetadata()\n      .filter(addr => {\n        if (!addr.verified) {\n          return false\n        }\n\n        const maStr = addr.multiaddr.toString()\n\n        if (addresses.has(maStr)) {\n          return false\n        }\n\n        addresses.add(maStr)\n\n        return true\n      })\n      .map(address => address.multiaddr)\n\n    // filter addressees before returning\n    return this.announceFilter(\n      multiaddrs.map(str => {\n        const ma = multiaddr(str)\n\n        // do not append our peer id to a path multiaddr as it will become invalid\n        if (ma.protos().pop()?.path === true) {\n          return ma\n        }\n\n        if (ma.getPeerId() === this.components.peerId.toString()) {\n          return ma\n        }\n\n        return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`)\n      })\n    )\n  }\n\n  getAddressesWithMetadata (): NodeAddress[] {\n    const announceMultiaddrs = this.getAnnounceAddrs()\n\n    if (announceMultiaddrs.length > 0) {\n      // allow transports to add certhashes and other runtime information\n      this.components.transportManager.getListeners().forEach(listener => {\n        listener.updateAnnounceAddrs(announceMultiaddrs)\n      })\n\n      return announceMultiaddrs.map(multiaddr => ({\n        multiaddr,\n        verified: true,\n        type: 'announce',\n        expires: Date.now() + this.addressVerificationTTL,\n        lastVerified: Date.now()\n      }))\n    }\n\n    let addresses: NodeAddress[] = []\n\n    // add transport addresses\n    addresses = addresses.concat(\n      this.components.transportManager.getAddrs()\n        .map(multiaddr => this.transportAddresses.get(multiaddr, this.addressVerificationTTL))\n    )\n\n    // add append announce addresses\n    addresses = addresses.concat(\n      this.getAppendAnnounceAddrs().map(multiaddr => ({\n        multiaddr,\n        verified: true,\n        type: 'announce',\n        expires: Date.now() + this.addressVerificationTTL,\n        lastVerified: Date.now()\n      }))\n    )\n\n    // add observed addresses\n    addresses = addresses.concat(\n      this.observed.getAll()\n    )\n\n    // add ip mapped addresses\n    addresses = addresses.concat(\n      this.ipMappings.getAll(addresses)\n    )\n\n    // add ip->domain mappings, must be done after IP mappings\n    addresses = addresses.concat(\n      this.dnsMappings.getAll(addresses)\n    )\n\n    return addresses\n  }\n\n  addDNSMapping (domain: string, addresses: string[]): void {\n    this.dnsMappings.add(domain, addresses)\n  }\n\n  removeDNSMapping (domain: string): void {\n    if (this.dnsMappings.remove(multiaddr(`/dns/${domain}`))) {\n      this._updatePeerStoreAddresses()\n    }\n  }\n\n  addPublicAddressMapping (internalIp: string, internalPort: number, externalIp: string, externalPort: number = internalPort, protocol: 'tcp' | 'udp' = 'tcp'): void {\n    this.ipMappings.add(internalIp, internalPort, externalIp, externalPort, protocol)\n\n    // remove duplicate observed addresses\n    this.observed.removePrefixed(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`)\n  }\n\n  removePublicAddressMapping (internalIp: string, internalPort: number, externalIp: string, externalPort: number = internalPort, protocol: 'tcp' | 'udp' = 'tcp'): void {\n    if (this.ipMappings.remove(multiaddr(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`))) {\n      this._updatePeerStoreAddresses()\n    }\n  }\n\n  /**\n   * Where an external service (router, gateway, etc) is forwarding traffic to\n   * us, attempt to add an IP mapping for the external address - this will\n   * include the observed mapping in the address list where we also have a DNS\n   * mapping for the external IP.\n   *\n   * Returns true if we added a new mapping\n   */\n  private maybeUpgradeToIPMapping (ma: Multiaddr): boolean {\n    // this address is already mapped\n    if (this.ipMappings.has(ma)) {\n      return false\n    }\n\n    const maOptions = ma.toOptions()\n\n    // only public IPv4 addresses\n    if (maOptions.family === 6 || maOptions.host === '127.0.0.1' || isPrivateIp(maOptions.host) === true) {\n      return false\n    }\n\n    const listeners = this.components.transportManager.getListeners()\n\n    const transportMatchers: Array<(ma: Multiaddr) => boolean> = [\n      (ma: Multiaddr) => WebSockets.exactMatch(ma) || WebSocketsSecure.exactMatch(ma),\n      (ma: Multiaddr) => TCP.exactMatch(ma),\n      (ma: Multiaddr) => QUICV1.exactMatch(ma)\n    ]\n\n    for (const matcher of transportMatchers) {\n      // is the incoming address the same type as the matcher\n      if (!matcher(ma)) {\n        continue\n      }\n\n      // get the listeners for this transport\n      const transportListeners = listeners.filter(listener => {\n        return listener.getAddrs().filter(ma => {\n          // only IPv4 addresses of the matcher type\n          return ma.toOptions().family === 4 && matcher(ma)\n        }).length > 0\n      })\n\n      // because the NAT mapping could be forwarding different external ports to\n      // internal ones, we can only be sure enough to add a mapping if there is\n      // a single listener\n      if (transportListeners.length !== 1) {\n        continue\n      }\n\n      // we have one listener which listens on one port so whatever the external\n      // NAT port mapping is, it should be for this listener\n      const linkLocalAddr = transportListeners[0].getAddrs().filter(ma => {\n        return ma.toOptions().host !== '127.0.0.1'\n      }).pop()\n\n      if (linkLocalAddr == null) {\n        continue\n      }\n\n      const linkLocalOptions = linkLocalAddr.toOptions()\n\n      // upgrade observed address to IP mapping\n      this.observed.remove(ma)\n      this.ipMappings.add(\n        linkLocalOptions.host,\n        linkLocalOptions.port,\n        maOptions.host,\n        maOptions.port,\n        maOptions.transport\n      )\n\n      return true\n    }\n\n    return false\n  }\n}\n", "export enum messages {\n  NOT_STARTED_YET = 'The libp2p node is not started yet',\n  NOT_FOUND = 'Not found'\n}\n\nexport class MissingServiceError extends Error {\n  constructor (message = 'Missing service') {\n    super(message)\n    this.name = 'MissingServiceError'\n  }\n}\n\nexport class UnmetServiceDependenciesError extends Error {\n  constructor (message = 'Unmet service dependencies') {\n    super(message)\n    this.name = 'UnmetServiceDependenciesError'\n  }\n}\n\nexport class NoContentRoutersError extends Error {\n  constructor (message = 'No content routers available') {\n    super(message)\n    this.name = 'NoContentRoutersError'\n  }\n}\n\nexport class NoPeerRoutersError extends Error {\n  constructor (message = 'No peer routers available') {\n    super(message)\n    this.name = 'NoPeerRoutersError'\n  }\n}\n\nexport class QueriedForSelfError extends Error {\n  constructor (message = 'Should not try to find self') {\n    super(message)\n    this.name = 'QueriedForSelfError'\n  }\n}\n\nexport class UnhandledProtocolError extends Error {\n  constructor (message = 'Unhandled protocol error') {\n    super(message)\n    this.name = 'UnhandledProtocolError'\n  }\n}\n\nexport class DuplicateProtocolHandlerError extends Error {\n  constructor (message = 'Duplicate protocol handler error') {\n    super(message)\n    this.name = 'DuplicateProtocolHandlerError'\n  }\n}\n\nexport class DialDeniedError extends Error {\n  constructor (message = 'Dial denied error') {\n    super(message)\n    this.name = 'DialDeniedError'\n  }\n}\n\nexport class UnsupportedListenAddressError extends Error {\n  constructor (message = 'No transport was configured to listen on this address') {\n    super(message)\n    this.name = 'UnsupportedListenAddressError'\n  }\n}\n\nexport class UnsupportedListenAddressesError extends Error {\n  constructor (message = 'Configured listen addresses could not be listened on') {\n    super(message)\n    this.name = 'UnsupportedListenAddressesError'\n  }\n}\n\nexport class NoValidAddressesError extends Error {\n  constructor (message = 'No valid addresses') {\n    super(message)\n    this.name = 'NoValidAddressesError'\n  }\n}\n\nexport class ConnectionInterceptedError extends Error {\n  constructor (message = 'Connection intercepted') {\n    super(message)\n    this.name = 'ConnectionInterceptedError'\n  }\n}\n\nexport class ConnectionDeniedError extends Error {\n  constructor (message = 'Connection denied') {\n    super(message)\n    this.name = 'ConnectionDeniedError'\n  }\n}\n\nexport class MuxerUnavailableError extends Error {\n  constructor (message = 'Stream is not multiplexed') {\n    super(message)\n    this.name = 'MuxerUnavailableError'\n  }\n}\n\nexport class EncryptionFailedError extends Error {\n  constructor (message = 'Encryption failed') {\n    super(message)\n    this.name = 'EncryptionFailedError'\n  }\n}\n\nexport class TransportUnavailableError extends Error {\n  constructor (message = 'Transport unavailable') {\n    super(message)\n    this.name = 'TransportUnavailableError'\n  }\n}\n", "import { serviceCapabilities, serviceDependencies } from '@libp2p/interface'\nimport { isStartable, type Startable, type Libp2pEvents, type ComponentLogger, type NodeInfo, type ConnectionProtector, type ConnectionGater, type ContentRouting, type TypedEventTarget, type Metrics, type PeerId, type PeerRouting, type PeerStore, type PrivateKey, type Upgrader } from '@libp2p/interface'\nimport { defaultLogger } from '@libp2p/logger'\nimport { MissingServiceError, UnmetServiceDependenciesError } from './errors.js'\nimport type { AddressManager, ConnectionManager, RandomWalk, Registrar, TransportManager } from '@libp2p/interface-internal'\nimport type { DNS } from '@multiformats/dns'\nimport type { Datastore } from 'interface-datastore'\n\nexport interface Components extends Record<string, any>, Startable {\n  peerId: PeerId\n  privateKey: PrivateKey\n  nodeInfo: NodeInfo\n  logger: ComponentLogger\n  events: TypedEventTarget<Libp2pEvents>\n  addressManager: AddressManager\n  peerStore: PeerStore\n  upgrader: Upgrader\n  randomWalk: RandomWalk\n  registrar: Registrar\n  connectionManager: ConnectionManager\n  transportManager: TransportManager\n  connectionGater: ConnectionGater\n  contentRouting: ContentRouting\n  peerRouting: PeerRouting\n  datastore: Datastore\n  connectionProtector?: ConnectionProtector\n  metrics?: Metrics\n  dns?: DNS\n}\n\nexport interface ComponentsInit {\n  peerId?: PeerId\n  privateKey?: PrivateKey\n  nodeInfo?: NodeInfo\n  logger?: ComponentLogger\n  events?: TypedEventTarget<Libp2pEvents>\n  addressManager?: AddressManager\n  peerStore?: PeerStore\n  upgrader?: Upgrader\n  randomWalk?: RandomWalk\n  metrics?: Metrics\n  registrar?: Registrar\n  connectionManager?: ConnectionManager\n  transportManager?: TransportManager\n  connectionGater?: ConnectionGater\n  contentRouting?: ContentRouting\n  peerRouting?: PeerRouting\n  datastore?: Datastore\n  connectionProtector?: ConnectionProtector\n  dns?: DNS\n}\n\nclass DefaultComponents implements Startable {\n  public components: Record<string, any> = {}\n  private _started = false\n\n  constructor (init: ComponentsInit = {}) {\n    this.components = {}\n\n    for (const [key, value] of Object.entries(init)) {\n      this.components[key] = value\n    }\n\n    if (this.components.logger == null) {\n      this.components.logger = defaultLogger()\n    }\n  }\n\n  isStarted (): boolean {\n    return this._started\n  }\n\n  private async _invokeStartableMethod (methodName: 'beforeStart' | 'start' | 'afterStart' | 'beforeStop' | 'stop' | 'afterStop'): Promise<void> {\n    await Promise.all(\n      Object.values(this.components)\n        .filter(obj => isStartable(obj))\n        .map(async (startable: Startable) => {\n          await startable[methodName]?.()\n        })\n    )\n  }\n\n  async beforeStart (): Promise<void> {\n    await this._invokeStartableMethod('beforeStart')\n  }\n\n  async start (): Promise<void> {\n    await this._invokeStartableMethod('start')\n    this._started = true\n  }\n\n  async afterStart (): Promise<void> {\n    await this._invokeStartableMethod('afterStart')\n  }\n\n  async beforeStop (): Promise<void> {\n    await this._invokeStartableMethod('beforeStop')\n  }\n\n  async stop (): Promise<void> {\n    await this._invokeStartableMethod('stop')\n    this._started = false\n  }\n\n  async afterStop (): Promise<void> {\n    await this._invokeStartableMethod('afterStop')\n  }\n}\n\nconst OPTIONAL_SERVICES = [\n  'metrics',\n  'connectionProtector',\n  'dns'\n]\n\nconst NON_SERVICE_PROPERTIES = [\n  'components',\n  'isStarted',\n  'beforeStart',\n  'start',\n  'afterStart',\n  'beforeStop',\n  'stop',\n  'afterStop',\n  'then',\n  '_invokeStartableMethod'\n]\n\nexport function defaultComponents (init: ComponentsInit = {}): Components {\n  const components = new DefaultComponents(init)\n\n  const proxy = new Proxy(components, {\n    get (target, prop, receiver) {\n      if (typeof prop === 'string' && !NON_SERVICE_PROPERTIES.includes(prop)) {\n        const service = components.components[prop]\n\n        if (service == null && !OPTIONAL_SERVICES.includes(prop)) {\n          throw new MissingServiceError(`${prop} not set`)\n        }\n\n        return service\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n\n    set (target, prop, value) {\n      if (typeof prop === 'string') {\n        components.components[prop] = value\n      } else {\n        Reflect.set(target, prop, value)\n      }\n\n      return true\n    }\n  })\n\n  // @ts-expect-error component keys are proxied\n  return proxy\n}\n\nexport function checkServiceDependencies (components: Components): void {\n  const serviceCapabilities: Record<string, ConstrainBoolean> = {}\n\n  for (const service of Object.values(components.components)) {\n    for (const capability of getServiceCapabilities(service)) {\n      serviceCapabilities[capability] = true\n    }\n  }\n\n  for (const service of Object.values(components.components)) {\n    for (const capability of getServiceDependencies(service)) {\n      if (serviceCapabilities[capability] !== true) {\n        throw new UnmetServiceDependenciesError(`Service \"${getServiceName(service)}\" required capability \"${capability}\" but it was not provided by any component, you may need to add additional configuration when creating your node.`)\n      }\n    }\n  }\n}\n\nfunction getServiceCapabilities (service: any): string[] {\n  if (Array.isArray(service?.[serviceCapabilities])) {\n    return service[serviceCapabilities]\n  }\n\n  return []\n}\n\nfunction getServiceDependencies (service: any): string[] {\n  if (Array.isArray(service?.[serviceDependencies])) {\n    return service[serviceDependencies]\n  }\n\n  return []\n}\n\nfunction getServiceName (service: any): string {\n  return service?.[Symbol.toStringTag] ?? service?.toString() ?? 'unknown'\n}\n", "import { isPrivateIp } from '@libp2p/utils/private-ip'\nimport { WebSockets } from '@multiformats/multiaddr-matcher'\nimport type { ConnectionGater } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst CODEC_IP4 = 0x04\nconst CODEC_IP6 = 0x29\n\n/**\n * Returns a connection gater that disallows dialling private addresses or\n * insecure websockets by default.\n *\n * Browsers are severely limited in their resource usage so don't waste time\n * trying to dial undialable addresses, and they also print verbose error\n * messages when making connections over insecure transports which causes\n * confusion.\n */\nexport function connectionGater (gater: ConnectionGater = {}): ConnectionGater {\n  return {\n    denyDialPeer: async () => false,\n    denyDialMultiaddr: async (multiaddr: Multiaddr) => {\n      // do not connect to insecure websockets by default\n      if (WebSockets.matches(multiaddr)) {\n        return false\n      }\n\n      const tuples = multiaddr.stringTuples()\n\n      // do not connect to private addresses by default\n      if (tuples[0][0] === CODEC_IP4 || tuples[0][0] === CODEC_IP6) {\n        return Boolean(isPrivateIp(`${tuples[0][1]}`))\n      }\n\n      return false\n    },\n    denyInboundConnection: async () => false,\n    denyOutboundConnection: async () => false,\n    denyInboundEncryptedConnection: async () => false,\n    denyOutboundEncryptedConnection: async () => false,\n    denyInboundUpgradedConnection: async () => false,\n    denyOutboundUpgradedConnection: async () => false,\n    filterMultiaddrForPeer: async () => true,\n    ...gater\n  }\n}\n", "// From https://github.com/sindresorhus/random-int/blob/c37741b56f76b9160b0b63dae4e9c64875128146/index.js#L13-L15\nconst randomInteger = (minimum, maximum) => Math.floor((Math.random() * (maximum - minimum + 1)) + minimum);\n\nconst createAbortError = () => {\n\tconst error = new Error('Delay aborted');\n\terror.name = 'AbortError';\n\treturn error;\n};\n\nconst clearMethods = new WeakMap();\n\nexport function createDelay({clearTimeout: defaultClear, setTimeout: defaultSet} = {}) {\n\t// We cannot use `async` here as we need the promise identity.\n\treturn (milliseconds, {value, signal} = {}) => {\n\t\t// TODO: Use `signal?.throwIfAborted()` when targeting Node.js 18.\n\t\tif (signal?.aborted) {\n\t\t\treturn Promise.reject(createAbortError());\n\t\t}\n\n\t\tlet timeoutId;\n\t\tlet settle;\n\t\tlet rejectFunction;\n\t\tconst clear = defaultClear ?? clearTimeout;\n\n\t\tconst signalListener = () => {\n\t\t\tclear(timeoutId);\n\t\t\trejectFunction(createAbortError());\n\t\t};\n\n\t\tconst cleanup = () => {\n\t\t\tif (signal) {\n\t\t\t\tsignal.removeEventListener('abort', signalListener);\n\t\t\t}\n\t\t};\n\n\t\tconst delayPromise = new Promise((resolve, reject) => {\n\t\t\tsettle = () => {\n\t\t\t\tcleanup();\n\t\t\t\tresolve(value);\n\t\t\t};\n\n\t\t\trejectFunction = reject;\n\t\t\ttimeoutId = (defaultSet ?? setTimeout)(settle, milliseconds);\n\t\t});\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', signalListener, {once: true});\n\t\t}\n\n\t\tclearMethods.set(delayPromise, () => {\n\t\t\tclear(timeoutId);\n\t\t\ttimeoutId = null;\n\t\t\tsettle();\n\t\t});\n\n\t\treturn delayPromise;\n\t};\n}\n\nconst delay = createDelay();\n\nexport default delay;\n\nexport async function rangeDelay(minimum, maximum, options = {}) {\n\treturn delay(randomInteger(minimum, maximum), options);\n}\n\nexport function clearDelay(promise) {\n\tclearMethods.get(promise)?.();\n}\n", "import type { RateLimiterResult } from './rate-limiter.js'\n\n/**\n * A rate limit was hit\n */\nexport class RateLimitError extends Error {\n  remainingPoints: number\n  msBeforeNext: number\n  consumedPoints: number\n  isFirstInDuration: boolean\n\n  constructor (message = 'Rate limit exceeded', props: RateLimiterResult) {\n    super(message)\n    this.name = 'RateLimitError'\n    this.remainingPoints = props.remainingPoints\n    this.msBeforeNext = props.msBeforeNext\n    this.consumedPoints = props.consumedPoints\n    this.isFirstInDuration = props.isFirstInDuration\n  }\n}\n\nexport class QueueFullError extends Error {\n  static name = 'QueueFullError'\n\n  constructor (message: string = 'The queue was full') {\n    super(message)\n    this.name = 'QueueFullError'\n  }\n}\n", "import delay from 'delay'\nimport { RateLimitError } from './errors.js'\n\nexport interface RateLimiterInit {\n  /**\n   * Number of points\n   *\n   * @default 4\n   */\n  points?: number\n\n  /**\n   * Per seconds\n   *\n   * @default 1\n   */\n  duration?: number\n\n  /**\n   * Block if consumed more than points in current duration for blockDuration seconds\n   *\n   * @default 0\n   */\n  blockDuration?: number\n\n  /**\n   * Execute allowed actions evenly over duration\n   *\n   * @default false\n   */\n  execEvenly?: boolean\n\n  /**\n   * ms, works with execEvenly=true option\n   *\n   * @default duration * 1000 / points\n   */\n  execEvenlyMinDelayMs?: number\n\n  /**\n   * @default \"rlflx\"\n   */\n  keyPrefix?: string\n}\n\nexport interface GetKeySecDurationOptions {\n  customDuration?: number\n}\n\nexport interface RateLimiterResult {\n  remainingPoints: number\n  msBeforeNext: number\n  consumedPoints: number\n  isFirstInDuration: boolean\n}\n\nexport interface RateRecord {\n  value: number\n  expiresAt?: Date\n  timeoutId?: ReturnType<typeof setTimeout>\n}\n\nexport class RateLimiter {\n  public readonly memoryStorage: MemoryStorage\n  protected points: number\n  protected duration: number\n  protected blockDuration: number\n  protected execEvenly: boolean\n  protected execEvenlyMinDelayMs: number\n  protected keyPrefix: string\n\n  constructor (opts: RateLimiterInit = {}) {\n    this.points = opts.points ?? 4\n    this.duration = opts.duration ?? 1\n    this.blockDuration = opts.blockDuration ?? 0\n    this.execEvenly = opts.execEvenly ?? false\n    this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs ?? (this.duration * 1000 / this.points)\n    this.keyPrefix = opts.keyPrefix ?? 'rlflx'\n    this.memoryStorage = new MemoryStorage()\n  }\n\n  async consume (key: string, pointsToConsume: number = 1, options: GetKeySecDurationOptions = {}): Promise<RateLimiterResult> {\n    const rlKey = this.getKey(key)\n    const secDuration = this._getKeySecDuration(options)\n    let res = this.memoryStorage.incrby(rlKey, pointsToConsume, secDuration)\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0)\n\n    if (res.consumedPoints > this.points) {\n      // Block only first time when consumed more than points\n      if (this.blockDuration > 0 && res.consumedPoints <= (this.points + pointsToConsume)) {\n        // Block key\n        res = this.memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration)\n      }\n\n      throw new RateLimitError('Rate limit exceeded', res)\n    } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {\n      // Execute evenly\n      let delayMs = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2))\n      if (delayMs < this.execEvenlyMinDelayMs) {\n        delayMs = res.consumedPoints * this.execEvenlyMinDelayMs\n      }\n\n      await delay(delayMs)\n    }\n\n    return res\n  }\n\n  penalty (key: string, points: number = 1, options: GetKeySecDurationOptions = {}): RateLimiterResult {\n    const rlKey = this.getKey(key)\n    const secDuration = this._getKeySecDuration(options)\n    const res = this.memoryStorage.incrby(rlKey, points, secDuration)\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0)\n\n    return res\n  }\n\n  reward (key: string, points: number = 1, options: GetKeySecDurationOptions = {}): RateLimiterResult {\n    const rlKey = this.getKey(key)\n    const secDuration = this._getKeySecDuration(options)\n    const res = this.memoryStorage.incrby(rlKey, -points, secDuration)\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0)\n\n    return res\n  }\n\n  /**\n   * Block any key for secDuration seconds\n   *\n   * @param key\n   * @param secDuration\n   */\n  block (key: string, secDuration: number): RateLimiterResult {\n    const msDuration = secDuration * 1000\n    const initPoints = this.points + 1\n\n    this.memoryStorage.set(this.getKey(key), initPoints, secDuration)\n\n    return {\n      remainingPoints: 0,\n      msBeforeNext: msDuration === 0 ? -1 : msDuration,\n      consumedPoints: initPoints,\n      isFirstInDuration: false\n    }\n  }\n\n  set (key: string, points: number, secDuration: number = 0): RateLimiterResult {\n    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000\n\n    this.memoryStorage.set(this.getKey(key), points, secDuration)\n\n    return {\n      remainingPoints: 0,\n      msBeforeNext: msDuration === 0 ? -1 : msDuration,\n      consumedPoints: points,\n      isFirstInDuration: false\n    }\n  }\n\n  get (key: string): RateLimiterResult | undefined {\n    const res = this.memoryStorage.get(this.getKey(key))\n\n    if (res != null) {\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0)\n    }\n\n    return res\n  }\n\n  delete (key: string): void {\n    this.memoryStorage.delete(this.getKey(key))\n  }\n\n  private _getKeySecDuration (options?: GetKeySecDurationOptions): number {\n    if (options?.customDuration != null && options.customDuration >= 0) {\n      return options.customDuration\n    }\n\n    return this.duration\n  }\n\n  getKey (key: string): string {\n    return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key\n  }\n\n  parseKey (rlKey: string): string {\n    return rlKey.substring(this.keyPrefix.length)\n  }\n}\n\nexport class MemoryStorage {\n  public readonly storage: Map<string, RateRecord>\n\n  constructor () {\n    this.storage = new Map()\n  }\n\n  incrby (key: string, value: number, durationSec: number): RateLimiterResult {\n    const existing = this.storage.get(key)\n\n    if (existing != null) {\n      const msBeforeExpires = existing.expiresAt != null\n        ? existing.expiresAt.getTime() - new Date().getTime()\n        : -1\n\n      if (existing.expiresAt == null || msBeforeExpires > 0) {\n        // Change value\n        existing.value += value\n\n        return {\n          remainingPoints: 0,\n          msBeforeNext: msBeforeExpires,\n          consumedPoints: existing.value,\n          isFirstInDuration: false\n        }\n      }\n\n      return this.set(key, value, durationSec)\n    }\n\n    return this.set(key, value, durationSec)\n  }\n\n  set (key: string, value: number, durationSec: number): RateLimiterResult {\n    const durationMs = durationSec * 1000\n    const existing = this.storage.get(key)\n\n    if (existing != null) {\n      clearTimeout(existing.timeoutId)\n    }\n\n    const record: RateRecord = {\n      value,\n      expiresAt: durationMs > 0 ? new Date(Date.now() + durationMs) : undefined\n    }\n\n    this.storage.set(key, record)\n\n    if (durationMs > 0) {\n      record.timeoutId = setTimeout(() => {\n        this.storage.delete(key)\n      }, durationMs)\n\n      if (record.timeoutId.unref != null) {\n        record.timeoutId.unref()\n      }\n    }\n\n    return {\n      remainingPoints: 0,\n      msBeforeNext: durationMs === 0 ? -1 : durationMs,\n      consumedPoints: record.value,\n      isFirstInDuration: true\n    }\n  }\n\n  get (key: string): RateLimiterResult | undefined {\n    const existing = this.storage.get(key)\n\n    if (existing != null) {\n      const msBeforeExpires = existing.expiresAt != null\n        ? existing.expiresAt.getTime() - new Date().getTime()\n        : -1\n      return {\n        remainingPoints: 0,\n        msBeforeNext: msBeforeExpires,\n        consumedPoints: existing.value,\n        isFirstInDuration: false\n      }\n    }\n  }\n\n  delete (key: string): boolean {\n    const record = this.storage.get(key)\n\n    if (record != null) {\n      if (record.timeoutId != null) {\n        clearTimeout(record.timeoutId)\n      }\n\n      this.storage.delete(key)\n\n      return true\n    }\n    return false\n  }\n}\n", "import { InvalidMultiaddrError, InvalidParametersError, isPeerId } from '@libp2p/interface'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { isMultiaddr } from '@multiformats/multiaddr'\nimport type { PeerId } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface PeerAddress {\n  peerId?: PeerId\n  multiaddrs: Multiaddr[]\n}\n\n/**\n * Extracts a PeerId and/or multiaddr from the passed PeerId or Multiaddr or an array of Multiaddrs\n */\nexport function getPeerAddress (peer: PeerId | Multiaddr | Multiaddr[]): PeerAddress {\n  if (isPeerId(peer)) {\n    return { peerId: peer, multiaddrs: [] }\n  }\n\n  if (!Array.isArray(peer)) {\n    peer = [peer]\n  }\n\n  let peerId: PeerId | undefined\n\n  if (peer.length > 0) {\n    const peerIdStr = peer[0].getPeerId()\n    peerId = peerIdStr == null ? undefined : peerIdFromString(peerIdStr)\n\n    // ensure PeerId is either not set or is consistent\n    peer.forEach(ma => {\n      if (!isMultiaddr(ma)) {\n        throw new InvalidMultiaddrError('Invalid multiaddr')\n      }\n\n      const maPeerIdStr = ma.getPeerId()\n\n      if (maPeerIdStr == null) {\n        if (peerId != null) {\n          throw new InvalidParametersError('Multiaddrs must all have the same peer id or have no peer id')\n        }\n      } else {\n        const maPeerId = peerIdFromString(maPeerIdStr)\n\n        if (peerId?.equals(maPeerId) !== true) {\n          throw new InvalidParametersError('Multiaddrs must all have the same peer id or have no peer id')\n        }\n      }\n    })\n  }\n\n  return {\n    peerId,\n    multiaddrs: peer\n  }\n}\n", "import type { Connection, Stream, AbortOptions } from '@libp2p/interface'\n\n/**\n * Close the passed stream, falling back to aborting the stream if closing\n * cleanly fails.\n */\nexport async function safelyCloseStream (stream?: Stream, options?: AbortOptions): Promise<void> {\n  try {\n    await stream?.close(options)\n  } catch (err: any) {\n    stream?.abort(err)\n  }\n}\n\n/**\n * These are speculative protocols that are run automatically on connection open\n * so are usually not the reason the connection was opened.\n *\n * Consequently when requested it should be safe to close connections that only\n * have these protocol streams open.\n */\nconst DEFAULT_CLOSABLE_PROTOCOLS = [\n  // identify\n  '/ipfs/id/1.0.0',\n\n  // identify-push\n  '/ipfs/id/push/1.0.0',\n\n  // autonat\n  '/libp2p/autonat/1.0.0',\n\n  // dcutr\n  '/libp2p/dcutr'\n]\n\nexport interface SafelyCloseConnectionOptions extends AbortOptions {\n  /**\n   * Only close the stream if it either has no protocol streams open or only\n   * ones in this list.\n   *\n   * @default ['/ipfs/id/1.0.0']\n   */\n  closableProtocols?: string[]\n}\n\n/**\n * Close the passed connection if it has no streams, or only closable protocol\n * streams, falling back to aborting the connection if closing it cleanly fails.\n */\nexport async function safelyCloseConnectionIfUnused (connection?: Connection, options?: SafelyCloseConnectionOptions): Promise<void> {\n  const streamProtocols = connection?.streams?.map(stream => stream.protocol) ?? []\n  const closableProtocols = options?.closableProtocols ?? DEFAULT_CLOSABLE_PROTOCOLS\n\n  // if the connection has protocols not in the closable protocols list, do not\n  // close the connection\n  if (streamProtocols.filter(proto => proto != null && !closableProtocols.includes(proto)).length > 0) {\n    return\n  }\n\n  try {\n    await connection?.close(options)\n  } catch (err: any) {\n    connection?.abort(err)\n  }\n}\n", "/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#dialTimeout\n */\nexport const DIAL_TIMEOUT = 10_000\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#inboundUpgradeTimeout\n */\nexport const INBOUND_UPGRADE_TIMEOUT = 10_000\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#protocolNegotiationTimeout\n */\nexport const PROTOCOL_NEGOTIATION_TIMEOUT = 10_000\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxPeerAddrsToDial\n */\nexport const MAX_PEER_ADDRS_TO_DIAL = 25\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#inboundConnectionThreshold\n */\nexport const INBOUND_CONNECTION_THRESHOLD = 5\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxIncomingPendingConnections\n */\nexport const MAX_INCOMING_PENDING_CONNECTIONS = 10\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxParallelReconnects\n */\nexport const MAX_PARALLEL_RECONNECTS = 5\n\n/**\n * Store as part of the peer store metadata for a given peer, the value for this\n * key is a timestamp of the last time a dial attempt failed with the timestamp\n * stored as a string.\n *\n * Used to insure we do not endlessly try to auto dial peers we have recently\n * failed to dial.\n */\nexport const LAST_DIAL_FAILURE_KEY = 'last-dial-failure'\n\n/**\n * Store as part of the peer store metadata for a given peer, the value for this\n * key is a timestamp of the last time a dial attempt succeeded with the\n * timestamp stored as a string.\n */\nexport const LAST_DIAL_SUCCESS_KEY = 'last-dial-success'\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxDialQueueLength\n */\nexport const MAX_DIAL_QUEUE_LENGTH = 500\n", "export * from './constants.defaults.js'\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxConnections\n */\nexport const MAX_CONNECTIONS = 100\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxParallelDials\n */\nexport const MAX_PARALLEL_DIALS = 50\n", "import { multiaddr, resolvers, type Multiaddr, type ResolveOptions } from '@multiformats/multiaddr'\nimport { convertToIpNet } from '@multiformats/multiaddr/convert'\nimport type { IpNet } from '@chainsafe/netmask'\nimport type { LoggerOptions } from '@libp2p/interface'\n\n/**\n * Recursively resolve DNSADDR multiaddrs\n */\nexport async function resolveMultiaddrs (ma: Multiaddr, options: ResolveOptions & LoggerOptions): Promise<Multiaddr[]> {\n  // check multiaddr resolvers\n  let resolvable = false\n\n  for (const key of resolvers.keys()) {\n    resolvable = ma.protoNames().includes(key)\n\n    if (resolvable) {\n      break\n    }\n  }\n\n  // return multiaddr if it is not resolvable\n  if (!resolvable) {\n    return [ma]\n  }\n\n  const output = await ma.resolve(options)\n\n  options.log('resolved %s to', ma, output.map(ma => ma.toString()))\n\n  return output\n}\n\n/**\n * Converts a multiaddr string or object to an IpNet object.\n * If the multiaddr doesn't include /ipcidr, it will encapsulate with the appropriate CIDR:\n * - /ipcidr/32 for IPv4\n * - /ipcidr/128 for IPv6\n *\n * @param {string | Multiaddr} ma - The multiaddr string or object to convert.\n * @returns {IpNet} The converted IpNet object.\n * @throws {Error} Throws an error if the multiaddr is not valid.\n */\nexport function multiaddrToIpNet (ma: string | Multiaddr): IpNet {\n  try {\n    let parsedMa: Multiaddr\n    if (typeof ma === 'string') {\n      parsedMa = multiaddr(ma)\n    } else {\n      parsedMa = ma\n    }\n\n    // Check if /ipcidr is already present\n    if (!parsedMa.protoNames().includes('ipcidr')) {\n      const isIPv6 = parsedMa.protoNames().includes('ip6')\n      const cidr = isIPv6 ? '/ipcidr/128' : '/ipcidr/32'\n      parsedMa = parsedMa.encapsulate(cidr)\n    }\n\n    return convertToIpNet(parsedMa)\n  } catch (error) {\n    throw new Error(`Can't convert to IpNet, Invalid multiaddr format: ${ma}`)\n  }\n}\n", "import { PeerMap } from '@libp2p/peer-collections'\nimport { safelyCloseConnectionIfUnused } from '@libp2p/utils/close'\nimport { MAX_CONNECTIONS } from './constants.js'\nimport { multiaddrToIpNet } from './utils.js'\nimport type { IpNet } from '@chainsafe/netmask'\nimport type { Libp2pEvents, Logger, ComponentLogger, TypedEventTarget, PeerStore, Connection } from '@libp2p/interface'\nimport type { ConnectionManager } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\ninterface ConnectionPrunerInit {\n  maxConnections?: number\n  allow?: Multiaddr[]\n}\n\ninterface ConnectionPrunerComponents {\n  connectionManager: ConnectionManager\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\nconst defaultOptions = {\n  maxConnections: MAX_CONNECTIONS,\n  allow: []\n}\n\n/**\n * If we go over the max connections limit, choose some connections to close\n */\nexport class ConnectionPruner {\n  private readonly maxConnections: number\n  private readonly connectionManager: ConnectionManager\n  private readonly peerStore: PeerStore\n  private readonly allow: IpNet[]\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly log: Logger\n\n  constructor (components: ConnectionPrunerComponents, init: ConnectionPrunerInit = {}) {\n    this.maxConnections = init.maxConnections ?? defaultOptions.maxConnections\n    this.allow = (init.allow ?? []).map(ma => multiaddrToIpNet(ma))\n    this.connectionManager = components.connectionManager\n    this.peerStore = components.peerStore\n    this.events = components.events\n    this.log = components.logger.forComponent('libp2p:connection-manager:connection-pruner')\n    this.maybePruneConnections = this.maybePruneConnections.bind(this)\n  }\n\n  start (): void {\n    this.events.addEventListener('connection:open', this.maybePruneConnections)\n  }\n\n  stop (): void {\n    this.events.removeEventListener('connection:open', this.maybePruneConnections)\n  }\n\n  maybePruneConnections (): void {\n    this._maybePruneConnections()\n      .catch(err => {\n        this.log.error('error while pruning connections %e', err)\n      })\n  }\n\n  /**\n   * If we have more connections than our maximum, select some excess connections\n   * to prune based on peer value\n   */\n  private async _maybePruneConnections (): Promise<void> {\n    const connections = this.connectionManager.getConnections()\n    const numConnections = connections.length\n\n    this.log('checking max connections limit %d/%d', numConnections, this.maxConnections)\n\n    if (numConnections <= this.maxConnections) {\n      return\n    }\n\n    const peerValues = new PeerMap<number>()\n\n    // work out peer values\n    for (const connection of connections) {\n      const remotePeer = connection.remotePeer\n\n      if (peerValues.has(remotePeer)) {\n        continue\n      }\n\n      peerValues.set(remotePeer, 0)\n\n      try {\n        const peer = await this.peerStore.get(remotePeer)\n\n        // sum all tag values\n        peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {\n          return acc + curr.value\n        }, 0))\n      } catch (err: any) {\n        if (err.name !== 'NotFoundError') {\n          this.log.error('error loading peer tags', err)\n        }\n      }\n    }\n\n    const sortedConnections = this.sortConnections(connections, peerValues)\n\n    // close some connections\n    const toPrune = Math.max(numConnections - this.maxConnections, 0)\n    const toClose = []\n\n    for (const connection of sortedConnections) {\n      this.log('too many connections open - closing a connection to %p', connection.remotePeer)\n      // check allow list\n      const connectionInAllowList = this.allow.some((ipNet) => {\n        return ipNet.contains(connection.remoteAddr.nodeAddress().address)\n      })\n\n      // Connections in the allow list should be excluded from pruning\n      if (!connectionInAllowList) {\n        toClose.push(connection)\n      }\n\n      if (toClose.length === toPrune) {\n        break\n      }\n    }\n\n    // close connections\n    await Promise.all(\n      toClose.map(async connection => {\n        await safelyCloseConnectionIfUnused(connection, {\n          signal: AbortSignal.timeout(1000)\n        })\n      })\n    )\n\n    // despatch prune event\n    this.events.safeDispatchEvent('connection:prune', { detail: toClose })\n  }\n\n  sortConnections (connections: Connection[], peerValues: PeerMap<number>): Connection[] {\n    return connections\n      // sort by connection age, newest to oldest\n      .sort((a, b) => {\n        const connectionALifespan = a.timeline.open\n        const connectionBLifespan = b.timeline.open\n\n        if (connectionALifespan < connectionBLifespan) {\n          return 1\n        }\n\n        if (connectionALifespan > connectionBLifespan) {\n          return -1\n        }\n\n        return 0\n      })\n      // sort by direction, incoming first then outgoing\n      .sort((a, b) => {\n        if (a.direction === 'outbound' && b.direction === 'inbound') {\n          return 1\n        }\n\n        if (a.direction === 'inbound' && b.direction === 'outbound') {\n          return -1\n        }\n\n        return 0\n      })\n      // sort by number of streams, lowest to highest\n      .sort((a, b) => {\n        if (a.streams.length > b.streams.length) {\n          return 1\n        }\n\n        if (a.streams.length < b.streams.length) {\n          return -1\n        }\n\n        return 0\n      })\n      // sort by tag value, lowest to highest\n      .sort((a, b) => {\n        const peerAValue = peerValues.get(a.remotePeer) ?? 0\n        const peerBValue = peerValues.get(b.remotePeer) ?? 0\n\n        if (peerAValue > peerBValue) {\n          return 1\n        }\n\n        if (peerAValue < peerBValue) {\n          return -1\n        }\n\n        return 0\n      })\n  }\n}\n", "import { AbortError } from '@libp2p/interface'\nimport pDefer from 'p-defer'\nimport type { DeferredPromise } from 'p-defer'\n\nexport class JobRecipient<JobReturnType> {\n  public deferred: DeferredPromise<JobReturnType>\n  public signal?: AbortSignal\n\n  constructor (signal?: AbortSignal) {\n    this.signal = signal\n    this.deferred = pDefer()\n\n    this.onAbort = this.onAbort.bind(this)\n    this.signal?.addEventListener('abort', this.onAbort)\n  }\n\n  onAbort (): void {\n    this.deferred.reject(this.signal?.reason ?? new AbortError())\n  }\n\n  cleanup (): void {\n    this.signal?.removeEventListener('abort', this.onAbort)\n  }\n}\n", "import { AbortError, setMaxListeners } from '@libp2p/interface'\nimport { raceSignal } from 'race-signal'\nimport { JobRecipient } from './recipient.js'\nimport type { JobStatus } from './index.js'\nimport type { AbortOptions } from '@libp2p/interface'\n\n/**\n * Returns a random string\n */\nfunction randomId (): string {\n  return `${(parseInt(String(Math.random() * 1e9), 10)).toString()}${Date.now()}`\n}\n\nexport interface JobTimeline {\n  created: number\n  started?: number\n  finished?: number\n}\n\nexport class Job <JobOptions extends AbortOptions = AbortOptions, JobReturnType = unknown> {\n  public id: string\n  public fn: (options: JobOptions) => Promise<JobReturnType>\n  public options: JobOptions\n  public recipients: Array<JobRecipient<JobReturnType>>\n  public status: JobStatus\n  public readonly timeline: JobTimeline\n  private readonly controller: AbortController\n\n  constructor (fn: (options: JobOptions) => Promise<JobReturnType>, options: any) {\n    this.id = randomId()\n    this.status = 'queued'\n    this.fn = fn\n    this.options = options\n    this.recipients = []\n    this.timeline = {\n      created: Date.now()\n    }\n\n    this.controller = new AbortController()\n    setMaxListeners(Infinity, this.controller.signal)\n\n    this.onAbort = this.onAbort.bind(this)\n  }\n\n  abort (err: Error): void {\n    this.controller.abort(err)\n  }\n\n  onAbort (): void {\n    const allAborted = this.recipients.reduce((acc, curr) => {\n      return acc && (curr.signal?.aborted === true)\n    }, true)\n\n    // if all recipients have aborted the job, actually abort the job\n    if (allAborted) {\n      this.controller.abort(new AbortError())\n      this.cleanup()\n    }\n  }\n\n  async join (options: AbortOptions = {}): Promise<JobReturnType> {\n    const recipient = new JobRecipient<JobReturnType>(options.signal)\n    this.recipients.push(recipient)\n\n    options.signal?.addEventListener('abort', this.onAbort)\n\n    return recipient.deferred.promise\n  }\n\n  async run (): Promise<void> {\n    this.status = 'running'\n    this.timeline.started = Date.now()\n\n    try {\n      this.controller.signal.throwIfAborted()\n\n      const result = await raceSignal(this.fn({\n        ...(this.options ?? {}),\n        signal: this.controller.signal\n      }), this.controller.signal)\n\n      this.recipients.forEach(recipient => {\n        recipient.deferred.resolve(result)\n      })\n\n      this.status = 'complete'\n    } catch (err) {\n      this.recipients.forEach(recipient => {\n        recipient.deferred.reject(err)\n      })\n\n      this.status = 'errored'\n    } finally {\n      this.timeline.finished = Date.now()\n      this.cleanup()\n    }\n  }\n\n  cleanup (): void {\n    this.recipients.forEach(recipient => {\n      recipient.cleanup()\n      recipient.signal?.removeEventListener('abort', this.onAbort)\n    })\n  }\n}\n", "import { AbortError, TypedEventEmitter } from '@libp2p/interface'\nimport { pushable } from 'it-pushable'\nimport { raceEvent } from 'race-event'\nimport { QueueFullError } from '../errors.js'\nimport { Job } from './job.js'\nimport type { AbortOptions, Metrics } from '@libp2p/interface'\n\nexport type { Job, JobTimeline } from './job.js'\nexport type { JobRecipient } from './recipient.js'\n\nexport interface Comparator<T> {\n  (a: T, b: T): -1 | 0 | 1\n}\n\nexport interface QueueInit<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  /**\n   * Concurrency limit.\n   *\n   * Minimum: `1`.\n   *\n   * @default Infinity\n   */\n  concurrency?: number\n\n  /**\n   * If the queue size grows to larger than this number the promise returned\n   * from the add function will reject\n   *\n   * @default Infinity\n   */\n  maxSize?: number\n\n  /**\n   * The name of the metric for the queue length\n   */\n  metricName?: string\n\n  /**\n   * An implementation of the libp2p Metrics interface\n   */\n  metrics?: Metrics\n\n  /**\n   * An optional function that will sort the queue after a job has been added\n   */\n  sort?: Comparator<Job<JobOptions, JobReturnType>>\n}\n\nexport type JobStatus = 'queued' | 'running' | 'errored' | 'complete'\n\nexport interface RunFunction<Options extends AbortOptions = AbortOptions, ReturnType = void> {\n  (options: Options): Promise<ReturnType>\n}\n\nexport interface JobMatcher<JobOptions extends AbortOptions = AbortOptions> {\n  (options?: Partial<JobOptions>): boolean\n}\n\nexport interface QueueJobSuccess<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  job: Job<JobOptions, JobReturnType>\n  result: JobReturnType\n}\n\nexport interface QueueJobFailure<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  job: Job<JobOptions, JobReturnType>\n  error: Error\n}\n\nexport interface QueueEvents<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  /**\n   * A job is about to start running\n   */\n  'active': CustomEvent\n\n  /**\n   * All jobs have finished and the queue is empty\n   */\n  'idle': CustomEvent\n\n  /**\n   * The queue is empty, jobs may be running\n   */\n  'empty': CustomEvent\n\n  /**\n   * A job was added to the queue\n   */\n  'add': CustomEvent\n\n  /**\n   * A job has finished or failed\n   */\n  'next': CustomEvent\n\n  /**\n   * A job has finished successfully\n   */\n  'completed': CustomEvent<JobReturnType>\n\n  /**\n   * A job has failed\n   */\n  'error': CustomEvent<Error>\n\n  /**\n   * Emitted just after `\"completed\", a job has finished successfully - this\n   * event gives access to the job and it's result\n   */\n  'success': CustomEvent<QueueJobSuccess<JobReturnType, JobOptions>>\n\n  /**\n   * Emitted just after `\"error\", a job has failed - this event gives access to\n   * the job and the thrown error\n   */\n  'failure': CustomEvent<QueueJobFailure<JobReturnType, JobOptions>>\n}\n\n/**\n * Heavily influence by `p-queue` with the following differences:\n *\n * 1. Items remain at the head of the queue while they are running so `queue.size` includes `queue.pending` items - this is so interested parties can join the results of a queue item while it is running\n * 2. The options for a job are stored separately to the job in order for them to be modified while they are still in the queue\n */\nexport class Queue<JobReturnType = unknown, JobOptions extends AbortOptions = AbortOptions> extends TypedEventEmitter<QueueEvents<JobReturnType, JobOptions>> {\n  public concurrency: number\n  public maxSize: number\n  public queue: Array<Job<JobOptions, JobReturnType>>\n  private pending: number\n  private readonly sort?: Comparator<Job<JobOptions, JobReturnType>>\n\n  constructor (init: QueueInit<JobReturnType, JobOptions> = {}) {\n    super()\n\n    this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY\n    this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY\n    this.pending = 0\n\n    if (init.metricName != null) {\n      init.metrics?.registerMetricGroup(init.metricName, {\n        calculate: () => {\n          return {\n            size: this.queue.length,\n            running: this.pending,\n            queued: this.queue.length - this.pending\n          }\n        }\n      })\n    }\n\n    this.sort = init.sort\n    this.queue = []\n  }\n\n  private tryToStartAnother (): boolean {\n    if (this.size === 0) {\n      // do this in the microtask queue so all job recipients receive the\n      // result before the \"empty\" event fires\n      queueMicrotask(() => {\n        this.safeDispatchEvent('empty')\n      })\n\n      if (this.running === 0) {\n        // do this in the microtask queue so all job recipients receive the\n        // result before the \"idle\" event fires\n        queueMicrotask(() => {\n          this.safeDispatchEvent('idle')\n        })\n      }\n\n      return false\n    }\n\n    if (this.pending < this.concurrency) {\n      let job: Job<JobOptions, JobReturnType> | undefined\n\n      for (const j of this.queue) {\n        if (j.status === 'queued') {\n          job = j\n          break\n        }\n      }\n\n      if (job == null) {\n        return false\n      }\n\n      this.safeDispatchEvent('active')\n\n      this.pending++\n\n      void job.run()\n        .finally(() => {\n          // remove the job from the queue\n          for (let i = 0; i < this.queue.length; i++) {\n            if (this.queue[i] === job) {\n              this.queue.splice(i, 1)\n              break\n            }\n          }\n\n          this.pending--\n          this.tryToStartAnother()\n          this.safeDispatchEvent('next')\n        })\n\n      return true\n    }\n\n    return false\n  }\n\n  private enqueue (job: Job<JobOptions, JobReturnType>): void {\n    this.queue.push(job)\n\n    if (this.sort != null) {\n      this.queue.sort(this.sort)\n    }\n  }\n\n  /**\n   * Adds a sync or async task to the queue. Always returns a promise.\n   */\n  async add (fn: RunFunction<JobOptions, JobReturnType>, options?: JobOptions): Promise<JobReturnType> {\n    options?.signal?.throwIfAborted()\n\n    if (this.size === this.maxSize) {\n      throw new QueueFullError()\n    }\n\n    const job = new Job<JobOptions, JobReturnType>(fn, options)\n    this.enqueue(job)\n    this.safeDispatchEvent('add')\n    this.tryToStartAnother()\n\n    return job.join(options)\n      .then(result => {\n        this.safeDispatchEvent('completed', { detail: result })\n        this.safeDispatchEvent('success', { detail: { job, result } })\n\n        return result\n      })\n      .catch(err => {\n        if (job.status === 'queued') {\n          // job was aborted before it started - remove the job from the queue\n          for (let i = 0; i < this.queue.length; i++) {\n            if (this.queue[i] === job) {\n              this.queue.splice(i, 1)\n              break\n            }\n          }\n        }\n\n        this.safeDispatchEvent('error', { detail: err })\n        this.safeDispatchEvent('failure', { detail: { job, error: err } })\n\n        throw err\n      })\n  }\n\n  /**\n   * Clear the queue\n   */\n  clear (): void {\n    this.queue.splice(0, this.queue.length)\n  }\n\n  /**\n   * Abort all jobs in the queue and clear it\n   */\n  abort (): void {\n    this.queue.forEach(job => {\n      job.abort(new AbortError())\n    })\n\n    this.clear()\n  }\n\n  /**\n   * Can be called multiple times. Useful if you for example add additional items at a later time.\n   *\n   * @returns A promise that settles when the queue becomes empty.\n   */\n  async onEmpty (options?: AbortOptions): Promise<void> {\n    // Instantly resolve if the queue is empty\n    if (this.size === 0) {\n      return\n    }\n\n    await raceEvent(this, 'empty', options?.signal)\n  }\n\n  /**\n   * @returns A promise that settles when the queue size is less than the given\n   * limit: `queue.size < limit`.\n   *\n   * If you want to avoid having the queue grow beyond a certain size you can\n   * `await queue.onSizeLessThan()` before adding a new item.\n   *\n   * Note that this only limits the number of items waiting to start. There\n   * could still be up to `concurrency` jobs already running that this call does\n   * not include in its calculation.\n   */\n  async onSizeLessThan (limit: number, options?: AbortOptions): Promise<void> {\n    // Instantly resolve if the queue is empty.\n    if (this.size < limit) {\n      return\n    }\n\n    await raceEvent(this, 'next', options?.signal, {\n      filter: () => this.size < limit\n    })\n  }\n\n  /**\n   * The difference with `.onEmpty` is that `.onIdle` guarantees that all work\n   * from the queue has finished. `.onEmpty` merely signals that the queue is\n   * empty, but it could mean that some promises haven't completed yet.\n   *\n   * @returns A promise that settles when the queue becomes empty, and all\n   * promises have completed; `queue.size === 0 && queue.pending === 0`.\n   */\n  async onIdle (options?: AbortOptions): Promise<void> {\n    // Instantly resolve if none pending and if nothing else is queued\n    if (this.pending === 0 && this.size === 0) {\n      return\n    }\n\n    await raceEvent(this, 'idle', options?.signal)\n  }\n\n  /**\n   * Size of the queue including running items\n   */\n  get size (): number {\n    return this.queue.length\n  }\n\n  /**\n   * The number of queued items waiting to run.\n   */\n  get queued (): number {\n    return this.queue.length - this.pending\n  }\n\n  /**\n   * The number of items currently running.\n   */\n  get running (): number {\n    return this.pending\n  }\n\n  /**\n   * Returns an async generator that makes it easy to iterate over the results\n   * of jobs added to the queue.\n   *\n   * The generator will end when the queue becomes idle, that is there are no\n   * jobs running and no jobs that have yet to run.\n   *\n   * If you need to keep the queue open indefinitely, consider using it-pushable\n   * instead.\n   */\n  async * toGenerator (options?: AbortOptions): AsyncGenerator<JobReturnType, void, unknown> {\n    options?.signal?.throwIfAborted()\n\n    const stream = pushable<JobReturnType>({\n      objectMode: true\n    })\n\n    const cleanup = (err?: Error): void => {\n      if (err != null) {\n        this.abort()\n      } else {\n        this.clear()\n      }\n\n      stream.end(err)\n    }\n\n    const onQueueJobComplete = (evt: CustomEvent<JobReturnType>): void => {\n      if (evt.detail != null) {\n        stream.push(evt.detail)\n      }\n    }\n\n    const onQueueError = (evt: CustomEvent<Error>): void => {\n      cleanup(evt.detail)\n    }\n\n    const onQueueIdle = (): void => {\n      cleanup()\n    }\n\n    // clear the queue and throw if the query is aborted\n    const onSignalAbort = (): void => {\n      cleanup(new AbortError('Queue aborted'))\n    }\n\n    // add listeners\n    this.addEventListener('completed', onQueueJobComplete)\n    this.addEventListener('error', onQueueError)\n    this.addEventListener('idle', onQueueIdle)\n    options?.signal?.addEventListener('abort', onSignalAbort)\n\n    try {\n      yield * stream\n    } finally {\n      // remove listeners\n      this.removeEventListener('completed', onQueueJobComplete)\n      this.removeEventListener('error', onQueueError)\n      this.removeEventListener('idle', onQueueIdle)\n      options?.signal?.removeEventListener('abort', onSignalAbort)\n\n      // empty the queue for when the user has broken out of a loop early\n      cleanup()\n    }\n  }\n}\n", "import { Queue } from './queue/index.js'\nimport type { QueueInit } from './queue/index.js'\nimport type { AbortOptions } from '@libp2p/interface'\n\nexport interface PriorityQueueJobOptions extends AbortOptions {\n  priority: number\n}\n\nexport class PriorityQueue <JobReturnType = void, JobOptions extends PriorityQueueJobOptions = PriorityQueueJobOptions> extends Queue<JobReturnType, JobOptions> {\n  constructor (init: QueueInit<JobReturnType, JobOptions> = {}) {\n    super({\n      ...init,\n      sort: (a, b) => {\n        if (a.options.priority > b.options.priority) {\n          return -1\n        }\n\n        if (a.options.priority < b.options.priority) {\n          return 1\n        }\n\n        return 0\n      }\n    })\n  }\n}\n", "/**\n * Check if a given ip address is a loopback address\n */\nexport function isLoopbackAddr (ip: string) {\n  return /^127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(ip) ||\n    /^::1$/.test(ip)\n}\n", "import { isLoopbackAddr } from 'is-loopback-addr'\nimport { isIpBased } from './is-ip-based.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n/**\n * Check if a given multiaddr is a loopback address.\n */\nexport function isLoopback (ma: Multiaddr): boolean {\n  if (!isIpBased(ma)) {\n    // not an IP based multiaddr, cannot be private\n    return false\n  }\n\n  const { address } = ma.nodeAddress()\n\n  return isLoopbackAddr(address)\n}\n", "import { isLoopback } from '@libp2p/utils/multiaddr/is-loopback'\nimport { isPrivate } from '@libp2p/utils/multiaddr/is-private'\nimport { Circuit, WebSockets, WebSocketsSecure, WebRTC, WebRTCDirect, WebTransport, TCP } from '@multiformats/multiaddr-matcher'\nimport type { Address } from '@libp2p/interface'\n\n/**\n * Sorts addresses by order of reliability, where they have presented the fewest\n * problems:\n *\n * TCP -> WebSockets/Secure -> WebRTC -> WebRTCDirect -> WebTransport\n */\n// eslint-disable-next-line complexity\nexport function reliableTransportsFirst (a: Address, b: Address): -1 | 0 | 1 {\n  const isATcp = TCP.exactMatch(a.multiaddr)\n  const isBTcp = TCP.exactMatch(b.multiaddr)\n\n  if (isATcp && !isBTcp) {\n    return -1\n  }\n\n  if (!isATcp && isBTcp) {\n    return 1\n  }\n\n  const isAWebSocketSecure = WebSocketsSecure.exactMatch(a.multiaddr)\n  const isBWebSocketSecure = WebSocketsSecure.exactMatch(b.multiaddr)\n\n  if (isAWebSocketSecure && !isBWebSocketSecure) {\n    return -1\n  }\n\n  if (!isAWebSocketSecure && isBWebSocketSecure) {\n    return 1\n  }\n\n  const isAWebSocket = WebSockets.exactMatch(a.multiaddr)\n  const isBWebSocket = WebSockets.exactMatch(b.multiaddr)\n\n  if (isAWebSocket && !isBWebSocket) {\n    return -1\n  }\n\n  if (!isAWebSocket && isBWebSocket) {\n    return 1\n  }\n\n  const isAWebRTC = WebRTC.exactMatch(a.multiaddr)\n  const isBWebRTC = WebRTC.exactMatch(b.multiaddr)\n\n  if (isAWebRTC && !isBWebRTC) {\n    return -1\n  }\n\n  if (!isAWebRTC && isBWebRTC) {\n    return 1\n  }\n\n  const isAWebRTCDirect = WebRTCDirect.exactMatch(a.multiaddr)\n  const isBWebRTCDirect = WebRTCDirect.exactMatch(b.multiaddr)\n\n  if (isAWebRTCDirect && !isBWebRTCDirect) {\n    return -1\n  }\n\n  if (!isAWebRTCDirect && isBWebRTCDirect) {\n    return 1\n  }\n\n  const isAWebTransport = WebTransport.exactMatch(a.multiaddr)\n  const isBWebTransport = WebTransport.exactMatch(b.multiaddr)\n\n  if (isAWebTransport && !isBWebTransport) {\n    return -1\n  }\n\n  if (!isAWebTransport && isBWebTransport) {\n    return 1\n  }\n\n  // ... everything else\n  return 0\n}\n\n/**\n * Compare function for array.sort() that moves loopback addresses to the end\n * of the array.\n */\nexport function loopbackAddressLast (a: Address, b: Address): -1 | 0 | 1 {\n  const isALoopback = isLoopback(a.multiaddr)\n  const isBLoopback = isLoopback(b.multiaddr)\n\n  if (isALoopback && !isBLoopback) {\n    return 1\n  } else if (!isALoopback && isBLoopback) {\n    return -1\n  }\n\n  return 0\n}\n\n/**\n * Compare function for array.sort() that moves public addresses to the start\n * of the array.\n */\nexport function publicAddressesFirst (a: Address, b: Address): -1 | 0 | 1 {\n  const isAPrivate = isPrivate(a.multiaddr)\n  const isBPrivate = isPrivate(b.multiaddr)\n\n  if (isAPrivate && !isBPrivate) {\n    return 1\n  } else if (!isAPrivate && isBPrivate) {\n    return -1\n  }\n\n  return 0\n}\n\n/**\n * Compare function for array.sort() that moves certified addresses to the start\n * of the array.\n */\nexport function certifiedAddressesFirst (a: Address, b: Address): -1 | 0 | 1 {\n  if (a.isCertified && !b.isCertified) {\n    return -1\n  } else if (!a.isCertified && b.isCertified) {\n    return 1\n  }\n\n  return 0\n}\n\n/**\n * Compare function for array.sort() that moves circuit relay addresses to the\n * end of the array.\n */\nexport function circuitRelayAddressesLast (a: Address, b: Address): -1 | 0 | 1 {\n  const isACircuit = Circuit.exactMatch(a.multiaddr)\n  const isBCircuit = Circuit.exactMatch(b.multiaddr)\n\n  if (isACircuit && !isBCircuit) {\n    return 1\n  } else if (!isACircuit && isBCircuit) {\n    return -1\n  }\n\n  return 0\n}\n\nexport function defaultAddressSorter (addresses: Address[]): Address[] {\n  return addresses\n    .sort(reliableTransportsFirst)\n    .sort(certifiedAddressesFirst)\n    .sort(circuitRelayAddressesLast)\n    .sort(publicAddressesFirst)\n    .sort(loopbackAddressLast)\n}\n", "/* eslint-disable max-depth */\nimport { TimeoutError, DialError, setMaxListeners, AbortError } from '@libp2p/interface'\nimport { PeerMap } from '@libp2p/peer-collections'\nimport { PriorityQueue } from '@libp2p/utils/priority-queue'\nimport { resolvers, multiaddr } from '@multiformats/multiaddr'\nimport { dnsaddrResolver } from '@multiformats/multiaddr/resolvers'\nimport { Circuit } from '@multiformats/multiaddr-matcher'\nimport { anySignal } from 'any-signal'\nimport { CustomProgressEvent } from 'progress-events'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { DialDeniedError, NoValidAddressesError } from '../errors.js'\nimport { getPeerAddress } from '../get-peer.js'\nimport { defaultAddressSorter } from './address-sorter.js'\nimport {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS,\n  MAX_PEER_ADDRS_TO_DIAL,\n  LAST_DIAL_FAILURE_KEY,\n  MAX_DIAL_QUEUE_LENGTH,\n  LAST_DIAL_SUCCESS_KEY\n} from './constants.js'\nimport { resolveMultiaddrs } from './utils.js'\nimport { DEFAULT_DIAL_PRIORITY } from './index.js'\nimport type { AddressSorter, ComponentLogger, Logger, Connection, ConnectionGater, Metrics, PeerId, Address, PeerStore, PeerRouting, IsDialableOptions, OpenConnectionProgressEvents } from '@libp2p/interface'\nimport type { OpenConnectionOptions, TransportManager } from '@libp2p/interface-internal'\nimport type { PriorityQueueJobOptions } from '@libp2p/utils/priority-queue'\nimport type { DNS } from '@multiformats/dns'\nimport type { Multiaddr, Resolver } from '@multiformats/multiaddr'\nimport type { ProgressOptions } from 'progress-events'\n\nexport interface PendingDialTarget {\n  resolve(value: any): void\n  reject(err: Error): void\n}\n\ninterface DialQueueJobOptions extends PriorityQueueJobOptions, ProgressOptions<OpenConnectionProgressEvents> {\n  peerId?: PeerId\n  multiaddrs: Set<string>\n}\n\ninterface DialerInit {\n  addressSorter?: AddressSorter\n  maxParallelDials?: number\n  maxDialQueueLength?: number\n  maxPeerAddrsToDial?: number\n  dialTimeout?: number\n  resolvers?: Record<string, Resolver>\n  connections?: PeerMap<Connection[]>\n}\n\nconst defaultOptions = {\n  maxParallelDials: MAX_PARALLEL_DIALS,\n  maxDialQueueLength: MAX_DIAL_QUEUE_LENGTH,\n  maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,\n  dialTimeout: DIAL_TIMEOUT,\n  resolvers: {\n    dnsaddr: dnsaddrResolver\n  }\n}\n\ninterface DialQueueComponents {\n  peerId: PeerId\n  metrics?: Metrics\n  peerStore: PeerStore\n  peerRouting: PeerRouting\n  transportManager: TransportManager\n  connectionGater: ConnectionGater\n  logger: ComponentLogger\n  dns?: DNS\n}\n\nexport class DialQueue {\n  public queue: PriorityQueue<Connection, DialQueueJobOptions>\n  private readonly components: DialQueueComponents\n  private readonly addressSorter?: AddressSorter\n  private readonly maxPeerAddrsToDial: number\n  private readonly maxDialQueueLength: number\n  private readonly dialTimeout: number\n  private shutDownController: AbortController\n  private readonly connections: PeerMap<Connection[]>\n  private readonly log: Logger\n\n  constructor (components: DialQueueComponents, init: DialerInit = {}) {\n    this.addressSorter = init.addressSorter\n    this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions.maxPeerAddrsToDial\n    this.maxDialQueueLength = init.maxDialQueueLength ?? defaultOptions.maxDialQueueLength\n    this.dialTimeout = init.dialTimeout ?? defaultOptions.dialTimeout\n    this.connections = init.connections ?? new PeerMap()\n    this.log = components.logger.forComponent('libp2p:connection-manager:dial-queue')\n    this.components = components\n\n    this.shutDownController = new AbortController()\n    setMaxListeners(Infinity, this.shutDownController.signal)\n\n    for (const [key, value] of Object.entries(init.resolvers ?? {})) {\n      resolvers.set(key, value)\n    }\n\n    // controls dial concurrency\n    this.queue = new PriorityQueue({\n      concurrency: init.maxParallelDials ?? defaultOptions.maxParallelDials,\n      metricName: 'libp2p_dial_queue',\n      metrics: components.metrics\n    })\n    // a started job errored\n    this.queue.addEventListener('error', (event) => {\n      if (event.detail.name !== AbortError.name) {\n        this.log.error('error in dial queue - %e', event.detail)\n      }\n    })\n  }\n\n  start (): void {\n    this.shutDownController = new AbortController()\n    setMaxListeners(Infinity, this.shutDownController.signal)\n  }\n\n  /**\n   * Clears any pending dials\n   */\n  stop (): void {\n    this.shutDownController.abort()\n    this.queue.abort()\n  }\n\n  /**\n   * Connects to a given peer, multiaddr or list of multiaddrs.\n   *\n   * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or\n   * multiaddrs are passed only those will be dialled.\n   *\n   * Where a list of multiaddrs is passed, if any contain a peer id then all\n   * multiaddrs in the list must contain the same peer id.\n   *\n   * The dial to the first address that is successfully able to upgrade a\n   * connection will be used, all other dials will be aborted when that happens.\n   */\n  async dial (peerIdOrMultiaddr: PeerId | Multiaddr | Multiaddr[], options: OpenConnectionOptions = {}): Promise<Connection> {\n    const { peerId, multiaddrs } = getPeerAddress(peerIdOrMultiaddr)\n\n    // make sure we don't have an existing connection to any of the addresses we\n    // are about to dial\n    const existingConnection = Array.from(this.connections.values()).flat().find(conn => {\n      if (options.force === true) {\n        return false\n      }\n\n      if (conn.remotePeer.equals(peerId)) {\n        return true\n      }\n\n      return multiaddrs.find(addr => {\n        return addr.equals(conn.remoteAddr)\n      })\n    })\n\n    if (existingConnection?.status === 'open') {\n      this.log('already connected to %a', existingConnection.remoteAddr)\n      options.onProgress?.(new CustomProgressEvent('dial-queue:already-connected'))\n      return existingConnection\n    }\n\n    // ready to dial, all async work finished - make sure we don't have any\n    // pending dials in progress for this peer or set of multiaddrs\n    const existingDial = this.queue.queue.find(job => {\n      if (peerId?.equals(job.options.peerId) === true) {\n        return true\n      }\n\n      // does the dial contain any of the target multiaddrs?\n      const addresses = job.options.multiaddrs\n\n      if (addresses == null) {\n        return false\n      }\n\n      for (const multiaddr of multiaddrs) {\n        if (addresses.has(multiaddr.toString())) {\n          return true\n        }\n      }\n\n      return false\n    })\n\n    if (existingDial != null) {\n      this.log('joining existing dial target for %p', peerId)\n\n      // add all multiaddrs to the dial target\n      for (const multiaddr of multiaddrs) {\n        existingDial.options.multiaddrs.add(multiaddr.toString())\n      }\n\n      options.onProgress?.(new CustomProgressEvent('dial-queue:already-in-dial-queue'))\n      return existingDial.join(options)\n    }\n\n    if (this.queue.size >= this.maxDialQueueLength) {\n      throw new DialError('Dial queue is full')\n    }\n\n    this.log('creating dial target for %p', peerId, multiaddrs.map(ma => ma.toString()))\n\n    options.onProgress?.(new CustomProgressEvent('dial-queue:add-to-dial-queue'))\n    return this.queue.add(async (options) => {\n      options.onProgress?.(new CustomProgressEvent('dial-queue:start-dial'))\n      // create abort conditions - need to do this before `calculateMultiaddrs` as\n      // we may be about to resolve a dns addr which can time out\n      const signal = anySignal([\n        this.shutDownController.signal,\n        options.signal\n      ])\n      setMaxListeners(Infinity, signal)\n\n      try {\n        return await this.dialPeer(options, signal)\n      } finally {\n        // clean up abort signals/controllers\n        signal.clear()\n      }\n    }, {\n      peerId,\n      priority: options.priority ?? DEFAULT_DIAL_PRIORITY,\n      multiaddrs: new Set(multiaddrs.map(ma => ma.toString())),\n      signal: options.signal ?? AbortSignal.timeout(this.dialTimeout),\n      onProgress: options.onProgress\n    })\n  }\n\n  private async dialPeer (options: DialQueueJobOptions, signal: AbortSignal): Promise<Connection> {\n    const peerId = options.peerId\n    const multiaddrs = options.multiaddrs\n    const failedMultiaddrs = new Set<string>()\n\n    // if we have no multiaddrs, only a peer id, set a flag so we will look the\n    // peer up in the peer routing to obtain multiaddrs\n    let forcePeerLookup = options.multiaddrs.size === 0\n\n    let dialed = 0\n    let dialIteration = 0\n    const errors: Error[] = []\n\n    this.log('starting dial to %p', peerId)\n\n    // repeat this operation in case addresses are added to the dial while we\n    // resolve multiaddrs, etc\n    while (forcePeerLookup || multiaddrs.size > 0) {\n      dialIteration++\n\n      // only perform peer lookup once\n      forcePeerLookup = false\n\n      // the addresses we will dial\n      const addrsToDial: Address[] = []\n\n      // copy the addresses into a new set\n      const addrs = new Set(options.multiaddrs)\n\n      // empty the old set - subsequent dial attempts for the same peer id may\n      // add more addresses to try\n      multiaddrs.clear()\n\n      this.log('calculating addrs to dial %p from %s', peerId, [...addrs])\n\n      // load addresses from address book, resolve and dnsaddrs, filter\n      // undialables, add peer IDs, etc\n      const calculatedAddrs = await this.calculateMultiaddrs(peerId, addrs, {\n        ...options,\n        signal\n      })\n\n      for (const addr of calculatedAddrs) {\n        // skip any addresses we have previously failed to dial\n        if (failedMultiaddrs.has(addr.multiaddr.toString())) {\n          this.log.trace('skipping previously failed multiaddr %a while dialing %p', addr.multiaddr, peerId)\n          continue\n        }\n\n        addrsToDial.push(addr)\n      }\n\n      this.log('%s dial to %p with %s', dialIteration === 1 ? 'starting' : 'continuing', peerId, addrsToDial.map(ma => ma.multiaddr.toString()))\n\n      options?.onProgress?.(new CustomProgressEvent<Address[]>('dial-queue:calculated-addresses', addrsToDial))\n\n      for (const address of addrsToDial) {\n        if (dialed === this.maxPeerAddrsToDial) {\n          this.log('dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others', dialed, options.peerId)\n\n          throw new DialError('Peer had more than maxPeerAddrsToDial')\n        }\n\n        dialed++\n\n        try {\n          // try to dial the address\n          const conn = await this.components.transportManager.dial(address.multiaddr, {\n            ...options,\n            signal\n          })\n\n          this.log('dial to %a succeeded', address.multiaddr)\n\n          // record the successful dial and the address\n          try {\n            await this.components.peerStore.merge(conn.remotePeer, {\n              multiaddrs: [\n                conn.remoteAddr\n              ],\n              metadata: {\n                [LAST_DIAL_SUCCESS_KEY]: uint8ArrayFromString(Date.now().toString())\n              }\n            })\n          } catch (err: any) {\n            this.log.error('could not update last dial failure key for %p', peerId, err)\n          }\n\n          // dial successful, return the connection\n          return conn\n        } catch (err: any) {\n          this.log.error('dial failed to %a', address.multiaddr, err)\n\n          // ensure we don't dial it again in this attempt\n          failedMultiaddrs.add(address.multiaddr.toString())\n\n          if (peerId != null) {\n            // record the failed dial\n            try {\n              await this.components.peerStore.merge(peerId, {\n                metadata: {\n                  [LAST_DIAL_FAILURE_KEY]: uint8ArrayFromString(Date.now().toString())\n                }\n              })\n            } catch (err: any) {\n              this.log.error('could not update last dial failure key for %p', peerId, err)\n            }\n          }\n\n          // the user/dial timeout/shutdown controller signal aborted\n          if (signal.aborted) {\n            throw new TimeoutError(err.message)\n          }\n\n          errors.push(err)\n        }\n      }\n    }\n\n    if (errors.length === 1) {\n      throw errors[0]\n    }\n\n    throw new AggregateError(errors, 'All multiaddr dials failed')\n  }\n\n  // eslint-disable-next-line complexity\n  private async calculateMultiaddrs (peerId?: PeerId, multiaddrs: Set<string> = new Set<string>(), options: OpenConnectionOptions = {}): Promise<Address[]> {\n    const addrs: Address[] = [...multiaddrs].map(ma => ({\n      multiaddr: multiaddr(ma),\n      isCertified: false\n    }))\n\n    // if a peer id or multiaddr(s) with a peer id, make sure it isn't our peer id and that we are allowed to dial it\n    if (peerId != null) {\n      if (this.components.peerId.equals(peerId)) {\n        throw new DialError('Tried to dial self')\n      }\n\n      if ((await this.components.connectionGater.denyDialPeer?.(peerId)) === true) {\n        throw new DialDeniedError('The dial request is blocked by gater.allowDialPeer')\n      }\n\n      // if just a peer id was passed, load available multiaddrs for this peer\n      // from the peer store\n      if (addrs.length === 0) {\n        this.log('loading multiaddrs for %p', peerId)\n        try {\n          const peer = await this.components.peerStore.get(peerId)\n          addrs.push(...peer.addresses)\n          this.log('loaded multiaddrs for %p', peerId, addrs.map(({ multiaddr }) => multiaddr.toString()))\n        } catch (err: any) {\n          if (err.name !== 'NotFoundError') {\n            throw err\n          }\n        }\n      }\n\n      // if we still don't have any addresses for this peer, try a lookup\n      // using the peer routing\n      if (addrs.length === 0) {\n        this.log('looking up multiaddrs for %p in the peer routing', peerId)\n\n        try {\n          const peerInfo = await this.components.peerRouting.findPeer(peerId, options)\n\n          this.log('found multiaddrs for %p in the peer routing', peerId, addrs.map(({ multiaddr }) => multiaddr.toString()))\n\n          addrs.push(...peerInfo.multiaddrs.map(multiaddr => ({\n            multiaddr,\n            isCertified: false\n          })))\n        } catch (err: any) {\n          if (err.name === 'NoPeerRoutersError') {\n            this.log('no peer routers configured', peerId)\n          } else {\n            this.log.error('looking up multiaddrs for %p in the peer routing failed - %e', peerId, err)\n          }\n        }\n      }\n    }\n\n    // resolve addresses - this can result in a one-to-many translation when\n    // dnsaddrs are resolved\n    let resolvedAddresses = (await Promise.all(\n      addrs.map(async addr => {\n        const result = await resolveMultiaddrs(addr.multiaddr, {\n          dns: this.components.dns,\n          ...options,\n          log: this.log\n        })\n\n        if (result.length === 1 && result[0].equals(addr.multiaddr)) {\n          return addr\n        }\n\n        return result.map(multiaddr => ({\n          multiaddr,\n          isCertified: false\n        }))\n      })\n    ))\n      .flat()\n\n    // ensure the peer id is appended to the multiaddr\n    if (peerId != null) {\n      const peerIdMultiaddr = `/p2p/${peerId.toString()}`\n      resolvedAddresses = resolvedAddresses.map(addr => {\n        const lastProto = addr.multiaddr.protos().pop()\n\n        // do not append peer id to path multiaddrs\n        if (lastProto?.path === true) {\n          return addr\n        }\n\n        // append peer id to multiaddr if it is not already present\n        if (addr.multiaddr.getPeerId() == null) {\n          return {\n            multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),\n            isCertified: addr.isCertified\n          }\n        }\n\n        return addr\n      })\n    }\n\n    const filteredAddrs = resolvedAddresses.filter(addr => {\n      // filter out any multiaddrs that we do not have transports for\n      if (this.components.transportManager.dialTransportForMultiaddr(addr.multiaddr) == null) {\n        return false\n      }\n\n      // if the resolved multiaddr has a PeerID but it's the wrong one, ignore it\n      // - this can happen with addresses like bootstrap.libp2p.io that resolve\n      // to multiple different peers\n      const addrPeerId = addr.multiaddr.getPeerId()\n      if (peerId != null && addrPeerId != null) {\n        return peerId.equals(addrPeerId)\n      }\n\n      return true\n    })\n\n    // deduplicate addresses\n    const dedupedAddrs = new Map<string, Address>()\n\n    for (const addr of filteredAddrs) {\n      const maStr = addr.multiaddr.toString()\n      const existing = dedupedAddrs.get(maStr)\n\n      if (existing != null) {\n        existing.isCertified = existing.isCertified || addr.isCertified || false\n        continue\n      }\n\n      dedupedAddrs.set(maStr, addr)\n    }\n\n    const dedupedMultiaddrs = [...dedupedAddrs.values()]\n\n    // make sure we actually have some addresses to dial\n    if (dedupedMultiaddrs.length === 0) {\n      throw new NoValidAddressesError('The dial request has no valid addresses')\n    }\n\n    const gatedAddrs: Address[] = []\n\n    for (const addr of dedupedMultiaddrs) {\n      if (this.components.connectionGater.denyDialMultiaddr != null && await this.components.connectionGater.denyDialMultiaddr(addr.multiaddr)) {\n        continue\n      }\n\n      gatedAddrs.push(addr)\n    }\n\n    const sortedGatedAddrs = this.addressSorter == null ? defaultAddressSorter(gatedAddrs) : gatedAddrs.sort(this.addressSorter)\n\n    // make sure we actually have some addresses to dial\n    if (sortedGatedAddrs.length === 0) {\n      throw new DialDeniedError('The connection gater denied all addresses in the dial request')\n    }\n\n    this.log.trace('addresses for %p before filtering', peerId ?? 'unknown peer', resolvedAddresses.map(({ multiaddr }) => multiaddr.toString()))\n    this.log.trace('addresses for %p after filtering', peerId ?? 'unknown peer', sortedGatedAddrs.map(({ multiaddr }) => multiaddr.toString()))\n\n    return sortedGatedAddrs\n  }\n\n  async isDialable (multiaddr: Multiaddr | Multiaddr[], options: IsDialableOptions = {}): Promise<boolean> {\n    if (!Array.isArray(multiaddr)) {\n      multiaddr = [multiaddr]\n    }\n\n    try {\n      const addresses = await this.calculateMultiaddrs(undefined, new Set(multiaddr.map(ma => ma.toString())), options)\n\n      if (options.runOnLimitedConnection === false) {\n        // return true if any resolved multiaddrs are not relay addresses\n        return addresses.find(addr => {\n          return !Circuit.matches(addr.multiaddr)\n        }) != null\n      }\n\n      return true\n    } catch (err) {\n      this.log.trace('error calculating if multiaddr(s) were dialable', err)\n    }\n\n    return false\n  }\n}\n", "import { Queue } from './queue/index.js'\nimport type { Job } from './queue/job.js'\nimport type { AbortOptions, PeerId } from '@libp2p/interface'\n\nexport interface PeerQueueJobOptions extends AbortOptions {\n  peerId: PeerId\n}\n\n/**\n * Extends Queue to add support for querying queued jobs by peer id\n */\nexport class PeerQueue<JobReturnType = void, JobOptions extends PeerQueueJobOptions = PeerQueueJobOptions> extends Queue<JobReturnType, JobOptions> {\n  has (peerId: PeerId): boolean {\n    return this.find(peerId) != null\n  }\n\n  find (peerId: PeerId): Job<JobOptions, JobReturnType> | undefined {\n    return this.queue.find(job => {\n      return peerId.equals(job.options.peerId)\n    })\n  }\n}\n", "import retry from 'retry';\nimport isNetworkError from 'is-network-error';\n\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\n\t\tif (message instanceof Error) {\n\t\t\tthis.originalError = message;\n\t\t\t({message} = message);\n\t\t} else {\n\t\t\tthis.originalError = new Error(message);\n\t\t\tthis.originalError.stack = this.stack;\n\t\t}\n\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\nconst decorateErrorWithCounts = (error, attemptNumber, options) => {\n\t// Minus 1 from attemptNumber because the first attempt does not count as a retry\n\tconst retriesLeft = options.retries - (attemptNumber - 1);\n\n\terror.attemptNumber = attemptNumber;\n\terror.retriesLeft = retriesLeft;\n\treturn error;\n};\n\nexport default async function pRetry(input, options) {\n\treturn new Promise((resolve, reject) => {\n\t\toptions = {...options};\n\t\toptions.onFailedAttempt ??= () => {};\n\t\toptions.shouldRetry ??= () => true;\n\t\toptions.retries ??= 10;\n\n\t\tconst operation = retry.operation(options);\n\n\t\tconst abortHandler = () => {\n\t\t\toperation.stop();\n\t\t\treject(options.signal?.reason);\n\t\t};\n\n\t\tif (options.signal && !options.signal.aborted) {\n\t\t\toptions.signal.addEventListener('abort', abortHandler, {once: true});\n\t\t}\n\n\t\tconst cleanUp = () => {\n\t\t\toptions.signal?.removeEventListener('abort', abortHandler);\n\t\t\toperation.stop();\n\t\t};\n\n\t\toperation.attempt(async attemptNumber => {\n\t\t\ttry {\n\t\t\t\tconst result = await input(attemptNumber);\n\t\t\t\tcleanUp();\n\t\t\t\tresolve(result);\n\t\t\t} catch (error) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!(error instanceof Error)) {\n\t\t\t\t\t\tthrow new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error instanceof AbortError) {\n\t\t\t\t\t\tthrow error.originalError;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error instanceof TypeError && !isNetworkError(error)) {\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\n\t\t\t\t\tdecorateErrorWithCounts(error, attemptNumber, options);\n\n\t\t\t\t\tif (!(await options.shouldRetry(error))) {\n\t\t\t\t\t\toperation.stop();\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tawait options.onFailedAttempt(error);\n\n\t\t\t\t\tif (!operation.retry(error)) {\n\t\t\t\t\t\tthrow operation.mainError();\n\t\t\t\t\t}\n\t\t\t\t} catch (finalError) {\n\t\t\t\t\tdecorateErrorWithCounts(finalError, attemptNumber, options);\n\t\t\t\t\tcleanUp();\n\t\t\t\t\treject(finalError);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n", "const objectToString = Object.prototype.toString;\n\nconst isError = value => objectToString.call(value) === '[object Error]';\n\nconst errorMessages = new Set([\n\t'network error', // Chrome\n\t'Failed to fetch', // Chrome\n\t'NetworkError when attempting to fetch resource.', // Firefox\n\t'The Internet connection appears to be offline.', // Safari 16\n\t'Load failed', // Safari 17+\n\t'Network request failed', // `cross-fetch`\n\t'fetch failed', // Undici (Node.js)\n\t'terminated', // Undici (Node.js)\n]);\n\nexport default function isNetworkError(error) {\n\tconst isValid = error\n\t\t&& isError(error)\n\t\t&& error.name === 'TypeError'\n\t\t&& typeof error.message === 'string';\n\n\tif (!isValid) {\n\t\treturn false;\n\t}\n\n\t// We do an extra check for Safari 17+ as it has a very generic error message.\n\t// Network errors in Safari have no stack.\n\tif (error.message === 'Load failed') {\n\t\treturn error.stack === undefined;\n\t}\n\n\treturn errorMessages.has(error.message);\n}\n", "import { KEEP_ALIVE } from '@libp2p/interface'\nimport { PeerQueue } from '@libp2p/utils/peer-queue'\nimport pRetry from 'p-retry'\nimport { MAX_PARALLEL_RECONNECTS } from './constants.js'\nimport type { ComponentLogger, Libp2pEvents, Logger, Metrics, Peer, PeerId, PeerStore, Startable, TypedEventTarget } from '@libp2p/interface'\nimport type { ConnectionManager } from '@libp2p/interface-internal'\n\nexport interface ReconnectQueueComponents {\n  connectionManager: ConnectionManager\n  events: TypedEventTarget<Libp2pEvents>\n  peerStore: PeerStore\n  logger: ComponentLogger\n  metrics?: Metrics\n}\n\nexport interface ReconnectQueueInit {\n  retries?: number\n  retryInterval?: number\n  backoffFactor?: number\n  maxParallelReconnects?: number\n}\n\n/**\n * When peers tagged with `KEEP_ALIVE` disconnect, this component attempts to\n * redial them\n */\nexport class ReconnectQueue implements Startable {\n  private readonly log: Logger\n  private readonly queue: PeerQueue\n  private started: boolean\n  private readonly peerStore: PeerStore\n  private readonly retries: number\n  private readonly retryInterval?: number\n  private readonly backoffFactor?: number\n  private readonly connectionManager: ConnectionManager\n  private readonly events: TypedEventTarget<Libp2pEvents>\n\n  constructor (components: ReconnectQueueComponents, init: ReconnectQueueInit = {}) {\n    this.log = components.logger.forComponent('libp2p:reconnect-queue')\n    this.peerStore = components.peerStore\n    this.connectionManager = components.connectionManager\n    this.queue = new PeerQueue({\n      concurrency: init.maxParallelReconnects ?? MAX_PARALLEL_RECONNECTS,\n      metricName: 'libp2p_reconnect_queue',\n      metrics: components.metrics\n    })\n    this.started = false\n    this.retries = init.retries ?? 5\n    this.backoffFactor = init.backoffFactor\n    this.retryInterval = init.retryInterval\n    this.events = components.events\n\n    components.events.addEventListener('peer:disconnect', (evt) => {\n      this.maybeReconnect(evt.detail)\n        .catch(err => {\n          this.log.error('failed to maybe reconnect to %p - %e', evt.detail, err)\n        })\n    })\n  }\n\n  private async maybeReconnect (peerId: PeerId): Promise<void> {\n    if (!this.started) {\n      return\n    }\n\n    const peer = await this.peerStore.get(peerId)\n\n    if (!hasKeepAliveTag(peer)) {\n      return\n    }\n\n    if (this.queue.has(peerId)) {\n      return\n    }\n\n    this.queue.add(async (options) => {\n      await pRetry(async (attempt) => {\n        if (!this.started) {\n          return\n        }\n\n        try {\n          await this.connectionManager.openConnection(peerId, {\n            signal: options?.signal\n          })\n        } catch (err) {\n          this.log('reconnecting to %p attempt %d of %d failed - %e', peerId, attempt, this.retries, err)\n          throw err\n        }\n      }, {\n        signal: options?.signal,\n        retries: this.retries,\n        factor: this.backoffFactor,\n        minTimeout: this.retryInterval\n      })\n    }, {\n      peerId\n    })\n      .catch(async err => {\n        this.log.error('failed to reconnect to %p - %e', peerId, err)\n\n        const tags: Record<string, undefined> = {}\n\n        ;[...peer.tags.keys()].forEach(key => {\n          if (key.startsWith(KEEP_ALIVE)) {\n            tags[key] = undefined\n          }\n        })\n\n        await this.peerStore.merge(peerId, {\n          tags\n        })\n\n        this.events.safeDispatchEvent('peer:reconnect-failure', {\n          detail: peerId\n        })\n      })\n      .catch(async err => {\n        this.log.error('failed to remove keep-alive tag from %p - %e', peerId, err)\n      })\n  }\n\n  start (): void {\n    this.started = true\n  }\n\n  async afterStart (): Promise<void> {\n    // re-connect to any peers with the KEEP_ALIVE tag\n    void Promise.resolve()\n      .then(async () => {\n        const keepAlivePeers: Peer[] = await this.peerStore.all({\n          filters: [\n            (peer) => hasKeepAliveTag(peer)\n          ]\n        })\n\n        await Promise.all(\n          keepAlivePeers.map(async peer => {\n            await this.connectionManager.openConnection(peer.id)\n              .catch(err => {\n                this.log.error(err)\n              })\n          })\n        )\n      })\n      .catch(err => {\n        this.log.error(err)\n      })\n  }\n\n  stop (): void {\n    this.started = false\n    this.queue.abort()\n  }\n}\n\nfunction hasKeepAliveTag (peer: Peer): boolean {\n  for (const tag of peer.tags.keys()) {\n    if (tag.startsWith(KEEP_ALIVE)) {\n      return true\n    }\n  }\n\n  return false\n}\n", "import { ConnectionClosedError, InvalidMultiaddrError, InvalidParametersError, InvalidPeerIdError, NotStartedError, start, stop } from '@libp2p/interface'\nimport { PeerMap } from '@libp2p/peer-collections'\nimport { RateLimiter } from '@libp2p/utils/rate-limiter'\nimport { type Multiaddr, type Resolver, multiaddr } from '@multiformats/multiaddr'\nimport { dnsaddrResolver } from '@multiformats/multiaddr/resolvers'\nimport { CustomProgressEvent } from 'progress-events'\nimport { getPeerAddress } from '../get-peer.js'\nimport { ConnectionPruner } from './connection-pruner.js'\nimport { DIAL_TIMEOUT, INBOUND_CONNECTION_THRESHOLD, MAX_CONNECTIONS, MAX_DIAL_QUEUE_LENGTH, MAX_INCOMING_PENDING_CONNECTIONS, MAX_PARALLEL_DIALS, MAX_PEER_ADDRS_TO_DIAL } from './constants.js'\nimport { DialQueue } from './dial-queue.js'\nimport { ReconnectQueue } from './reconnect-queue.js'\nimport { multiaddrToIpNet } from './utils.js'\nimport type { IpNet } from '@chainsafe/netmask'\nimport type { PendingDial, AddressSorter, Libp2pEvents, AbortOptions, ComponentLogger, Logger, Connection, MultiaddrConnection, ConnectionGater, TypedEventTarget, Metrics, PeerId, PeerStore, Startable, PendingDialStatus, PeerRouting, IsDialableOptions } from '@libp2p/interface'\nimport type { ConnectionManager, OpenConnectionOptions, TransportManager } from '@libp2p/interface-internal'\nimport type { JobStatus } from '@libp2p/utils/queue'\n\nexport const DEFAULT_DIAL_PRIORITY = 50\n\nexport interface ConnectionManagerInit {\n  /**\n   * The maximum number of connections libp2p is willing to have before it\n   * starts pruning connections to reduce resource usage.\n   *\n   * @default 300/100\n   */\n  maxConnections?: number\n\n  /**\n   * Sort the known addresses of a peer before trying to dial, By default public\n   * addresses will be dialled before private (e.g. loopback or LAN) addresses.\n   */\n  addressSorter?: AddressSorter\n\n  /**\n   * The maximum number of dials across all peers to execute in parallel.\n   *\n   * @default 100/50\n   */\n  maxParallelDials?: number\n\n  /**\n   * The maximum size the dial queue is allowed to grow to. Promises returned\n   * when dialing peers after this limit is reached will not resolve until the\n   * queue size falls beneath this size.\n   *\n   * @default 500\n   */\n  maxDialQueueLength?: number\n\n  /**\n   * Maximum number of addresses allowed for a given peer before giving up\n   *\n   * @default 25\n   */\n  maxPeerAddrsToDial?: number\n\n  /**\n   * How long a dial attempt is allowed to take, including DNS resolution\n   * of the multiaddr, opening a socket and upgrading it to a Connection.\n   *\n   * @default 10_000\n   */\n  dialTimeout?: number\n\n  /**\n   * When a new incoming connection is opened, the upgrade process (e.g.\n   * protect, encrypt, multiplex etc) must complete within this number of ms.\n   *\n   * @default 10_000\n   */\n  inboundUpgradeTimeout?: number\n\n  /**\n   * When a new outbound connection is opened, the upgrade process (e.g.\n   * protect, encrypt, multiplex etc) must complete within this number of ms.\n   *\n   * Does not apply if an abort signal is passed to the `.dial` method.\n   *\n   * @deprecated This is handled by `dialTimeout`\n   */\n  outboundUpgradeTimeout?: number\n\n  /**\n   * Protocol negotiation must complete within this number of ms\n   *\n   * @default 2000\n   * @deprecated use outboundStreamProtocolNegotiationTimeout or inboundStreamProtocolNegotiationTimeout instead\n   */\n  protocolNegotiationTimeout?: number\n\n  /**\n   * Outbound protocol negotiation must complete within this number of ms.\n   *\n   * Does not apply if an abort signal is passed to the `.dial` or\n   * `.dialProtocol` method of the `ConnectionManager` or the `openStream`\n   * method of the `Connection`.\n   *\n   * @default 10_000\n   */\n  outboundStreamProtocolNegotiationTimeout?: number\n\n  /**\n   * Inbound protocol negotiation must complete within this number of ms\n   *\n   * @default 10_000\n   */\n  inboundStreamProtocolNegotiationTimeout?: number\n\n  /**\n   * Multiaddr resolvers to use when dialling\n   */\n  resolvers?: Record<string, Resolver>\n\n  /**\n   * A list of multiaddrs that will always be allowed (except if they are in the\n   * deny list) to open connections to this node even if we've reached\n   * maxConnections\n   */\n  allow?: string[]\n\n  /**\n   * A list of multiaddrs that will never be allowed to open connections to\n   * this node under any circumstances\n   */\n  deny?: string[]\n\n  /**\n   * If more than this many connections are opened per second by a single\n   * host, reject subsequent connections.\n   *\n   * @default 5\n   */\n  inboundConnectionThreshold?: number\n\n  /**\n   * The maximum number of parallel incoming connections allowed that have yet\n   * to complete the connection upgrade - e.g. choosing connection encryption,\n   * muxer, etc.\n   *\n   * @default 10\n   */\n  maxIncomingPendingConnections?: number\n\n  /**\n   * When a peer tagged with `KEEP_ALIVE` disconnects, attempt to redial them\n   * this many times.\n   *\n   * @default 5\n   */\n  reconnectRetries?: number\n\n  /**\n   * When a peer tagged with `KEEP_ALIVE` disconnects, wait this long between\n   * each retry. Note this will be multiplied by `reconnectFactor` to create an\n   * increasing retry backoff.\n   *\n   * @default 1000\n   */\n  reconnectRetryInterval?: number\n\n  /**\n   * When a peer tagged with `KEEP_ALIVE` disconnects, apply this multiplication\n   * factor to the time interval between each retry.\n   *\n   * @default 2\n   */\n  reconnectBackoffFactor?: number\n\n  /**\n   * When a peers tagged with `KEEP_ALIVE` disconnect, reconnect to this many at\n   * once.\n   *\n   * @default 5\n   */\n  maxParallelReconnects?: number\n}\n\nconst defaultOptions = {\n  maxConnections: MAX_CONNECTIONS,\n  inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,\n  maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS\n}\n\nexport interface DefaultConnectionManagerComponents {\n  peerId: PeerId\n  metrics?: Metrics\n  peerStore: PeerStore\n  peerRouting: PeerRouting\n  transportManager: TransportManager\n  connectionGater: ConnectionGater\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\n/**\n * Responsible for managing known connections.\n */\nexport class DefaultConnectionManager implements ConnectionManager, Startable {\n  private started: boolean\n  private readonly connections: PeerMap<Connection[]>\n  private readonly allow: IpNet[]\n  private readonly deny: IpNet[]\n  private readonly maxIncomingPendingConnections: number\n  private incomingPendingConnections: number\n  private outboundPendingConnections: number\n  private readonly maxConnections: number\n\n  public readonly dialQueue: DialQueue\n  public readonly reconnectQueue: ReconnectQueue\n  public readonly connectionPruner: ConnectionPruner\n  private readonly inboundConnectionRateLimiter: RateLimiter\n  private readonly peerStore: PeerStore\n  private readonly metrics?: Metrics\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly log: Logger\n  private readonly peerId: PeerId\n\n  constructor (components: DefaultConnectionManagerComponents, init: ConnectionManagerInit = {}) {\n    this.maxConnections = init.maxConnections ?? defaultOptions.maxConnections\n\n    if (this.maxConnections < 1) {\n      throw new InvalidParametersError('Connection Manager maxConnections must be greater than 0')\n    }\n\n    /**\n     * Map of connections per peer\n     */\n    this.connections = new PeerMap()\n\n    this.started = false\n    this.peerId = components.peerId\n    this.peerStore = components.peerStore\n    this.metrics = components.metrics\n    this.events = components.events\n    this.log = components.logger.forComponent('libp2p:connection-manager')\n\n    this.onConnect = this.onConnect.bind(this)\n    this.onDisconnect = this.onDisconnect.bind(this)\n\n    // allow/deny lists\n    this.allow = (init.allow ?? []).map(str => multiaddrToIpNet(str))\n    this.deny = (init.deny ?? []).map(str => multiaddrToIpNet(str))\n\n    this.incomingPendingConnections = 0\n    this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions.maxIncomingPendingConnections\n    this.outboundPendingConnections = 0\n\n    // controls individual peers trying to dial us too quickly\n    this.inboundConnectionRateLimiter = new RateLimiter({\n      points: init.inboundConnectionThreshold ?? defaultOptions.inboundConnectionThreshold,\n      duration: 1\n    })\n\n    // controls what happens when we have too many connections\n    this.connectionPruner = new ConnectionPruner({\n      connectionManager: this,\n      peerStore: components.peerStore,\n      events: components.events,\n      logger: components.logger\n    }, {\n      maxConnections: this.maxConnections,\n      allow: init.allow?.map(a => multiaddr(a))\n    })\n\n    this.dialQueue = new DialQueue(components, {\n      addressSorter: init.addressSorter,\n      maxParallelDials: init.maxParallelDials ?? MAX_PARALLEL_DIALS,\n      maxDialQueueLength: init.maxDialQueueLength ?? MAX_DIAL_QUEUE_LENGTH,\n      maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,\n      dialTimeout: init.dialTimeout ?? DIAL_TIMEOUT,\n      resolvers: init.resolvers ?? {\n        dnsaddr: dnsaddrResolver\n      },\n      connections: this.connections\n    })\n\n    this.reconnectQueue = new ReconnectQueue({\n      events: components.events,\n      peerStore: components.peerStore,\n      logger: components.logger,\n      connectionManager: this\n    }, {\n      retries: init.reconnectRetries,\n      retryInterval: init.reconnectRetryInterval,\n      backoffFactor: init.reconnectBackoffFactor,\n      maxParallelReconnects: init.maxParallelReconnects\n    })\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/connection-manager'\n\n  /**\n   * Starts the Connection Manager. If Metrics are not enabled on libp2p\n   * only event loop and connection limits will be monitored.\n   */\n  async start (): Promise<void> {\n    // track inbound/outbound connections\n    this.metrics?.registerMetricGroup('libp2p_connection_manager_connections', {\n      calculate: () => {\n        const metric = {\n          inbound: 0,\n          'inbound pending': this.incomingPendingConnections,\n          outbound: 0,\n          'outbound pending': this.outboundPendingConnections\n        }\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            metric[conn.direction]++\n          }\n        }\n\n        return metric\n      }\n    })\n\n    // track total number of streams per protocol\n    this.metrics?.registerMetricGroup('libp2p_protocol_streams_total', {\n      label: 'protocol',\n      calculate: () => {\n        const metric: Record<string, number> = {}\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            for (const stream of conn.streams) {\n              const key = `${stream.direction} ${stream.protocol ?? 'unnegotiated'}`\n\n              metric[key] = (metric[key] ?? 0) + 1\n            }\n          }\n        }\n\n        return metric\n      }\n    })\n\n    // track 90th percentile of streams per protocol\n    this.metrics?.registerMetricGroup('libp2p_connection_manager_protocol_streams_per_connection_90th_percentile', {\n      label: 'protocol',\n      calculate: () => {\n        const allStreams: Record<string, number[]> = {}\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            const streams: Record<string, number> = {}\n\n            for (const stream of conn.streams) {\n              const key = `${stream.direction} ${stream.protocol ?? 'unnegotiated'}`\n\n              streams[key] = (streams[key] ?? 0) + 1\n            }\n\n            for (const [protocol, count] of Object.entries(streams)) {\n              allStreams[protocol] = allStreams[protocol] ?? []\n              allStreams[protocol].push(count)\n            }\n          }\n        }\n\n        const metric: Record<string, number> = {}\n\n        for (let [protocol, counts] of Object.entries(allStreams)) {\n          counts = counts.sort((a, b) => a - b)\n\n          const index = Math.floor(counts.length * 0.9)\n          metric[protocol] = counts[index]\n        }\n\n        return metric\n      }\n    })\n\n    this.events.addEventListener('connection:open', this.onConnect)\n    this.events.addEventListener('connection:close', this.onDisconnect)\n\n    await start(\n      this.dialQueue,\n      this.reconnectQueue,\n      this.connectionPruner\n    )\n\n    this.started = true\n    this.log('started')\n  }\n\n  /**\n   * Stops the Connection Manager\n   */\n  async stop (): Promise<void> {\n    this.events.removeEventListener('connection:open', this.onConnect)\n    this.events.removeEventListener('connection:close', this.onDisconnect)\n\n    await stop(\n      this.reconnectQueue,\n      this.dialQueue,\n      this.connectionPruner\n    )\n\n    // Close all connections we're tracking\n    const tasks: Array<Promise<void>> = []\n    for (const connectionList of this.connections.values()) {\n      for (const connection of connectionList) {\n        tasks.push((async () => {\n          try {\n            await connection.close()\n          } catch (err) {\n            this.log.error(err)\n          }\n        })())\n      }\n    }\n\n    this.log('closing %d connections', tasks.length)\n    await Promise.all(tasks)\n    this.connections.clear()\n\n    this.log('stopped')\n  }\n\n  getMaxConnections (): number {\n    return this.maxConnections\n  }\n\n  onConnect (evt: CustomEvent<Connection>): void {\n    void this._onConnect(evt).catch(err => {\n      this.log.error(err)\n    })\n  }\n\n  /**\n   * Tracks the incoming connection and check the connection limit\n   */\n  async _onConnect (evt: CustomEvent<Connection>): Promise<void> {\n    const { detail: connection } = evt\n\n    if (!this.started) {\n      // This can happen when we are in the process of shutting down the node\n      await connection.close()\n      return\n    }\n\n    if (connection.status !== 'open') {\n      // this can happen when the remote closes the connection immediately after\n      // opening\n      return\n    }\n\n    const peerId = connection.remotePeer\n    const isNewPeer = !this.connections.has(peerId)\n    const storedConns = this.connections.get(peerId) ?? []\n    storedConns.push(connection)\n\n    this.connections.set(peerId, storedConns)\n\n    // only need to store RSA public keys, all other types are embedded in the peer id\n    if (peerId.publicKey != null && peerId.type === 'RSA') {\n      await this.peerStore.patch(peerId, {\n        publicKey: peerId.publicKey\n      })\n    }\n\n    if (isNewPeer) {\n      this.events.safeDispatchEvent('peer:connect', { detail: connection.remotePeer })\n    }\n  }\n\n  /**\n   * Removes the connection from tracking\n   */\n  onDisconnect (evt: CustomEvent<Connection>): void {\n    const { detail: connection } = evt\n    const peerId = connection.remotePeer\n    const peerConns = this.connections.get(peerId) ?? []\n\n    // remove closed connection\n    const filteredPeerConns = peerConns.filter(conn => conn.id !== connection.id)\n\n    // update peer connections\n    this.connections.set(peerId, filteredPeerConns)\n\n    if (filteredPeerConns.length === 0) {\n      // trigger disconnect event if no connections remain\n      this.log('onDisconnect remove all connections for peer %p', peerId)\n      this.connections.delete(peerId)\n\n      // broadcast disconnect event\n      this.events.safeDispatchEvent('peer:disconnect', { detail: connection.remotePeer })\n    }\n  }\n\n  getConnections (peerId?: PeerId): Connection[] {\n    if (peerId != null) {\n      return this.connections.get(peerId) ?? []\n    }\n\n    let conns: Connection[] = []\n\n    for (const c of this.connections.values()) {\n      conns = conns.concat(c)\n    }\n\n    return conns\n  }\n\n  getConnectionsMap (): PeerMap<Connection[]> {\n    return this.connections\n  }\n\n  async openConnection (peerIdOrMultiaddr: PeerId | Multiaddr | Multiaddr[], options: OpenConnectionOptions = {}): Promise<Connection> {\n    if (!this.started) {\n      throw new NotStartedError('Not started')\n    }\n\n    this.outboundPendingConnections++\n\n    try {\n      options.signal?.throwIfAborted()\n\n      const { peerId } = getPeerAddress(peerIdOrMultiaddr)\n\n      if (this.peerId.equals(peerId)) {\n        throw new InvalidPeerIdError('Can not dial self')\n      }\n\n      if (peerId != null && options.force !== true) {\n        this.log('dial %p', peerId)\n        const existingConnection = this.getConnections(peerId)\n          .find(conn => conn.limits == null)\n\n        if (existingConnection != null) {\n          this.log('had an existing non-limited connection to %p', peerId)\n\n          options.onProgress?.(new CustomProgressEvent('dial-queue:already-connected'))\n          return existingConnection\n        }\n      }\n\n      const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {\n        ...options,\n        priority: options.priority ?? DEFAULT_DIAL_PRIORITY\n      })\n\n      if (connection.status !== 'open') {\n        throw new ConnectionClosedError('Remote closed connection during opening')\n      }\n\n      let peerConnections = this.connections.get(connection.remotePeer)\n\n      if (peerConnections == null) {\n        peerConnections = []\n        this.connections.set(connection.remotePeer, peerConnections)\n      }\n\n      // we get notified of connections via the Upgrader emitting \"connection\"\n      // events, double check we aren't already tracking this connection before\n      // storing it\n      let trackedConnection = false\n\n      for (const conn of peerConnections) {\n        if (conn.id === connection.id) {\n          trackedConnection = true\n        }\n\n        // make sure we don't already have a connection to this multiaddr\n        if (options.force !== true && conn.id !== connection.id && conn.remoteAddr.equals(connection.remoteAddr)) {\n          connection.abort(new InvalidMultiaddrError('Duplicate multiaddr connection'))\n\n          // return the existing connection\n          return conn\n        }\n      }\n\n      if (!trackedConnection) {\n        peerConnections.push(connection)\n      }\n\n      return connection\n    } finally {\n      this.outboundPendingConnections--\n    }\n  }\n\n  async closeConnections (peerId: PeerId, options: AbortOptions = {}): Promise<void> {\n    const connections = this.connections.get(peerId) ?? []\n\n    await Promise.all(\n      connections.map(async connection => {\n        try {\n          await connection.close(options)\n        } catch (err: any) {\n          connection.abort(err)\n        }\n      })\n    )\n  }\n\n  async acceptIncomingConnection (maConn: MultiaddrConnection): Promise<boolean> {\n    // check deny list\n    const denyConnection = this.deny.some(ma => {\n      return ma.contains(maConn.remoteAddr.nodeAddress().address)\n    })\n\n    if (denyConnection) {\n      this.log('connection from %a refused - connection remote address was in deny list', maConn.remoteAddr)\n      return false\n    }\n\n    // check allow list\n    const allowConnection = this.allow.some(ipNet => {\n      return ipNet.contains(maConn.remoteAddr.nodeAddress().address)\n    })\n\n    if (allowConnection) {\n      this.incomingPendingConnections++\n\n      return true\n    }\n\n    // check pending connections\n    if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {\n      this.log('connection from %a refused - incomingPendingConnections exceeded by host', maConn.remoteAddr)\n      return false\n    }\n\n    if (maConn.remoteAddr.isThinWaistAddress()) {\n      const host = maConn.remoteAddr.nodeAddress().address\n\n      try {\n        await this.inboundConnectionRateLimiter.consume(host, 1)\n      } catch {\n        this.log('connection from %a refused - inboundConnectionThreshold exceeded by host %s', maConn.remoteAddr, host)\n        return false\n      }\n    }\n\n    if (this.getConnections().length < this.maxConnections) {\n      this.incomingPendingConnections++\n\n      return true\n    }\n\n    this.log('connection from %a refused - maxConnections exceeded', maConn.remoteAddr)\n    return false\n  }\n\n  afterUpgradeInbound (): void {\n    this.incomingPendingConnections--\n  }\n\n  getDialQueue (): PendingDial[] {\n    const statusMap: Record<JobStatus, PendingDialStatus> = {\n      queued: 'queued',\n      running: 'active',\n      errored: 'error',\n      complete: 'success'\n    }\n\n    return this.dialQueue.queue.queue.map(job => {\n      return {\n        id: job.id,\n        status: statusMap[job.status],\n        peerId: job.options.peerId,\n        multiaddrs: [...job.options.multiaddrs].map(ma => multiaddr(ma))\n      }\n    })\n  }\n\n  async isDialable (multiaddr: Multiaddr | Multiaddr[], options: IsDialableOptions = {}): Promise<boolean> {\n    return this.dialQueue.isDialable(multiaddr, options)\n  }\n}\n", "/**\n * Implements exponential moving average. Ported from `moving-average`.\n *\n * @see https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n * @see https://www.npmjs.com/package/moving-average\n */\nexport class MovingAverage {\n  public movingAverage: number\n  public variance: number\n  public deviation: number\n  public forecast: number\n  private readonly timeSpan: number\n  private previousTime?: number\n\n  constructor (timeSpan: number) {\n    this.timeSpan = timeSpan\n    this.movingAverage = 0\n    this.variance = 0\n    this.deviation = 0\n    this.forecast = 0\n  }\n\n  alpha (t: number, pt: number): number {\n    return 1 - (Math.exp(-(t - pt) / this.timeSpan))\n  }\n\n  push (value: number, time: number = Date.now()): void {\n    if (this.previousTime != null) {\n      // calculate moving average\n      const a = this.alpha(time, this.previousTime)\n      const diff = value - this.movingAverage\n      const incr = a * diff\n      this.movingAverage = a * value + (1 - a) * this.movingAverage\n      // calculate variance & deviation\n      this.variance = (1 - a) * (this.variance + diff * incr)\n      this.deviation = Math.sqrt(this.variance)\n      // calculate forecast\n      this.forecast = this.movingAverage + a * diff\n    } else {\n      this.movingAverage = value\n    }\n\n    this.previousTime = time\n  }\n}\n", "import { setMaxListeners } from '@libp2p/interface'\nimport { anySignal, type ClearableSignal } from 'any-signal'\nimport { MovingAverage } from './moving-average.js'\nimport type { MetricGroup, Metrics } from '@libp2p/interface'\n\nexport const DEFAULT_TIMEOUT_MULTIPLIER = 1.2\nexport const DEFAULT_FAILURE_MULTIPLIER = 2\nexport const DEFAULT_MIN_TIMEOUT = 2000\n\nexport interface AdaptiveTimeoutSignal extends ClearableSignal {\n  start: number\n  timeout: number\n}\n\nexport interface AdaptiveTimeoutInit {\n  metricName?: string\n  metrics?: Metrics\n  interval?: number\n  initialValue?: number\n  timeoutMultiplier?: number\n  failureMultiplier?: number\n  minTimeout?: number\n}\n\nexport interface GetTimeoutSignalOptions {\n  timeoutFactor?: number\n  signal?: AbortSignal\n}\n\nexport class AdaptiveTimeout {\n  private readonly success: MovingAverage\n  private readonly failure: MovingAverage\n  private readonly next: MovingAverage\n  private readonly metric?: MetricGroup\n  private readonly timeoutMultiplier: number\n  private readonly failureMultiplier: number\n  private readonly minTimeout: number\n\n  constructor (init: AdaptiveTimeoutInit = {}) {\n    this.success = new MovingAverage(init.interval ?? 5000)\n    this.failure = new MovingAverage(init.interval ?? 5000)\n    this.next = new MovingAverage(init.interval ?? 5000)\n    this.failureMultiplier = init.failureMultiplier ?? DEFAULT_FAILURE_MULTIPLIER\n    this.timeoutMultiplier = init.timeoutMultiplier ?? DEFAULT_TIMEOUT_MULTIPLIER\n    this.minTimeout = init.minTimeout ?? DEFAULT_MIN_TIMEOUT\n\n    if (init.metricName != null) {\n      this.metric = init.metrics?.registerMetricGroup(init.metricName)\n    }\n  }\n\n  getTimeoutSignal (options: GetTimeoutSignalOptions = {}): AdaptiveTimeoutSignal {\n    // calculate timeout for individual peers based on moving average of\n    // previous successful requests\n    const timeout = Math.max(\n      Math.round(this.next.movingAverage * (options.timeoutFactor ?? this.timeoutMultiplier)),\n      this.minTimeout\n    )\n    const sendTimeout = AbortSignal.timeout(timeout)\n    const timeoutSignal = anySignal([options.signal, sendTimeout]) as AdaptiveTimeoutSignal\n    setMaxListeners(Infinity, timeoutSignal, sendTimeout)\n\n    timeoutSignal.start = Date.now()\n    timeoutSignal.timeout = timeout\n\n    return timeoutSignal\n  }\n\n  cleanUp (signal: AdaptiveTimeoutSignal): void {\n    const time = Date.now() - signal.start\n\n    if (signal.aborted) {\n      this.failure.push(time)\n      this.next.push(time * this.failureMultiplier)\n      this.metric?.update({\n        failureMovingAverage: this.failure.movingAverage,\n        failureDeviation: this.failure.deviation,\n        failureForecast: this.failure.forecast,\n        failureVariance: this.failure.variance,\n        failure: time\n      })\n    } else {\n      this.success.push(time)\n      this.next.push(time)\n      this.metric?.update({\n        successMovingAverage: this.success.movingAverage,\n        successDeviation: this.success.deviation,\n        successForecast: this.success.forecast,\n        successVariance: this.success.variance,\n        success: time\n      })\n    }\n  }\n}\n", "import { randomBytes } from '@libp2p/crypto'\nimport { serviceCapabilities, setMaxListeners } from '@libp2p/interface'\nimport { AdaptiveTimeout } from '@libp2p/utils/adaptive-timeout'\nimport { byteStream } from 'it-byte-stream'\nimport type { ComponentLogger, Logger, Metrics, Startable } from '@libp2p/interface'\nimport type { ConnectionManager } from '@libp2p/interface-internal'\nimport type { AdaptiveTimeoutInit } from '@libp2p/utils/adaptive-timeout'\n\nconst DEFAULT_PING_INTERVAL_MS = 10000\nconst PROTOCOL_VERSION = '1.0.0'\nconst PROTOCOL_NAME = 'ping'\nconst PROTOCOL_PREFIX = 'ipfs'\nconst PING_LENGTH = 32\nconst DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE = true\n\nexport interface ConnectionMonitorInit {\n  /**\n   * Whether the connection monitor is enabled\n   *\n   * @default true\n   */\n  enabled?: boolean\n\n  /**\n   * How often to ping remote peers in ms\n   *\n   * @default 10000\n   */\n  pingInterval?: number\n\n  /**\n   * Timeout settings for how long the ping is allowed to take before the\n   * connection will be judged inactive and aborted.\n   *\n   * The timeout is adaptive to cope with slower networks or nodes that\n   * have changing network characteristics, such as mobile.\n   */\n  pingTimeout?: Omit<AdaptiveTimeoutInit, 'metricsName' | 'metrics'>\n\n  /**\n   * If true, any connection that fails the ping will be aborted\n   *\n   * @default true\n   */\n  abortConnectionOnPingFailure?: boolean\n\n  /**\n   * Override the ping protocol prefix\n   *\n   * @default 'ipfs'\n   */\n  protocolPrefix?: string\n}\n\nexport interface ConnectionMonitorComponents {\n  logger: ComponentLogger\n  connectionManager: ConnectionManager\n  metrics?: Metrics\n}\n\nexport class ConnectionMonitor implements Startable {\n  private readonly protocol: string\n  private readonly components: ConnectionMonitorComponents\n  private readonly log: Logger\n  private heartbeatInterval?: ReturnType<typeof setInterval>\n  private readonly pingIntervalMs: number\n  private abortController?: AbortController\n  private readonly timeout: AdaptiveTimeout\n  private readonly abortConnectionOnPingFailure: boolean\n\n  constructor (components: ConnectionMonitorComponents, init: ConnectionMonitorInit = {}) {\n    this.components = components\n    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`\n\n    this.log = components.logger.forComponent('libp2p:connection-monitor')\n    this.pingIntervalMs = init.pingInterval ?? DEFAULT_PING_INTERVAL_MS\n    this.abortConnectionOnPingFailure = init.abortConnectionOnPingFailure ?? DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE\n    this.timeout = new AdaptiveTimeout({\n      ...(init.pingTimeout ?? {}),\n      metrics: components.metrics,\n      metricName: 'libp2p_connection_monitor_ping_time_milliseconds'\n    })\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/connection-monitor'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/connection-monitor'\n  ]\n\n  start (): void {\n    this.abortController = new AbortController()\n    setMaxListeners(Infinity, this.abortController.signal)\n\n    this.heartbeatInterval = setInterval(() => {\n      this.components.connectionManager.getConnections().forEach(conn => {\n        Promise.resolve().then(async () => {\n          let start = Date.now()\n          try {\n            const signal = this.timeout.getTimeoutSignal({\n              signal: this.abortController?.signal\n            })\n            const stream = await conn.newStream(this.protocol, {\n              signal,\n              runOnLimitedConnection: true\n            })\n            const bs = byteStream(stream)\n            start = Date.now()\n\n            await Promise.all([\n              bs.write(randomBytes(PING_LENGTH), {\n                signal\n              }),\n              bs.read(PING_LENGTH, {\n                signal\n              })\n            ])\n\n            conn.rtt = Date.now() - start\n\n            await bs.unwrap().close({\n              signal\n            })\n          } catch (err: any) {\n            if (err.name !== 'UnsupportedProtocolError') {\n              throw err\n            }\n\n            // protocol was unsupported, but that's ok as it means the remote\n            // peer was still alive. We ran multistream-select which means two\n            // round trips (e.g. 1x for the mss header, then another for the\n            // protocol) so divide the time it took by two\n            conn.rtt = (Date.now() - start) / 2\n          }\n        })\n          .catch(err => {\n            this.log.error('error during heartbeat', err)\n\n            if (this.abortConnectionOnPingFailure) {\n              this.log.error('aborting connection due to ping failure')\n              conn.abort(err)\n            } else {\n              this.log('connection ping failed, but not aborting due to abortConnectionOnPingFailure flag')\n            }\n          })\n      })\n    }, this.pingIntervalMs)\n  }\n\n  stop (): void {\n    this.abortController?.abort()\n\n    if (this.heartbeatInterval != null) {\n      clearInterval(this.heartbeatInterval)\n    }\n  }\n}\n", "import { NotStartedError } from '@libp2p/interface'\nimport { PeerSet } from '@libp2p/peer-collections'\nimport merge from 'it-merge'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { NoContentRoutersError } from './errors.js'\nimport type { AbortOptions, ComponentLogger, ContentRouting, Metrics, PeerInfo, PeerRouting, PeerStore, RoutingOptions, Startable } from '@libp2p/interface'\nimport type { CID } from 'multiformats/cid'\n\nexport interface CompoundContentRoutingInit {\n  routers: ContentRouting[]\n}\n\nexport interface CompoundContentRoutingComponents {\n  peerStore: PeerStore\n  peerRouting: PeerRouting\n  logger: ComponentLogger\n  metrics?: Metrics\n}\n\nexport class CompoundContentRouting implements ContentRouting, Startable {\n  private readonly routers: ContentRouting[]\n  private started: boolean\n  private readonly components: CompoundContentRoutingComponents\n\n  constructor (components: CompoundContentRoutingComponents, init: CompoundContentRoutingInit) {\n    this.routers = init.routers ?? []\n    this.started = false\n    this.components = components\n\n    this.findProviders = components.metrics?.traceFunction('libp2p.contentRouting.findProviders', this.findProviders.bind(this), {\n      optionsIndex: 1,\n      getAttributesFromArgs: ([cid], attrs) => {\n        return {\n          ...attrs,\n          cid: cid.toString()\n        }\n      },\n      getAttributesFromYieldedValue: (value, attrs: { providers?: string[] }) => {\n        return {\n          ...attrs,\n          providers: [...(Array.isArray(attrs.providers) ? attrs.providers : []), value.id.toString()]\n        }\n      }\n    }) ?? this.findProviders\n    this.provide = components.metrics?.traceFunction('libp2p.contentRouting.provide', this.provide.bind(this), {\n      optionsIndex: 1,\n      getAttributesFromArgs: ([cid], attrs) => {\n        return {\n          ...attrs,\n          cid: cid.toString()\n        }\n      }\n    }) ?? this.provide\n    this.cancelReprovide = components.metrics?.traceFunction('libp2p.contentRouting.cancelReprovide', this.cancelReprovide.bind(this), {\n      optionsIndex: 1,\n      getAttributesFromArgs: ([cid], attrs) => {\n        return {\n          ...attrs,\n          cid: cid.toString()\n        }\n      }\n    }) ?? this.cancelReprovide\n    this.put = components.metrics?.traceFunction('libp2p.contentRouting.put', this.put.bind(this), {\n      optionsIndex: 2,\n      getAttributesFromArgs: ([key]) => {\n        return {\n          key: uint8ArrayToString(key, 'base36')\n        }\n      }\n    }) ?? this.put\n    this.get = components.metrics?.traceFunction('libp2p.contentRouting.get', this.get.bind(this), {\n      optionsIndex: 1,\n      getAttributesFromArgs: ([key]) => {\n        return {\n          key: uint8ArrayToString(key, 'base36')\n        }\n      }\n    }) ?? this.get\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/content-routing'\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  async start (): Promise<void> {\n    this.started = true\n  }\n\n  async stop (): Promise<void> {\n    this.started = false\n  }\n\n  /**\n   * Iterates over all content routers in parallel to find providers of the given key\n   */\n  async * findProviders (key: CID, options: RoutingOptions = {}): AsyncGenerator<PeerInfo> {\n    if (this.routers.length === 0) {\n      throw new NoContentRoutersError('No content routers available')\n    }\n\n    const self = this\n    const seen = new PeerSet()\n\n    for await (const peer of merge(\n      ...self.routers.map(router => router.findProviders(key, options))\n    )) {\n      // the peer was yielded by a content router without multiaddrs and we\n      // failed to load them\n      if (peer == null) {\n        continue\n      }\n\n      // store the addresses for the peer if found\n      if (peer.multiaddrs.length > 0) {\n        await this.components.peerStore.merge(peer.id, {\n          multiaddrs: peer.multiaddrs\n        })\n      }\n\n      // deduplicate peers\n      if (seen.has(peer.id)) {\n        continue\n      }\n\n      seen.add(peer.id)\n\n      yield peer\n    }\n  }\n\n  /**\n   * Iterates over all content routers in parallel to notify it is\n   * a provider of the given key\n   */\n  async provide (key: CID, options: AbortOptions = {}): Promise<void> {\n    if (this.routers.length === 0) {\n      throw new NoContentRoutersError('No content routers available')\n    }\n\n    await Promise.all(this.routers.map(async (router) => {\n      await router.provide(key, options)\n    }))\n  }\n\n  async cancelReprovide (key: CID, options: AbortOptions = {}): Promise<void> {\n    if (this.routers.length === 0) {\n      throw new NoContentRoutersError('No content routers available')\n    }\n\n    await Promise.all(this.routers.map(async (router) => {\n      await router.cancelReprovide(key, options)\n    }))\n  }\n\n  /**\n   * Store the given key/value pair in the available content routings\n   */\n  async put (key: Uint8Array, value: Uint8Array, options?: AbortOptions): Promise<void> {\n    if (!this.isStarted()) {\n      throw new NotStartedError()\n    }\n\n    await Promise.all(this.routers.map(async (router) => {\n      await router.put(key, value, options)\n    }))\n  }\n\n  /**\n   * Get the value to the given key.\n   * Times out after 1 minute by default.\n   */\n  async get (key: Uint8Array, options?: AbortOptions): Promise<Uint8Array> {\n    if (!this.isStarted()) {\n      throw new NotStartedError()\n    }\n\n    return Promise.any(this.routers.map(async (router) => {\n      return router.get(key, options)\n    }))\n  }\n}\n", "import { NotFoundError } from '@libp2p/interface'\nimport { createScalableCuckooFilter } from '@libp2p/utils/filters'\nimport merge from 'it-merge'\nimport parallel from 'it-parallel'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { NoPeerRoutersError, QueriedForSelfError } from './errors.js'\nimport type { Logger, Metrics, PeerId, PeerInfo, PeerRouting, PeerStore, RoutingOptions } from '@libp2p/interface'\nimport type { ComponentLogger } from '@libp2p/logger'\n\nexport interface PeerRoutingInit {\n  routers?: PeerRouting[]\n}\n\nexport interface DefaultPeerRoutingComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n  logger: ComponentLogger\n  metrics?: Metrics\n}\n\nexport class DefaultPeerRouting implements PeerRouting {\n  private readonly log: Logger\n  private readonly peerId: PeerId\n  private readonly peerStore: PeerStore\n  private readonly routers: PeerRouting[]\n\n  constructor (components: DefaultPeerRoutingComponents, init: PeerRoutingInit = {}) {\n    this.log = components.logger.forComponent('libp2p:peer-routing')\n    this.peerId = components.peerId\n    this.peerStore = components.peerStore\n    this.routers = init.routers ?? []\n\n    this.findPeer = components.metrics?.traceFunction('libp2p.peerRouting.findPeer', this.findPeer.bind(this), {\n      optionsIndex: 1,\n      getAttributesFromArgs: ([peer], attrs) => {\n        return {\n          ...attrs,\n          peer: peer.toString()\n        }\n      }\n    }) ?? this.findPeer\n    this.getClosestPeers = components.metrics?.traceFunction('libp2p.peerRouting.getClosestPeers', this.getClosestPeers.bind(this), {\n      optionsIndex: 1,\n      getAttributesFromArgs: ([key], attrs) => {\n        return {\n          ...attrs,\n          key: uint8ArrayToString(key, 'base36')\n        }\n      },\n      getAttributesFromYieldedValue: (value, attrs: { peers?: string[] }) => {\n        return {\n          ...attrs,\n          peers: [...(Array.isArray(attrs.peers) ? attrs.peers : []), value.id.toString()]\n        }\n      }\n    }) ?? this.getClosestPeers\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/peer-routing'\n\n  /**\n   * Iterates over all peer routers in parallel to find the given peer\n   */\n  async findPeer (id: PeerId, options?: RoutingOptions): Promise<PeerInfo> {\n    if (this.routers.length === 0) {\n      throw new NoPeerRoutersError('No peer routers available')\n    }\n\n    if (id.toString() === this.peerId.toString()) {\n      throw new QueriedForSelfError('Should not try to find self')\n    }\n\n    const self = this\n    const source = merge(\n      ...this.routers.map(router => (async function * () {\n        try {\n          yield await router.findPeer(id, options)\n        } catch (err) {\n          self.log.error(err)\n        }\n      })())\n    )\n\n    for await (const peer of source) {\n      if (peer == null) {\n        continue\n      }\n\n      // store the addresses for the peer if found\n      if (peer.multiaddrs.length > 0) {\n        await this.peerStore.merge(peer.id, {\n          multiaddrs: peer.multiaddrs\n        })\n      }\n\n      return peer\n    }\n\n    throw new NotFoundError()\n  }\n\n  /**\n   * Attempt to find the closest peers on the network to the given key\n   */\n  async * getClosestPeers (key: Uint8Array, options: RoutingOptions = {}): AsyncGenerator<PeerInfo> {\n    if (this.routers.length === 0) {\n      throw new NoPeerRoutersError('No peer routers available')\n    }\n\n    const self = this\n    const seen = createScalableCuckooFilter(1024)\n\n    for await (const peer of parallel(\n      async function * () {\n        const source = merge(\n          ...self.routers.map(router => router.getClosestPeers(key, options))\n        )\n\n        for await (let peer of source) {\n          yield async () => {\n            // find multiaddrs if they are missing\n            if (peer.multiaddrs.length === 0) {\n              try {\n                peer = await self.findPeer(peer.id, {\n                  ...options,\n                  useCache: false\n                })\n              } catch (err) {\n                self.log.error('could not find peer multiaddrs', err)\n                return\n              }\n            }\n\n            return peer\n          }\n        }\n      }()\n    )) {\n      if (peer == null) {\n        continue\n      }\n\n      // store the addresses for the peer if found\n      if (peer.multiaddrs.length > 0) {\n        await this.peerStore.merge(peer.id, {\n          multiaddrs: peer.multiaddrs\n        })\n      }\n\n      // deduplicate peers\n      if (seen.has(peer.id.toMultihash().bytes)) {\n        continue\n      }\n\n      seen.add(peer.id.toMultihash().bytes)\n\n      yield peer\n    }\n  }\n}\n", "import { randomBytes } from '@libp2p/crypto'\nimport { TypedEventEmitter, setMaxListeners } from '@libp2p/interface'\nimport { anySignal } from 'any-signal'\nimport pDefer, { type DeferredPromise } from 'p-defer'\nimport { raceEvent } from 'race-event'\nimport { raceSignal } from 'race-signal'\nimport type { AbortOptions, ComponentLogger, Logger, PeerInfo, PeerRouting, Startable } from '@libp2p/interface'\nimport type { RandomWalk as RandomWalkInterface } from '@libp2p/interface-internal'\n\nexport interface RandomWalkComponents {\n  peerRouting: PeerRouting\n  logger: ComponentLogger\n}\n\ninterface RandomWalkEvents {\n  'walk:peer': CustomEvent<PeerInfo>\n  'walk:error': CustomEvent<Error>\n}\n\nexport class RandomWalk extends TypedEventEmitter<RandomWalkEvents> implements RandomWalkInterface, Startable {\n  private readonly peerRouting: PeerRouting\n  private readonly log: Logger\n  private walking: boolean\n  private walkers: number\n  private shutdownController: AbortController\n  private walkController?: AbortController\n  private needNext?: DeferredPromise<void>\n\n  constructor (components: RandomWalkComponents) {\n    super()\n\n    this.log = components.logger.forComponent('libp2p:random-walk')\n    this.peerRouting = components.peerRouting\n    this.walkers = 0\n    this.walking = false\n\n    // stops any in-progress walks when the node is shut down\n    this.shutdownController = new AbortController()\n    setMaxListeners(Infinity, this.shutdownController.signal)\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/random-walk'\n\n  start (): void {\n    this.shutdownController = new AbortController()\n    setMaxListeners(Infinity, this.shutdownController.signal)\n  }\n\n  stop (): void {\n    this.shutdownController.abort()\n  }\n\n  async * walk (options?: AbortOptions): AsyncGenerator<PeerInfo> {\n    if (!this.walking) {\n      // start the query that causes walk:peer events to be emitted\n      this.startWalk()\n    }\n\n    this.walkers++\n    const signal = anySignal([this.shutdownController.signal, options?.signal])\n    setMaxListeners(Infinity, signal)\n\n    try {\n      while (true) {\n        // if another consumer has paused the query, start it again\n        this.needNext?.resolve()\n        this.needNext = pDefer()\n\n        // wait for a walk:peer or walk:error event\n        const event = await raceEvent<CustomEvent<PeerInfo>>(this, 'walk:peer', signal, {\n          errorEvent: 'walk:error'\n        })\n\n        yield event.detail\n      }\n    } finally {\n      signal.clear()\n      this.walkers--\n\n      // stop the walk if no more consumers are interested\n      if (this.walkers === 0) {\n        this.walkController?.abort()\n        this.walkController = undefined\n      }\n    }\n  }\n\n  private startWalk (): void {\n    this.walking = true\n\n    // the signal for this controller will be aborted if no more random peers\n    // are required\n    this.walkController = new AbortController()\n    setMaxListeners(Infinity, this.walkController.signal)\n\n    const signal = anySignal([this.walkController.signal, this.shutdownController.signal])\n    setMaxListeners(Infinity, signal)\n\n    const start = Date.now()\n    let found = 0\n\n    Promise.resolve().then(async () => {\n      this.log('start walk')\n\n      // find peers until no more consumers are interested\n      while (this.walkers > 0) {\n        try {\n          const data = randomBytes(32)\n          let s = Date.now()\n\n          for await (const peer of this.peerRouting.getClosestPeers(data, { signal })) {\n            if (signal.aborted) {\n              this.log('aborting walk')\n            }\n\n            signal.throwIfAborted()\n\n            this.log('found peer %p after %dms for %d walkers', peer.id, Date.now() - s, this.walkers)\n            found++\n            this.safeDispatchEvent('walk:peer', {\n              detail: peer\n            })\n\n            // if we only have one consumer, pause the query until they request\n            // another random peer or they signal they are no longer interested\n            if (this.walkers === 1 && this.needNext != null) {\n              this.log('wait for need next')\n              await raceSignal(this.needNext.promise, signal)\n            }\n\n            s = Date.now()\n          }\n\n          this.log('walk iteration for %b and %d walkers finished, found %d peers', data, this.walkers, found)\n        } catch (err) {\n          this.log.error('random walk errored', err)\n\n          this.safeDispatchEvent('walk:error', {\n            detail: err\n          })\n        }\n      }\n\n      this.log('no walkers left, ended walk')\n    })\n      .catch(err => {\n        this.log.error('random walk errored', err)\n      })\n      .finally(() => {\n        this.log('finished walk, found %d peers after %dms', found, Date.now() - start)\n        this.walking = false\n      })\n  }\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport merge from 'merge-options'\nimport * as errorsJs from './errors.js'\nimport type { IdentifyResult, Libp2pEvents, Logger, PeerUpdate, TypedEventTarget, PeerId, PeerStore, Topology, StreamHandler, StreamHandlerRecord, StreamHandlerOptions } from '@libp2p/interface'\nimport type { Registrar as RegistrarInterface } from '@libp2p/interface-internal'\nimport type { ComponentLogger } from '@libp2p/logger'\n\nexport const DEFAULT_MAX_INBOUND_STREAMS = 32\nexport const DEFAULT_MAX_OUTBOUND_STREAMS = 64\n\nexport interface RegistrarComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\n/**\n * Responsible for notifying registered protocols of events in the network.\n */\nexport class Registrar implements RegistrarInterface {\n  private readonly log: Logger\n  private readonly topologies: Map<string, Map<string, Topology>>\n  private readonly handlers: Map<string, StreamHandlerRecord>\n  private readonly components: RegistrarComponents\n\n  constructor (components: RegistrarComponents) {\n    this.log = components.logger.forComponent('libp2p:registrar')\n    this.topologies = new Map()\n    this.handlers = new Map()\n    this.components = components\n\n    this._onDisconnect = this._onDisconnect.bind(this)\n    this._onPeerUpdate = this._onPeerUpdate.bind(this)\n    this._onPeerIdentify = this._onPeerIdentify.bind(this)\n\n    this.components.events.addEventListener('peer:disconnect', this._onDisconnect)\n    this.components.events.addEventListener('peer:update', this._onPeerUpdate)\n    this.components.events.addEventListener('peer:identify', this._onPeerIdentify)\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/registrar'\n\n  getProtocols (): string[] {\n    return Array.from(new Set<string>([\n      ...this.handlers.keys()\n    ])).sort()\n  }\n\n  getHandler (protocol: string): StreamHandlerRecord {\n    const handler = this.handlers.get(protocol)\n\n    if (handler == null) {\n      throw new errorsJs.UnhandledProtocolError(`No handler registered for protocol ${protocol}`)\n    }\n\n    return handler\n  }\n\n  getTopologies (protocol: string): Topology[] {\n    const topologies = this.topologies.get(protocol)\n\n    if (topologies == null) {\n      return []\n    }\n\n    return [\n      ...topologies.values()\n    ]\n  }\n\n  /**\n   * Registers the `handler` for each protocol\n   */\n  async handle (protocol: string, handler: StreamHandler, opts?: StreamHandlerOptions): Promise<void> {\n    if (this.handlers.has(protocol) && opts?.force !== true) {\n      throw new errorsJs.DuplicateProtocolHandlerError(`Handler already registered for protocol ${protocol}`)\n    }\n\n    const options = merge.bind({ ignoreUndefined: true })({\n      maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,\n      maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS\n    }, opts)\n\n    this.handlers.set(protocol, {\n      handler,\n      options\n    })\n\n    // Add new protocol to self protocols in the peer store\n    await this.components.peerStore.merge(this.components.peerId, {\n      protocols: [protocol]\n    })\n  }\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   */\n  async unhandle (protocols: string | string[]): Promise<void> {\n    const protocolList = Array.isArray(protocols) ? protocols : [protocols]\n\n    protocolList.forEach(protocol => {\n      this.handlers.delete(protocol)\n    })\n\n    // Update self protocols in the peer store\n    await this.components.peerStore.patch(this.components.peerId, {\n      protocols: this.getProtocols()\n    })\n  }\n\n  /**\n   * Register handlers for a set of multicodecs given\n   */\n  async register (protocol: string, topology: Topology): Promise<string> {\n    if (topology == null) {\n      throw new InvalidParametersError('invalid topology')\n    }\n\n    // Create topology\n    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`\n\n    let topologies = this.topologies.get(protocol)\n\n    if (topologies == null) {\n      topologies = new Map<string, Topology>()\n      this.topologies.set(protocol, topologies)\n    }\n\n    topologies.set(id, topology)\n\n    return id\n  }\n\n  /**\n   * Unregister topology\n   */\n  unregister (id: string): void {\n    for (const [protocol, topologies] of this.topologies.entries()) {\n      if (topologies.has(id)) {\n        topologies.delete(id)\n\n        if (topologies.size === 0) {\n          this.topologies.delete(protocol)\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove a disconnected peer from the record\n   */\n  _onDisconnect (evt: CustomEvent<PeerId>): void {\n    const remotePeer = evt.detail\n\n    void this.components.peerStore.get(remotePeer)\n      .then(peer => {\n        for (const protocol of peer.protocols) {\n          const topologies = this.topologies.get(protocol)\n\n          if (topologies == null) {\n            // no topologies are interested in this protocol\n            continue\n          }\n\n          for (const topology of topologies.values()) {\n            if (topology.filter?.has(remotePeer) === false) {\n              continue\n            }\n\n            topology.filter?.remove(remotePeer)\n            topology.onDisconnect?.(remotePeer)\n          }\n        }\n      })\n      .catch(err => {\n        if (err.name === 'NotFoundError') {\n          // peer has not completed identify so they are not in the peer store\n          return\n        }\n\n        this.log.error('could not inform topologies of disconnecting peer %p', remotePeer, err)\n      })\n  }\n\n  /**\n   * When a peer is updated, if they have removed supported protocols notify any\n   * topologies interested in the removed protocols.\n   */\n  _onPeerUpdate (evt: CustomEvent<PeerUpdate>): void {\n    const { peer, previous } = evt.detail\n    const removed = (previous?.protocols ?? []).filter(protocol => !peer.protocols.includes(protocol))\n\n    for (const protocol of removed) {\n      const topologies = this.topologies.get(protocol)\n\n      if (topologies == null) {\n        // no topologies are interested in this protocol\n        continue\n      }\n\n      for (const topology of topologies.values()) {\n        if (topology.filter?.has(peer.id) === false) {\n          continue\n        }\n\n        topology.filter?.remove(peer.id)\n        topology.onDisconnect?.(peer.id)\n      }\n    }\n  }\n\n  /**\n   * After identify has completed and we have received the list of supported\n   * protocols, notify any topologies interested in those protocols.\n   */\n  _onPeerIdentify (evt: CustomEvent<IdentifyResult>): void {\n    const protocols = evt.detail.protocols\n    const connection = evt.detail.connection\n    const peerId = evt.detail.peerId\n\n    for (const protocol of protocols) {\n      const topologies = this.topologies.get(protocol)\n\n      if (topologies == null) {\n        // no topologies are interested in this protocol\n        continue\n      }\n\n      for (const topology of topologies.values()) {\n        if (connection.limits != null && topology.notifyOnLimitedConnection !== true) {\n          continue\n        }\n\n        if (topology.filter?.has(peerId) === true) {\n          continue\n        }\n\n        topology.filter?.add(peerId)\n        topology.onConnect?.(peerId, connection)\n      }\n    }\n  }\n}\n", "import type { Metric, Metrics } from '@libp2p/interface'\n\nexport interface TrackedMapInit {\n  name: string\n  metrics: Metrics\n}\n\nclass TrackedMap<K, V> extends Map<K, V> {\n  private readonly metric: Metric\n\n  constructor (init: TrackedMapInit) {\n    super()\n\n    const { name, metrics } = init\n\n    this.metric = metrics.registerMetric(name)\n    this.updateComponentMetric()\n  }\n\n  set (key: K, value: V): this {\n    super.set(key, value)\n    this.updateComponentMetric()\n    return this\n  }\n\n  delete (key: K): boolean {\n    const deleted = super.delete(key)\n    this.updateComponentMetric()\n    return deleted\n  }\n\n  clear (): void {\n    super.clear()\n    this.updateComponentMetric()\n  }\n\n  private updateComponentMetric (): void {\n    this.metric.update(this.size)\n  }\n}\n\nexport interface CreateTrackedMapInit {\n  /**\n   * The metric name to use\n   */\n  name: string\n\n  /**\n   * A metrics implementation\n   */\n  metrics?: Metrics\n}\n\nexport function trackedMap <K, V> (config: CreateTrackedMapInit): Map<K, V> {\n  const { name, metrics } = config\n  let map: Map<K, V>\n\n  if (metrics != null) {\n    map = new TrackedMap<K, V>({ name, metrics })\n  } else {\n    map = new Map<K, V>()\n  }\n\n  return map\n}\n", "import { FaultTolerance, InvalidParametersError, NotStartedError } from '@libp2p/interface'\nimport { trackedMap } from '@libp2p/utils/tracked-map'\nimport { IP4, IP6 } from '@multiformats/multiaddr-matcher'\nimport { CustomProgressEvent } from 'progress-events'\nimport { TransportUnavailableError, UnsupportedListenAddressError, UnsupportedListenAddressesError } from './errors.js'\nimport type { Libp2pEvents, ComponentLogger, Logger, Connection, TypedEventTarget, Metrics, Startable, Listener, Transport, Upgrader } from '@libp2p/interface'\nimport type { AddressManager, TransportManager, TransportManagerDialOptions } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface TransportManagerInit {\n  faultTolerance?: FaultTolerance\n}\n\nexport interface DefaultTransportManagerComponents {\n  metrics?: Metrics\n  addressManager: AddressManager\n  upgrader: Upgrader\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\ninterface IPStats {\n  success: number\n  attempts: number\n}\n\ninterface ListenStats {\n  errors: Map<string, Error>\n  ipv4: IPStats\n  ipv6: IPStats\n}\n\nexport class DefaultTransportManager implements TransportManager, Startable {\n  private readonly log: Logger\n  private readonly components: DefaultTransportManagerComponents\n  private readonly transports: Map<string, Transport>\n  private readonly listeners: Map<string, Listener[]>\n  private readonly faultTolerance: FaultTolerance\n  private started: boolean\n\n  constructor (components: DefaultTransportManagerComponents, init: TransportManagerInit = {}) {\n    this.log = components.logger.forComponent('libp2p:transports')\n    this.components = components\n    this.started = false\n    this.transports = new Map<string, Transport>()\n    this.listeners = trackedMap({\n      name: 'libp2p_transport_manager_listeners',\n      metrics: this.components.metrics\n    })\n    this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/transport-manager'\n\n  /**\n   * Adds a `Transport` to the manager\n   */\n  add (transport: Transport): void {\n    const tag = transport[Symbol.toStringTag]\n\n    if (tag == null) {\n      throw new InvalidParametersError('Transport must have a valid tag')\n    }\n\n    if (this.transports.has(tag)) {\n      throw new InvalidParametersError(`There is already a transport with the tag ${tag}`)\n    }\n\n    this.log('adding transport %s', tag)\n\n    this.transports.set(tag, transport)\n\n    if (!this.listeners.has(tag)) {\n      this.listeners.set(tag, [])\n    }\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  start (): void {\n    this.started = true\n  }\n\n  async afterStart (): Promise<void> {\n    // Listen on the provided transports for the provided addresses\n    const addrs = this.components.addressManager.getListenAddrs()\n\n    await this.listen(addrs)\n  }\n\n  /**\n   * Stops all listeners\n   */\n  async stop (): Promise<void> {\n    const tasks = []\n    for (const [key, listeners] of this.listeners) {\n      this.log('closing listeners for %s', key)\n      while (listeners.length > 0) {\n        const listener = listeners.pop()\n\n        if (listener == null) {\n          continue\n        }\n\n        tasks.push(listener.close())\n      }\n    }\n\n    await Promise.all(tasks)\n    this.log('all listeners closed')\n    for (const key of this.listeners.keys()) {\n      this.listeners.set(key, [])\n    }\n\n    this.started = false\n  }\n\n  /**\n   * Dials the given Multiaddr over it's supported transport\n   */\n  async dial (ma: Multiaddr, options?: TransportManagerDialOptions): Promise<Connection> {\n    const transport = this.dialTransportForMultiaddr(ma)\n\n    if (transport == null) {\n      throw new TransportUnavailableError(`No transport available for address ${String(ma)}`)\n    }\n\n    options?.onProgress?.(new CustomProgressEvent<string>('transport-manager:selected-transport', transport[Symbol.toStringTag]))\n\n    // @ts-expect-error the transport has a typed onProgress option but we\n    // can't predict what transport implementation we selected so all we can\n    // do is pass the onProgress handler in and hope for the best\n    return transport.dial(ma, {\n      ...options,\n      upgrader: this.components.upgrader\n    })\n  }\n\n  /**\n   * Returns all Multiaddr's the listeners are using\n   */\n  getAddrs (): Multiaddr[] {\n    let addrs: Multiaddr[] = []\n    for (const listeners of this.listeners.values()) {\n      for (const listener of listeners) {\n        addrs = [...addrs, ...listener.getAddrs()]\n      }\n    }\n    return addrs\n  }\n\n  /**\n   * Returns all the transports instances\n   */\n  getTransports (): Transport[] {\n    return Array.of(...this.transports.values())\n  }\n\n  /**\n   * Returns all the listener instances\n   */\n  getListeners (): Listener[] {\n    return Array.of(...this.listeners.values()).flat()\n  }\n\n  /**\n   * Finds a transport that matches the given Multiaddr\n   */\n  dialTransportForMultiaddr (ma: Multiaddr): Transport | undefined {\n    for (const transport of this.transports.values()) {\n      const addrs = transport.dialFilter([ma])\n\n      if (addrs.length > 0) {\n        return transport\n      }\n    }\n  }\n\n  /**\n   * Finds a transport that matches the given Multiaddr\n   */\n  listenTransportForMultiaddr (ma: Multiaddr): Transport | undefined {\n    for (const transport of this.transports.values()) {\n      const addrs = transport.listenFilter([ma])\n\n      if (addrs.length > 0) {\n        return transport\n      }\n    }\n  }\n\n  /**\n   * Starts listeners for each listen Multiaddr\n   */\n  async listen (addrs: Multiaddr[]): Promise<void> {\n    if (!this.isStarted()) {\n      throw new NotStartedError('Not started')\n    }\n\n    if (addrs == null || addrs.length === 0) {\n      this.log('no addresses were provided for listening, this node is dial only')\n      return\n    }\n\n    // track IPv4/IPv6 results - if we succeed on IPv4 but all IPv6 attempts\n    // fail then we are probably on a network without IPv6 support\n    const listenStats: ListenStats = {\n      errors: new Map(),\n      ipv4: {\n        success: 0,\n        attempts: 0\n      },\n      ipv6: {\n        success: 0,\n        attempts: 0\n      }\n    }\n\n    addrs.forEach(ma => {\n      listenStats.errors.set(ma.toString(), new UnsupportedListenAddressError())\n    })\n\n    const tasks: Array<Promise<void>> = []\n\n    for (const [key, transport] of this.transports.entries()) {\n      const supportedAddrs = transport.listenFilter(addrs)\n\n      // For each supported multiaddr, create a listener\n      for (const addr of supportedAddrs) {\n        this.log('creating listener for %s on %a', key, addr)\n        const listener = transport.createListener({\n          upgrader: this.components.upgrader\n        })\n\n        let listeners: Listener[] = this.listeners.get(key) ?? []\n\n        if (listeners == null) {\n          listeners = []\n          this.listeners.set(key, listeners)\n        }\n\n        listeners.push(listener)\n\n        // Track listen/close events\n        listener.addEventListener('listening', () => {\n          this.components.events.safeDispatchEvent('transport:listening', {\n            detail: listener\n          })\n        })\n        listener.addEventListener('close', () => {\n          const index = listeners.findIndex(l => l === listener)\n\n          // remove the listener\n          listeners.splice(index, 1)\n\n          this.components.events.safeDispatchEvent('transport:close', {\n            detail: listener\n          })\n        })\n\n        // track IPv4/IPv6 support\n        if (IP4.matches(addr)) {\n          listenStats.ipv4.attempts++\n        } else if (IP6.matches(addr)) {\n          listenStats.ipv6.attempts++\n        }\n\n        // We need to attempt to listen on everything\n        tasks.push(\n          listener.listen(addr)\n            .then(() => {\n              listenStats.errors.delete(addr.toString())\n\n              if (IP4.matches(addr)) {\n                listenStats.ipv4.success++\n              }\n\n              if (IP6.matches(addr)) {\n                listenStats.ipv6.success++\n              }\n            }, (err) => {\n              this.log.error('transport %s could not listen on address %a - %e', key, addr, err)\n              listenStats.errors.set(addr.toString(), err)\n              throw err\n            })\n        )\n      }\n    }\n\n    const results = await Promise.allSettled(tasks)\n\n    // listening on all addresses, all good\n    if (results.length > 0 && results.every(res => res.status === 'fulfilled')) {\n      return\n    }\n\n    // detect lack of IPv6 support on the current network - if we tried to\n    // listen on IPv4 and IPv6 addresses, and all IPv4 addresses succeeded but\n    // all IPv6 addresses fail, then we can assume there's no IPv6 here\n    if (this.ipv6Unsupported(listenStats)) {\n      this.log('all IPv4 addresses succeed but all IPv6 failed')\n      return\n    }\n\n    if (this.faultTolerance === FaultTolerance.NO_FATAL) {\n      // ok to be dial-only\n      this.log('failed to listen on any address but fault tolerance allows this')\n      return\n    }\n\n    // if a configured address was not able to be listened on, throw an error\n    throw new UnsupportedListenAddressesError(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \\`transportManager.faultTolerance\\` to NO_FATAL:\\n${\n      [...listenStats.errors.entries()].map(([addr, err]) => {\n        return `\n  ${addr}: ${`${err.stack ?? err}`.split('\\n').join('\\n  ')}\n`\n      }).join('')\n    }`)\n  }\n\n  private ipv6Unsupported (listenStats: ListenStats): boolean {\n    if (listenStats.ipv4.attempts === 0 || listenStats.ipv6.attempts === 0) {\n      return false\n    }\n\n    const allIpv4Succeeded = listenStats.ipv4.attempts === listenStats.ipv4.success\n    const allIpv6Failed = listenStats.ipv6.success === 0\n\n    return allIpv4Succeeded && allIpv6Failed\n  }\n\n  /**\n   * Removes the given transport from the manager.\n   * If a transport has any running listeners, they will be closed.\n   */\n  async remove (key: string): Promise<void> {\n    const listeners = this.listeners.get(key) ?? []\n    this.log.trace('removing transport %s', key)\n\n    // Close any running listeners\n    const tasks = []\n    this.log.trace('closing listeners for %s', key)\n    while (listeners.length > 0) {\n      const listener = listeners.pop()\n\n      if (listener == null) {\n        continue\n      }\n\n      tasks.push(listener.close())\n    }\n    await Promise.all(tasks)\n\n    this.transports.delete(key)\n    this.listeners.delete(key)\n  }\n\n  /**\n   * Removes all transports from the manager.\n   * If any listeners are running, they will be closed.\n   *\n   * @async\n   */\n  async removeAll (): Promise<void> {\n    const tasks = []\n    for (const key of this.transports.keys()) {\n      tasks.push(this.remove(key))\n    }\n\n    await Promise.all(tasks)\n  }\n}\n", "export const PROTOCOL_ID = '/multistream/1.0.0'\n\n// Conforming to go-libp2p\n// See https://github.com/multiformats/go-multistream/blob/master/multistream.go#L297\nexport const MAX_PROTOCOL_LENGTH = 1024\n", "import { InvalidMessageError } from '@libp2p/interface'\nimport { type Uint8ArrayList } from 'uint8arraylist'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport type { AbortOptions, LoggerOptions } from '@libp2p/interface'\nimport type { LengthPrefixedStream } from 'it-length-prefixed-stream'\nimport type { Duplex, Source } from 'it-stream-types'\n\nconst NewLine = uint8ArrayFromString('\\n')\n\n/**\n * `write` encodes and writes a single buffer\n */\nexport async function write (writer: LengthPrefixedStream<Duplex<AsyncGenerator<Uint8Array | Uint8ArrayList>, Source<Uint8Array>>>, buffer: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<void> {\n  await writer.write(buffer, options)\n}\n\n/**\n * `writeAll` behaves like `write`, except it encodes an array of items as a single write\n */\nexport async function writeAll (writer: LengthPrefixedStream<Duplex<AsyncGenerator<Uint8Array | Uint8ArrayList>, Source<Uint8Array>>>, buffers: Uint8Array[], options?: AbortOptions): Promise<void> {\n  await writer.writeV(buffers, options)\n}\n\n/**\n * Read a length-prefixed buffer from the passed stream, stripping the final newline character\n */\nexport async function read (reader: LengthPrefixedStream<Duplex<AsyncGenerator<Uint8Array | Uint8ArrayList>, Source<Uint8Array>>>, options: AbortOptions & LoggerOptions): Promise<Uint8ArrayList> {\n  const buf = await reader.read(options)\n\n  if (buf.byteLength === 0 || buf.get(buf.byteLength - 1) !== NewLine[0]) {\n    options.log.error('Invalid mss message - missing newline', buf)\n    throw new InvalidMessageError('Missing newline')\n  }\n\n  return buf.sublist(0, -1) // Remove newline\n}\n\n/**\n * Read a length-prefixed string from the passed stream, stripping the final newline character\n */\nexport async function readString (reader: LengthPrefixedStream<Duplex<AsyncGenerator<Uint8Array | Uint8ArrayList>, Source<Uint8Array>>>, options: AbortOptions & LoggerOptions): Promise<string> {\n  const buf = await read(reader, options)\n\n  return uint8ArrayToString(buf.subarray())\n}\n", "import { UnsupportedProtocolError } from '@libp2p/interface'\nimport { lpStream } from 'it-length-prefixed-stream'\nimport pDefer from 'p-defer'\nimport { raceSignal } from 'race-signal'\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { MAX_PROTOCOL_LENGTH } from './constants.js'\nimport * as multistream from './multistream.js'\nimport { PROTOCOL_ID } from './index.js'\nimport type { MultistreamSelectInit, ProtocolStream } from './index.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Duplex } from 'it-stream-types'\n\nexport interface SelectStream extends Duplex<any, any, any> {\n  readStatus?: string\n  closeWrite?(options?: AbortOptions): Promise<void>\n  closeRead?(options?: AbortOptions): Promise<void>\n  close?(options?: AbortOptions): Promise<void>\n}\n\n/**\n * Negotiate a protocol to use from a list of protocols.\n *\n * @param stream - A duplex iterable stream to dial on\n * @param protocols - A list of protocols (or single protocol) to negotiate with. Protocols are attempted in order until a match is made.\n * @param options - An options object containing an AbortSignal and an optional boolean `writeBytes` - if this is true, `Uint8Array`s will be written into `duplex`, otherwise `Uint8ArrayList`s will\n * @returns A stream for the selected protocol and the protocol that was selected from the list of protocols provided to `select`.\n * @example\n *\n * ```TypeScript\n * import { pipe } from 'it-pipe'\n * import * as mss from '@libp2p/multistream-select'\n * import { Mplex } from '@libp2p/mplex'\n *\n * const muxer = new Mplex()\n * const muxedStream = muxer.newStream()\n *\n * // mss.select(protocol(s))\n * // Select from one of the passed protocols (in priority order)\n * // Returns selected stream and protocol\n * const { stream: dhtStream, protocol } = await mss.select(muxedStream, [\n *   // This might just be different versions of DHT, but could be different implementations\n *   '/ipfs-dht/2.0.0', // Most of the time this will probably just be one item.\n *   '/ipfs-dht/1.0.0'\n * ])\n *\n * // Typically this stream will be passed back to the caller of libp2p.dialProtocol\n * //\n * // ...it might then do something like this:\n * // try {\n * //   await pipe(\n * //     [uint8ArrayFromString('Some DHT data')]\n * //     dhtStream,\n * //     async source => {\n * //       for await (const chunk of source)\n * //         // DHT response data\n * //     }\n * //   )\n * // } catch (err) {\n * //   // Error in stream\n * // }\n * ```\n */\nexport async function select <Stream extends SelectStream> (stream: Stream, protocols: string | string[], options: MultistreamSelectInit): Promise<ProtocolStream<Stream>> {\n  protocols = Array.isArray(protocols) ? [...protocols] : [protocols]\n\n  if (protocols.length === 1 && options.negotiateFully === false) {\n    return optimisticSelect(stream, protocols[0], options)\n  }\n\n  const lp = lpStream(stream, {\n    ...options,\n    maxDataLength: MAX_PROTOCOL_LENGTH\n  })\n  const protocol = protocols.shift()\n\n  if (protocol == null) {\n    throw new Error('At least one protocol must be specified')\n  }\n\n  options.log.trace('select: write [\"%s\", \"%s\"]', PROTOCOL_ID, protocol)\n  const p1 = uint8ArrayFromString(`${PROTOCOL_ID}\\n`)\n  const p2 = uint8ArrayFromString(`${protocol}\\n`)\n  await multistream.writeAll(lp, [p1, p2], options)\n\n  options.log.trace('select: reading multistream-select header')\n  let response = await multistream.readString(lp, options)\n  options.log.trace('select: read \"%s\"', response)\n\n  // Read the protocol response if we got the protocolId in return\n  if (response === PROTOCOL_ID) {\n    options.log.trace('select: reading protocol response')\n    response = await multistream.readString(lp, options)\n    options.log.trace('select: read \"%s\"', response)\n  }\n\n  // We're done\n  if (response === protocol) {\n    return { stream: lp.unwrap(), protocol }\n  }\n\n  // We haven't gotten a valid ack, try the other protocols\n  for (const protocol of protocols) {\n    options.log.trace('select: write \"%s\"', protocol)\n    await multistream.write(lp, uint8ArrayFromString(`${protocol}\\n`), options)\n    options.log.trace('select: reading protocol response')\n    const response = await multistream.readString(lp, options)\n    options.log.trace('select: read \"%s\" for \"%s\"', response, protocol)\n\n    if (response === protocol) {\n      return { stream: lp.unwrap(), protocol }\n    }\n  }\n\n  throw new UnsupportedProtocolError('protocol selection failed')\n}\n\n/**\n * Optimistically negotiates a protocol.\n *\n * It *does not* block writes waiting for the other end to respond. Instead, it\n * simply assumes the negotiation went successfully and starts writing data.\n *\n * Use when it is known that the receiver supports the desired protocol.\n */\nfunction optimisticSelect <Stream extends SelectStream> (stream: Stream, protocol: string, options: MultistreamSelectInit): ProtocolStream<Stream> {\n  const originalSink = stream.sink.bind(stream)\n  const originalSource = stream.source\n\n  let negotiated = false\n  let negotiating = false\n  const doneNegotiating = pDefer()\n\n  let sentProtocol = false\n  let sendingProtocol = false\n  const doneSendingProtocol = pDefer()\n\n  let readProtocol = false\n  let readingProtocol = false\n  const doneReadingProtocol = pDefer()\n\n  const lp = lpStream({\n    sink: originalSink,\n    source: originalSource\n  }, {\n    ...options,\n    maxDataLength: MAX_PROTOCOL_LENGTH\n  })\n\n  stream.sink = async source => {\n    const { sink } = lp.unwrap()\n\n    await sink(async function * () {\n      let sentData = false\n\n      for await (const buf of source) {\n        // started reading before the source yielded, wait for protocol send\n        if (sendingProtocol) {\n          await doneSendingProtocol.promise\n        }\n\n        // writing before reading, send the protocol and the first chunk of data\n        if (!sentProtocol) {\n          sendingProtocol = true\n\n          options.log.trace('optimistic: write [\"%s\", \"%s\", data(%d)] in sink', PROTOCOL_ID, protocol, buf.byteLength)\n\n          const protocolString = `${protocol}\\n`\n\n          // send protocols in first chunk of data written to transport\n          yield new Uint8ArrayList(\n            Uint8Array.from([19]), // length of PROTOCOL_ID plus newline\n            uint8ArrayFromString(`${PROTOCOL_ID}\\n`),\n            varint.encode(protocolString.length),\n            uint8ArrayFromString(protocolString),\n            buf\n          ).subarray()\n\n          options.log.trace('optimistic: wrote [\"%s\", \"%s\", data(%d)] in sink', PROTOCOL_ID, protocol, buf.byteLength)\n\n          sentProtocol = true\n          sendingProtocol = false\n          doneSendingProtocol.resolve()\n\n          // read the negotiation response but don't block more sending\n          negotiate()\n            .catch(err => {\n              options.log.error('could not finish optimistic protocol negotiation of %s', protocol, err)\n            })\n        } else {\n          yield buf\n        }\n\n        sentData = true\n      }\n\n      // special case - the source passed to the sink has ended but we didn't\n      // negotiated the protocol yet so do it now\n      if (!sentData) {\n        await negotiate()\n      }\n    }())\n  }\n\n  async function negotiate (): Promise<void> {\n    if (negotiating) {\n      options.log.trace('optimistic: already negotiating %s stream', protocol)\n      await doneNegotiating.promise\n      return\n    }\n\n    negotiating = true\n\n    try {\n      // we haven't sent the protocol yet, send it now\n      if (!sentProtocol) {\n        options.log.trace('optimistic: doing send protocol for %s stream', protocol)\n        await doSendProtocol()\n      }\n\n      // if we haven't read the protocol response yet, do it now\n      if (!readProtocol) {\n        options.log.trace('optimistic: doing read protocol for %s stream', protocol)\n        await doReadProtocol()\n      }\n    } finally {\n      negotiating = false\n      negotiated = true\n      doneNegotiating.resolve()\n    }\n  }\n\n  async function doSendProtocol (): Promise<void> {\n    if (sendingProtocol) {\n      await doneSendingProtocol.promise\n      return\n    }\n\n    sendingProtocol = true\n\n    try {\n      options.log.trace('optimistic: write [\"%s\", \"%s\", data] in source', PROTOCOL_ID, protocol)\n      await lp.writeV([\n        uint8ArrayFromString(`${PROTOCOL_ID}\\n`),\n        uint8ArrayFromString(`${protocol}\\n`)\n      ])\n      options.log.trace('optimistic: wrote [\"%s\", \"%s\", data] in source', PROTOCOL_ID, protocol)\n    } finally {\n      sentProtocol = true\n      sendingProtocol = false\n      doneSendingProtocol.resolve()\n    }\n  }\n\n  async function doReadProtocol (): Promise<void> {\n    if (readingProtocol) {\n      await doneReadingProtocol.promise\n      return\n    }\n\n    readingProtocol = true\n\n    try {\n      options.log.trace('optimistic: reading multistream select header')\n      let response = await multistream.readString(lp, options)\n      options.log.trace('optimistic: read multistream select header \"%s\"', response)\n\n      if (response === PROTOCOL_ID) {\n        response = await multistream.readString(lp, options)\n      }\n\n      options.log.trace('optimistic: read protocol \"%s\", expecting \"%s\"', response, protocol)\n\n      if (response !== protocol) {\n        throw new UnsupportedProtocolError('protocol selection failed')\n      }\n    } finally {\n      readProtocol = true\n      readingProtocol = false\n      doneReadingProtocol.resolve()\n    }\n  }\n\n  stream.source = (async function * () {\n    // make sure we've done protocol negotiation before we read stream data\n    await negotiate()\n\n    options.log.trace('optimistic: reading data from \"%s\" stream', protocol)\n    yield * lp.unwrap().source\n  })()\n\n  if (stream.closeRead != null) {\n    const originalCloseRead = stream.closeRead.bind(stream)\n\n    stream.closeRead = async (opts) => {\n      // we need to read & write to negotiate the protocol so ensure we've done\n      // this before closing the readable end of the stream\n      if (!negotiated) {\n        await negotiate().catch(err => {\n          options.log.error('could not negotiate protocol before close read', err)\n        })\n      }\n\n      // protocol has been negotiated, ok to close the readable end\n      await originalCloseRead(opts)\n    }\n  }\n\n  if (stream.closeWrite != null) {\n    const originalCloseWrite = stream.closeWrite.bind(stream)\n\n    stream.closeWrite = async (opts) => {\n      // we need to read & write to negotiate the protocol so ensure we've done\n      // this before closing the writable end of the stream\n      if (!negotiated) {\n        await negotiate().catch(err => {\n          options.log.error('could not negotiate protocol before close write', err)\n        })\n      }\n\n      // protocol has been negotiated, ok to close the writable end\n      await originalCloseWrite(opts)\n    }\n  }\n\n  if (stream.close != null) {\n    const originalClose = stream.close.bind(stream)\n\n    stream.close = async (opts) => {\n      // if we are in the process of negotiation, let it finish before closing\n      // because we may have unsent early data\n      const tasks = []\n\n      if (sendingProtocol) {\n        tasks.push(doneSendingProtocol.promise)\n      }\n\n      if (readingProtocol) {\n        tasks.push(doneReadingProtocol.promise)\n      }\n\n      if (tasks.length > 0) {\n        // let the in-flight protocol negotiation finish gracefully\n        await raceSignal(\n          Promise.all(tasks),\n          opts?.signal\n        )\n      } else {\n        // no protocol negotiation attempt has occurred so don't start one\n        negotiated = true\n        negotiating = false\n        doneNegotiating.resolve()\n      }\n\n      // protocol has been negotiated, ok to close the writable end\n      await originalClose(opts)\n    }\n  }\n\n  return {\n    stream,\n    protocol\n  }\n}\n", "import { encode } from 'it-length-prefixed'\nimport { lpStream } from 'it-length-prefixed-stream'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { MAX_PROTOCOL_LENGTH, PROTOCOL_ID } from './constants.js'\nimport * as multistream from './multistream.js'\nimport type { MultistreamSelectInit, ProtocolStream } from './index.js'\nimport type { Duplex } from 'it-stream-types'\n\n/**\n * Handle multistream protocol selections for the given list of protocols.\n *\n * Note that after a protocol is handled `listener` can no longer be used.\n *\n * @param stream - A duplex iterable stream to listen on\n * @param protocols - A list of protocols (or single protocol) that this listener is able to speak.\n * @param options - an options object containing an AbortSignal and an optional boolean `writeBytes` - if this is true, `Uint8Array`s will be written into `duplex`, otherwise `Uint8ArrayList`s will\n * @returns A stream for the selected protocol and the protocol that was selected from the list of protocols provided to `select`\n * @example\n *\n * ```TypeScript\n * import { pipe } from 'it-pipe'\n * import * as mss from '@libp2p/multistream-select'\n * import { Mplex } from '@libp2p/mplex'\n *\n * const muxer = new Mplex({\n *   async onStream (muxedStream) {\n *   // mss.handle(handledProtocols)\n *   // Returns selected stream and protocol\n *   const { stream, protocol } = await mss.handle(muxedStream, [\n *     '/ipfs-dht/1.0.0',\n *     '/ipfs-bitswap/1.0.0'\n *   ])\n *\n *   // Typically here we'd call the handler function that was registered in\n *   // libp2p for the given protocol:\n *   // e.g. handlers[protocol].handler(stream)\n *   //\n *   // If protocol was /ipfs-dht/1.0.0 it might do something like this:\n *   // try {\n *   //   await pipe(\n *   //     dhtStream,\n *   //     source => (async function * () {\n *   //       for await (const chunk of source)\n *   //         // Incoming DHT data -> process and yield to respond\n *   //     })(),\n *   //     dhtStream\n *   //   )\n *   // } catch (err) {\n *   //   // Error in stream\n *   // }\n *   }\n * })\n * ```\n */\nexport async function handle <Stream extends Duplex<any, any, any>> (stream: Stream, protocols: string | string[], options: MultistreamSelectInit): Promise<ProtocolStream<Stream>> {\n  protocols = Array.isArray(protocols) ? protocols : [protocols]\n  options.log.trace('handle: available protocols %s', protocols)\n\n  const lp = lpStream(stream, {\n    ...options,\n    maxDataLength: MAX_PROTOCOL_LENGTH,\n    maxLengthLength: 2 // 2 bytes is enough to length-prefix MAX_PROTOCOL_LENGTH\n  })\n\n  while (true) {\n    options.log.trace('handle: reading incoming string')\n    const protocol = await multistream.readString(lp, options)\n    options.log.trace('handle: read \"%s\"', protocol)\n\n    if (protocol === PROTOCOL_ID) {\n      options.log.trace('handle: respond with \"%s\" for \"%s\"', PROTOCOL_ID, protocol)\n      await multistream.write(lp, uint8ArrayFromString(`${PROTOCOL_ID}\\n`), options)\n      options.log.trace('handle: responded with \"%s\" for \"%s\"', PROTOCOL_ID, protocol)\n      continue\n    }\n\n    if (protocols.includes(protocol)) {\n      options.log.trace('handle: respond with \"%s\" for \"%s\"', protocol, protocol)\n      await multistream.write(lp, uint8ArrayFromString(`${protocol}\\n`), options)\n      options.log.trace('handle: responded with \"%s\" for \"%s\"', protocol, protocol)\n\n      return { stream: lp.unwrap(), protocol }\n    }\n\n    if (protocol === 'ls') {\n      // <varint-msg-len><varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\\n\n      const protos = new Uint8ArrayList(\n        ...protocols.map(p => encode.single(uint8ArrayFromString(`${p}\\n`))),\n        uint8ArrayFromString('\\n')\n      )\n\n      options.log.trace('handle: respond with \"%s\" for %s', protocols, protocol)\n      await multistream.write(lp, protos, options)\n      options.log.trace('handle: responded with \"%s\" for %s', protocols, protocol)\n      continue\n    }\n\n    options.log.trace('handle: respond with \"na\" for \"%s\"', protocol)\n    await multistream.write(lp, uint8ArrayFromString('na\\n'), options)\n    options.log('handle: responded with \"na\" for \"%s\"', protocol)\n  }\n}\n", "import { connectionSymbol, setMaxListeners, LimitedConnectionError, ConnectionClosedError, ConnectionClosingError } from '@libp2p/interface'\nimport type { AbortOptions, Logger, ComponentLogger, Direction, Connection, Stream, ConnectionTimeline, ConnectionStatus, NewStreamOptions, PeerId, ConnectionLimits } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst CLOSE_TIMEOUT = 500\n\ninterface ConnectionInit {\n  remoteAddr: Multiaddr\n  remotePeer: PeerId\n  newStream(protocols: string[], options?: AbortOptions): Promise<Stream>\n  close(options?: AbortOptions): Promise<void>\n  abort(err: Error): void\n  getStreams(): Stream[]\n  status: ConnectionStatus\n  direction: Direction\n  timeline: ConnectionTimeline\n  multiplexer?: string\n  encryption?: string\n  limits?: ConnectionLimits\n  logger: ComponentLogger\n}\n\n/**\n * An implementation of the js-libp2p connection.\n * Any libp2p transport should use an upgrader to return this connection.\n */\nexport class ConnectionImpl implements Connection {\n  /**\n   * Connection identifier.\n   */\n  public readonly id: string\n\n  /**\n   * Observed multiaddr of the remote peer\n   */\n  public readonly remoteAddr: Multiaddr\n\n  /**\n   * Remote peer id\n   */\n  public readonly remotePeer: PeerId\n\n  public direction: Direction\n  public timeline: ConnectionTimeline\n  public multiplexer?: string\n  public encryption?: string\n  public status: ConnectionStatus\n  public limits?: ConnectionLimits\n  public readonly log: Logger\n\n  /**\n   * User provided tags\n   *\n   */\n  public tags: string[]\n\n  /**\n   * Reference to the new stream function of the multiplexer\n   */\n  private readonly _newStream: (protocols: string[], options?: NewStreamOptions) => Promise<Stream>\n\n  /**\n   * Reference to the close function of the raw connection\n   */\n  private readonly _close: (options?: AbortOptions) => Promise<void>\n\n  private readonly _abort: (err: Error) => void\n\n  /**\n   * Reference to the getStreams function of the muxer\n   */\n  private readonly _getStreams: () => Stream[]\n\n  /**\n   * An implementation of the js-libp2p connection.\n   * Any libp2p transport should use an upgrader to return this connection.\n   */\n  constructor (init: ConnectionInit) {\n    const { remoteAddr, remotePeer, newStream, close, abort, getStreams } = init\n\n    this.id = `${(parseInt(String(Math.random() * 1e9))).toString(36)}${Date.now()}`\n    this.remoteAddr = remoteAddr\n    this.remotePeer = remotePeer\n    this.direction = init.direction\n    this.status = 'open'\n    this.timeline = init.timeline\n    this.multiplexer = init.multiplexer\n    this.encryption = init.encryption\n    this.limits = init.limits\n    this.log = init.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`)\n\n    if (this.remoteAddr.getPeerId() == null) {\n      this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)\n    }\n\n    this._newStream = newStream\n    this._close = close\n    this._abort = abort\n    this._getStreams = getStreams\n    this.tags = []\n  }\n\n  readonly [Symbol.toStringTag] = 'Connection'\n\n  readonly [connectionSymbol] = true\n\n  /**\n   * Get all the streams of the muxer\n   */\n  get streams (): Stream[] {\n    return this._getStreams()\n  }\n\n  /**\n   * Create a new stream from this connection\n   */\n  async newStream (protocols: string | string[], options?: NewStreamOptions): Promise<Stream> {\n    if (this.status === 'closing') {\n      throw new ConnectionClosingError('the connection is being closed')\n    }\n\n    if (this.status === 'closed') {\n      throw new ConnectionClosedError('the connection is closed')\n    }\n\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols]\n    }\n\n    if (this.limits != null && options?.runOnLimitedConnection !== true) {\n      throw new LimitedConnectionError('Cannot open protocol stream on limited connection')\n    }\n\n    const stream = await this._newStream(protocols, options)\n\n    stream.direction = 'outbound'\n\n    return stream\n  }\n\n  /**\n   * Close the connection\n   */\n  async close (options: AbortOptions = {}): Promise<void> {\n    if (this.status === 'closed' || this.status === 'closing') {\n      return\n    }\n\n    this.log('closing connection to %a', this.remoteAddr)\n\n    this.status = 'closing'\n\n    if (options.signal == null) {\n      const signal = AbortSignal.timeout(CLOSE_TIMEOUT)\n      setMaxListeners(Infinity, signal)\n\n      options = {\n        ...options,\n        signal\n      }\n    }\n\n    try {\n      this.log.trace('closing underlying transport')\n\n      // close raw connection\n      await this._close(options)\n\n      this.log.trace('updating timeline with close time')\n\n      this.status = 'closed'\n      this.timeline.close = Date.now()\n    } catch (err: any) {\n      this.log.error('error encountered during graceful close of connection to %a', this.remoteAddr, err)\n      this.abort(err)\n    }\n  }\n\n  abort (err: Error): void {\n    if (this.status === 'closed') {\n      return\n    }\n\n    this.log.error('aborting connection to %a due to error', this.remoteAddr, err)\n\n    this.status = 'closing'\n\n    // Abort raw connection\n    this._abort(err)\n\n    this.status = 'closed'\n    this.timeline.close = Date.now()\n  }\n}\n\nexport function createConnection (init: ConnectionInit): Connection {\n  return new ConnectionImpl(init)\n}\n", "import { InvalidMultiaddrError, TooManyInboundProtocolStreamsError, TooManyOutboundProtocolStreamsError, LimitedConnectionError, setMaxListeners, InvalidPeerIdError } from '@libp2p/interface'\nimport * as mss from '@libp2p/multistream-select'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { anySignal } from 'any-signal'\nimport { CustomProgressEvent } from 'progress-events'\nimport { createConnection } from './connection/index.js'\nimport { PROTOCOL_NEGOTIATION_TIMEOUT, INBOUND_UPGRADE_TIMEOUT } from './connection-manager/constants.js'\nimport { ConnectionDeniedError, ConnectionInterceptedError, EncryptionFailedError, MuxerUnavailableError } from './errors.js'\nimport { DEFAULT_MAX_INBOUND_STREAMS, DEFAULT_MAX_OUTBOUND_STREAMS } from './registrar.js'\nimport type { Libp2pEvents, AbortOptions, ComponentLogger, MultiaddrConnection, Connection, Stream, ConnectionProtector, NewStreamOptions, ConnectionEncrypter, SecuredConnection, ConnectionGater, TypedEventTarget, Metrics, PeerId, PeerStore, StreamMuxer, StreamMuxerFactory, Upgrader as UpgraderInterface, UpgraderOptions, ConnectionLimits, SecureConnectionOptions, CounterGroup, ClearableSignal } from '@libp2p/interface'\nimport type { ConnectionManager, Registrar } from '@libp2p/interface-internal'\n\ninterface CreateConnectionOptions {\n  cryptoProtocol: string\n  direction: 'inbound' | 'outbound'\n  maConn: MultiaddrConnection\n  upgradedConn: MultiaddrConnection\n  remotePeer: PeerId\n  muxerFactory?: StreamMuxerFactory\n  limits?: ConnectionLimits\n}\n\ninterface OnStreamOptions {\n  connection: Connection\n  stream: Stream\n  protocol: string\n}\n\nexport interface CryptoResult extends SecuredConnection<MultiaddrConnection> {\n  protocol: string\n}\n\nexport interface UpgraderInit {\n  connectionEncrypters: ConnectionEncrypter[]\n  streamMuxers: StreamMuxerFactory[]\n\n  /**\n   * An amount of ms by which an inbound connection upgrade must complete\n   *\n   * @default 3000\n   */\n  inboundUpgradeTimeout?: number\n\n  /**\n   * When a new incoming stream is opened on a multiplexed connection, protocol\n   * negotiation on that stream must complete within this many ms\n   *\n   * @default 2000\n   */\n  inboundStreamProtocolNegotiationTimeout?: number\n\n  /**\n   * When a new incoming stream is opened on a multiplexed connection, protocol\n   * negotiation on that stream must complete within this many ms\n   *\n   * @default 2000\n   */\n  outboundStreamProtocolNegotiationTimeout?: number\n}\n\nfunction findIncomingStreamLimit (protocol: string, registrar: Registrar): number | undefined {\n  try {\n    const { options } = registrar.getHandler(protocol)\n\n    return options.maxInboundStreams\n  } catch (err: any) {\n    if (err.name !== 'UnhandledProtocolError') {\n      throw err\n    }\n  }\n\n  return DEFAULT_MAX_INBOUND_STREAMS\n}\n\nfunction findOutgoingStreamLimit (protocol: string, registrar: Registrar, options: NewStreamOptions = {}): number {\n  try {\n    const { options } = registrar.getHandler(protocol)\n\n    if (options.maxOutboundStreams != null) {\n      return options.maxOutboundStreams\n    }\n  } catch (err: any) {\n    if (err.name !== 'UnhandledProtocolError') {\n      throw err\n    }\n  }\n\n  return options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS\n}\n\nfunction countStreams (protocol: string, direction: 'inbound' | 'outbound', connection: Connection): number {\n  let streamCount = 0\n\n  connection.streams.forEach(stream => {\n    if (stream.direction === direction && stream.protocol === protocol) {\n      streamCount++\n    }\n  })\n\n  return streamCount\n}\n\nexport interface UpgraderComponents {\n  peerId: PeerId\n  metrics?: Metrics\n  connectionManager: ConnectionManager\n  connectionGater: ConnectionGater\n  connectionProtector?: ConnectionProtector\n  registrar: Registrar\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\ntype ConnectionDeniedType = keyof Pick<ConnectionGater, 'denyOutboundConnection' | 'denyInboundEncryptedConnection' | 'denyOutboundEncryptedConnection' | 'denyInboundUpgradedConnection' | 'denyOutboundUpgradedConnection'>\n\nexport class Upgrader implements UpgraderInterface {\n  private readonly components: UpgraderComponents\n  private readonly connectionEncrypters: Map<string, ConnectionEncrypter>\n  private readonly streamMuxers: Map<string, StreamMuxerFactory>\n  private readonly inboundUpgradeTimeout: number\n  private readonly inboundStreamProtocolNegotiationTimeout: number\n  private readonly outboundStreamProtocolNegotiationTimeout: number\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly metrics: {\n    dials?: CounterGroup<'inbound' | 'outbound'>\n    errors?: CounterGroup<'inbound' | 'outbound'>\n  }\n\n  constructor (components: UpgraderComponents, init: UpgraderInit) {\n    this.components = components\n    this.connectionEncrypters = new Map()\n\n    init.connectionEncrypters.forEach(encrypter => {\n      this.connectionEncrypters.set(encrypter.protocol, encrypter)\n    })\n\n    this.streamMuxers = new Map()\n\n    init.streamMuxers.forEach(muxer => {\n      this.streamMuxers.set(muxer.protocol, muxer)\n    })\n\n    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? INBOUND_UPGRADE_TIMEOUT\n    this.inboundStreamProtocolNegotiationTimeout = init.inboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT\n    this.outboundStreamProtocolNegotiationTimeout = init.outboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT\n    this.events = components.events\n    this.metrics = {\n      dials: components.metrics?.registerCounterGroup('libp2p_connection_manager_dials_total'),\n      errors: components.metrics?.registerCounterGroup('libp2p_connection_manager_dial_errors_total')\n    }\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/upgrader'\n\n  async shouldBlockConnection (connectionType: 'denyInboundConnection', maConn: MultiaddrConnection): Promise<void>\n  async shouldBlockConnection (connectionType: ConnectionDeniedType, remotePeer: PeerId, maConn: MultiaddrConnection): Promise<void>\n  async shouldBlockConnection (method: ConnectionDeniedType | 'denyInboundConnection', ...args: any[]): Promise<void> {\n    const denyOperation: any = this.components.connectionGater[method]\n\n    if (denyOperation == null) {\n      return\n    }\n\n    const result = await denyOperation.apply(this.components.connectionGater, args)\n\n    if (result === true) {\n      throw new ConnectionInterceptedError(`The multiaddr connection is blocked by gater.${method}`)\n    }\n  }\n\n  createInboundAbortSignal (signal: AbortSignal): ClearableSignal {\n    const output = anySignal([\n      AbortSignal.timeout(this.inboundUpgradeTimeout),\n      signal\n    ])\n    setMaxListeners(Infinity, output)\n\n    return output\n  }\n\n  /**\n   * Upgrades an inbound connection\n   */\n  async upgradeInbound (maConn: MultiaddrConnection, opts: UpgraderOptions): Promise<void> {\n    let accepted = false\n\n    // always apply upgrade timeout for incoming upgrades\n    const signal = this.createInboundAbortSignal(opts.signal)\n\n    try {\n      this.metrics.dials?.increment({\n        inbound: true\n      })\n\n      accepted = await this.components.connectionManager.acceptIncomingConnection(maConn)\n\n      if (!accepted) {\n        throw new ConnectionDeniedError('Connection denied')\n      }\n\n      await this.shouldBlockConnection('denyInboundConnection', maConn)\n\n      await this._performUpgrade(maConn, 'inbound', {\n        ...opts,\n        signal\n      })\n    } catch (err) {\n      this.metrics.errors?.increment({\n        inbound: true\n      })\n\n      throw err\n    } finally {\n      signal.clear()\n\n      if (accepted) {\n        this.components.connectionManager.afterUpgradeInbound()\n      }\n    }\n  }\n\n  /**\n   * Upgrades an outbound connection\n   */\n  async upgradeOutbound (maConn: MultiaddrConnection, opts: UpgraderOptions): Promise<Connection> {\n    try {\n      this.metrics.dials?.increment({\n        outbound: true\n      })\n\n      const idStr = maConn.remoteAddr.getPeerId()\n      let remotePeerId: PeerId | undefined\n\n      if (idStr != null) {\n        remotePeerId = peerIdFromString(idStr)\n        await this.shouldBlockConnection('denyOutboundConnection', remotePeerId, maConn)\n      }\n\n      let direction: 'inbound' | 'outbound' = 'outbound'\n\n      // act as the multistream-select server if we are not to be the initiator\n      if (opts.initiator === false) {\n        direction = 'inbound'\n      }\n\n      return await this._performUpgrade(maConn, direction, opts)\n    } catch (err) {\n      this.metrics.errors?.increment({\n        outbound: true\n      })\n\n      throw err\n    }\n  }\n\n  private async _performUpgrade (maConn: MultiaddrConnection, direction: 'inbound' | 'outbound', opts: UpgraderOptions): Promise<Connection> {\n    let encryptedConn: MultiaddrConnection\n    let remotePeer: PeerId\n    let upgradedConn: MultiaddrConnection\n    let muxerFactory: StreamMuxerFactory | undefined\n    let cryptoProtocol\n\n    this.components.metrics?.trackMultiaddrConnection(maConn)\n\n    maConn.log.trace('starting the %s connection upgrade', direction)\n\n    // Protect\n    let protectedConn = maConn\n\n    if (opts?.skipProtection !== true) {\n      const protector = this.components.connectionProtector\n\n      if (protector != null) {\n        maConn.log('protecting the %s connection', direction)\n        protectedConn = await protector.protect(maConn, opts)\n      }\n    }\n\n    try {\n      // Encrypt the connection\n      encryptedConn = protectedConn\n      if (opts?.skipEncryption !== true) {\n        opts?.onProgress?.(new CustomProgressEvent(`upgrader:encrypt-${direction}-connection`));\n\n        ({\n          conn: encryptedConn,\n          remotePeer,\n          protocol: cryptoProtocol,\n          streamMuxer: muxerFactory\n        } = await (direction === 'inbound'\n          ? this._encryptInbound(protectedConn, opts)\n          : this._encryptOutbound(protectedConn, opts)\n        ))\n\n        const maConn: MultiaddrConnection = {\n          ...protectedConn,\n          ...encryptedConn\n        }\n\n        await this.shouldBlockConnection(direction === 'inbound' ? 'denyInboundEncryptedConnection' : 'denyOutboundEncryptedConnection', remotePeer, maConn)\n      } else {\n        const idStr = maConn.remoteAddr.getPeerId()\n\n        if (idStr == null) {\n          throw new InvalidMultiaddrError(`${direction} connection that skipped encryption must have a peer id`)\n        }\n\n        const remotePeerId = peerIdFromString(idStr)\n\n        cryptoProtocol = 'native'\n        remotePeer = remotePeerId\n      }\n\n      // this can happen if we dial a multiaddr without a peer id, we only find\n      // out the identity of the remote after the connection is encrypted\n      if (remotePeer.equals(this.components.peerId)) {\n        const err = new InvalidPeerIdError('Can not dial self')\n        maConn.abort(err)\n        throw err\n      }\n\n      upgradedConn = encryptedConn\n      if (opts?.muxerFactory != null) {\n        muxerFactory = opts.muxerFactory\n      } else if (muxerFactory == null && this.streamMuxers.size > 0) {\n        opts?.onProgress?.(new CustomProgressEvent(`upgrader:multiplex-${direction}-connection`))\n\n        // Multiplex the connection\n        const multiplexed = await (direction === 'inbound'\n          ? this._multiplexInbound({\n            ...protectedConn,\n            ...encryptedConn\n          }, this.streamMuxers, opts)\n          : this._multiplexOutbound({\n            ...protectedConn,\n            ...encryptedConn\n          }, this.streamMuxers, opts))\n        muxerFactory = multiplexed.muxerFactory\n        upgradedConn = multiplexed.stream\n      }\n    } catch (err: any) {\n      maConn.log.error('failed to upgrade inbound connection %s %a - %e', direction === 'inbound' ? 'from' : 'to', maConn.remoteAddr, err)\n      throw err\n    }\n\n    await this.shouldBlockConnection(direction === 'inbound' ? 'denyInboundUpgradedConnection' : 'denyOutboundUpgradedConnection', remotePeer, maConn)\n\n    maConn.log('successfully upgraded %s connection', direction)\n\n    return this._createConnection({\n      cryptoProtocol,\n      direction,\n      maConn,\n      upgradedConn,\n      muxerFactory,\n      remotePeer,\n      limits: opts?.limits\n    })\n  }\n\n  /**\n   * A convenience method for generating a new `Connection`\n   */\n  _createConnection (opts: CreateConnectionOptions): Connection {\n    const {\n      cryptoProtocol,\n      direction,\n      maConn,\n      upgradedConn,\n      remotePeer,\n      muxerFactory,\n      limits\n    } = opts\n\n    let muxer: StreamMuxer | undefined\n    let newStream: ((multicodecs: string[], options?: AbortOptions) => Promise<Stream>) | undefined\n    let connection: Connection // eslint-disable-line prefer-const\n\n    if (muxerFactory != null) {\n      // Create the muxer\n      muxer = muxerFactory.createStreamMuxer({\n        direction,\n        // Run anytime a remote stream is created\n        onIncomingStream: muxedStream => {\n          if (connection == null) {\n            return\n          }\n\n          void Promise.resolve()\n            .then(async () => {\n              const protocols = this.components.registrar.getProtocols()\n              const signal = AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout)\n              setMaxListeners(Infinity, signal)\n\n              const { stream, protocol } = await mss.handle(muxedStream, protocols, {\n                signal,\n                log: muxedStream.log,\n                yieldBytes: false\n              })\n\n              if (connection == null) {\n                return\n              }\n\n              connection.log('incoming stream opened on %s', protocol)\n\n              const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar)\n              const streamCount = countStreams(protocol, 'inbound', connection)\n\n              if (streamCount === incomingLimit) {\n                const err = new TooManyInboundProtocolStreamsError(`Too many inbound protocol streams for protocol \"${protocol}\" - limit ${incomingLimit}`)\n                muxedStream.abort(err)\n\n                throw err\n              }\n\n              // after the handshake the returned stream can have early data so override\n              // the source/sink\n              muxedStream.source = stream.source\n              muxedStream.sink = stream.sink\n              muxedStream.protocol = protocol\n\n              // allow closing the write end of a not-yet-negotiated stream\n              if (stream.closeWrite != null) {\n                muxedStream.closeWrite = stream.closeWrite\n              }\n\n              // allow closing the read end of a not-yet-negotiated stream\n              if (stream.closeRead != null) {\n                muxedStream.closeRead = stream.closeRead\n              }\n\n              // make sure we don't try to negotiate a stream we are closing\n              if (stream.close != null) {\n                muxedStream.close = stream.close\n              }\n\n              // If a protocol stream has been successfully negotiated and is to be passed to the application,\n              // the peer store should ensure that the peer is registered with that protocol\n              await this.components.peerStore.merge(remotePeer, {\n                protocols: [protocol]\n              })\n\n              this.components.metrics?.trackProtocolStream(muxedStream, connection)\n\n              this._onStream({ connection, stream: muxedStream, protocol })\n            })\n            .catch(async err => {\n              connection.log.error('error handling incoming stream id %s - %e', muxedStream.id, err)\n\n              if (muxedStream.timeline.close == null) {\n                await muxedStream.close()\n              }\n            })\n        }\n      })\n\n      newStream = async (protocols: string[], options: NewStreamOptions = {}): Promise<Stream> => {\n        if (muxer == null) {\n          throw new MuxerUnavailableError('Connection is not multiplexed')\n        }\n\n        connection.log.trace('starting new stream for protocols %s', protocols)\n        const muxedStream = await muxer.newStream()\n        connection.log.trace('started new stream %s for protocols %s', muxedStream.id, protocols)\n\n        try {\n          if (options.signal == null) {\n            muxedStream.log('no abort signal was passed while trying to negotiate protocols %s falling back to default timeout', protocols)\n\n            const signal = AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout)\n            setMaxListeners(Infinity, signal)\n\n            options = {\n              ...options,\n              signal\n            }\n          }\n\n          muxedStream.log.trace('selecting protocol from protocols %s', protocols)\n\n          const {\n            stream,\n            protocol\n          } = await mss.select(muxedStream, protocols, {\n            ...options,\n            log: muxedStream.log,\n            yieldBytes: true\n          })\n\n          muxedStream.log.trace('selected protocol %s', protocol)\n\n          const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar, options)\n          const streamCount = countStreams(protocol, 'outbound', connection)\n\n          if (streamCount >= outgoingLimit) {\n            const err = new TooManyOutboundProtocolStreamsError(`Too many outbound protocol streams for protocol \"${protocol}\" - ${streamCount}/${outgoingLimit}`)\n            muxedStream.abort(err)\n\n            throw err\n          }\n\n          // If a protocol stream has been successfully negotiated and is to be passed to the application,\n          // the peer store should ensure that the peer is registered with that protocol\n          await this.components.peerStore.merge(remotePeer, {\n            protocols: [protocol]\n          })\n\n          // after the handshake the returned stream can have early data so override\n          // the source/sink\n          muxedStream.source = stream.source\n          muxedStream.sink = stream.sink\n          muxedStream.protocol = protocol\n\n          // allow closing the write end of a not-yet-negotiated stream\n          if (stream.closeWrite != null) {\n            muxedStream.closeWrite = stream.closeWrite\n          }\n\n          // allow closing the read end of a not-yet-negotiated stream\n          if (stream.closeRead != null) {\n            muxedStream.closeRead = stream.closeRead\n          }\n\n          // make sure we don't try to negotiate a stream we are closing\n          if (stream.close != null) {\n            muxedStream.close = stream.close\n          }\n\n          this.components.metrics?.trackProtocolStream(muxedStream, connection)\n\n          return muxedStream\n        } catch (err: any) {\n          connection.log.error('could not create new outbound stream on connection %s %a for protocols %s - %e', direction === 'inbound' ? 'from' : 'to', opts.maConn.remoteAddr, protocols, err)\n\n          if (muxedStream.timeline.close == null) {\n            muxedStream.abort(err)\n          }\n\n          throw err\n        }\n      }\n\n      // Pipe all data through the muxer\n      void Promise.all([\n        muxer.sink(upgradedConn.source),\n        upgradedConn.sink(muxer.source)\n      ]).catch(err => {\n        connection.log.error('error piping data through muxer - %e', err)\n      })\n    }\n\n    const _timeline = maConn.timeline\n    maConn.timeline = new Proxy(_timeline, {\n      set: (...args) => {\n        if (args[1] === 'close' && args[2] != null && _timeline.close == null) {\n          // Wait for close to finish before notifying of the closure\n          (async () => {\n            try {\n              if (connection.status === 'open') {\n                await connection.close()\n              }\n            } catch (err: any) {\n              connection.log.error('error closing connection after timeline close %e', err)\n            } finally {\n              this.events.safeDispatchEvent('connection:close', {\n                detail: connection\n              })\n            }\n          })().catch(err => {\n            connection.log.error('error thrown while dispatching connection:close event %e', err)\n          })\n        }\n\n        return Reflect.set(...args)\n      }\n    })\n    maConn.timeline.upgraded = Date.now()\n\n    const errConnectionNotMultiplexed = (): any => {\n      throw new MuxerUnavailableError('Connection is not multiplexed')\n    }\n\n    // Create the connection\n    connection = createConnection({\n      remoteAddr: maConn.remoteAddr,\n      remotePeer,\n      status: 'open',\n      direction,\n      timeline: maConn.timeline,\n      multiplexer: muxer?.protocol,\n      encryption: cryptoProtocol,\n      limits,\n      logger: this.components.logger,\n      newStream: newStream ?? errConnectionNotMultiplexed,\n      getStreams: () => {\n        return muxer?.streams ?? []\n      },\n      close: async (options?: AbortOptions) => {\n        // ensure remaining streams are closed gracefully\n        await muxer?.close(options)\n\n        // close the underlying transport\n        await maConn.close(options)\n      },\n      abort: (err) => {\n        maConn.abort(err)\n\n        // ensure remaining streams are aborted\n        muxer?.abort(err)\n      }\n    })\n\n    this.events.safeDispatchEvent('connection:open', {\n      detail: connection\n    })\n\n    // @ts-expect-error nah\n    connection.__maConnTimeline = _timeline\n\n    return connection\n  }\n\n  /**\n   * Routes incoming streams to the correct handler\n   */\n  _onStream (opts: OnStreamOptions): void {\n    const { connection, stream, protocol } = opts\n    const { handler, options } = this.components.registrar.getHandler(protocol)\n\n    if (connection.limits != null && options.runOnLimitedConnection !== true) {\n      throw new LimitedConnectionError('Cannot open protocol stream on limited connection')\n    }\n\n    handler({ connection, stream })\n  }\n\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`\n   */\n  async _encryptInbound (connection: MultiaddrConnection, options?: AbortOptions): Promise<CryptoResult> {\n    const protocols = Array.from(this.connectionEncrypters.keys())\n\n    try {\n      const { stream, protocol } = await mss.handle(connection, protocols, {\n        ...options,\n        log: connection.log\n      })\n      const encrypter = this.connectionEncrypters.get(protocol)\n\n      if (encrypter == null) {\n        throw new EncryptionFailedError(`no crypto module found for ${protocol}`)\n      }\n\n      connection.log('encrypting inbound connection to %a using %s', connection.remoteAddr, protocol)\n\n      return {\n        ...await encrypter.secureInbound(stream, options),\n        protocol\n      }\n    } catch (err: any) {\n      connection.log.error('encrypting inbound connection from %a failed', connection.remoteAddr, err)\n      throw new EncryptionFailedError(err.message)\n    }\n  }\n\n  /**\n   * Attempts to encrypt the given `connection` with the provided connection encrypters.\n   * The first `ConnectionEncrypter` module to succeed will be used\n   */\n  async _encryptOutbound (connection: MultiaddrConnection, options: SecureConnectionOptions): Promise<CryptoResult> {\n    const protocols = Array.from(this.connectionEncrypters.keys())\n\n    try {\n      connection.log.trace('selecting encrypter from %s', protocols)\n\n      const { stream, protocol } = await mss.select(connection, protocols, {\n        ...options,\n        log: connection.log,\n        yieldBytes: true\n      })\n      const encrypter = this.connectionEncrypters.get(protocol)\n\n      if (encrypter == null) {\n        throw new EncryptionFailedError(`no crypto module found for ${protocol}`)\n      }\n\n      connection.log('encrypting outbound connection to %a using %s', connection.remoteAddr, protocol)\n\n      return {\n        ...await encrypter.secureOutbound(stream, options),\n        protocol\n      }\n    } catch (err: any) {\n      connection.log.error('encrypting outbound connection to %a failed', connection.remoteAddr, err)\n      throw new EncryptionFailedError(err.message)\n    }\n  }\n\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   */\n  async _multiplexOutbound (connection: MultiaddrConnection, muxers: Map<string, StreamMuxerFactory>, options: AbortOptions): Promise<{ stream: MultiaddrConnection, muxerFactory?: StreamMuxerFactory }> {\n    const protocols = Array.from(muxers.keys())\n    connection.log('outbound selecting muxer %s', protocols)\n    try {\n      connection.log.trace('selecting stream muxer from %s', protocols)\n\n      const {\n        stream,\n        protocol\n      } = await mss.select(connection, protocols, {\n        ...options,\n        log: connection.log,\n        yieldBytes: true\n      })\n\n      connection.log('selected %s as muxer protocol', protocol)\n      const muxerFactory = muxers.get(protocol)\n\n      return { stream, muxerFactory }\n    } catch (err: any) {\n      connection.log.error('error multiplexing outbound connection', err)\n      throw new MuxerUnavailableError(String(err))\n    }\n  }\n\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   */\n  async _multiplexInbound (connection: MultiaddrConnection, muxers: Map<string, StreamMuxerFactory>, options: AbortOptions): Promise<{ stream: MultiaddrConnection, muxerFactory?: StreamMuxerFactory }> {\n    const protocols = Array.from(muxers.keys())\n    connection.log('inbound handling muxers %s', protocols)\n    try {\n      const { stream, protocol } = await mss.handle(connection, protocols, {\n        ...options,\n        log: connection.log\n      })\n      const muxerFactory = muxers.get(protocol)\n\n      return { stream, muxerFactory }\n    } catch (err: any) {\n      connection.log.error('error multiplexing inbound connection', err)\n      throw new MuxerUnavailableError(String(err))\n    }\n  }\n\n  getConnectionEncrypters (): Map<string, ConnectionEncrypter<unknown>> {\n    return this.connectionEncrypters\n  }\n\n  getStreamMuxers (): Map<string, StreamMuxerFactory> {\n    return this.streamMuxers\n  }\n}\n", "export const version = '2.8.2'\nexport const name = 'js-libp2p'\n", "import * as pkg from './version.js'\n\nexport function userAgent (name?: string, version?: string): string {\n  return `${name ?? pkg.name}/${version ?? pkg.version} browser/${globalThis.navigator.userAgent}`\n}\n", "import { publicKeyFromProtobuf } from '@libp2p/crypto/keys'\nimport { contentRoutingSymbol, TypedEventEmitter, setMaxListeners, peerDiscoverySymbol, peerRoutingSymbol, InvalidParametersError } from '@libp2p/interface'\nimport { defaultLogger } from '@libp2p/logger'\nimport { PeerSet } from '@libp2p/peer-collections'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { persistentPeerStore } from '@libp2p/peer-store'\nimport { isMultiaddr, type Multiaddr } from '@multiformats/multiaddr'\nimport { MemoryDatastore } from 'datastore-core/memory'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { AddressManager } from './address-manager/index.js'\nimport { checkServiceDependencies, defaultComponents } from './components.js'\nimport { connectionGater } from './config/connection-gater.js'\nimport { DefaultConnectionManager } from './connection-manager/index.js'\nimport { ConnectionMonitor } from './connection-monitor.js'\nimport { CompoundContentRouting } from './content-routing.js'\nimport { DefaultPeerRouting } from './peer-routing.js'\nimport { RandomWalk } from './random-walk.js'\nimport { Registrar } from './registrar.js'\nimport { DefaultTransportManager } from './transport-manager.js'\nimport { Upgrader } from './upgrader.js'\nimport { userAgent } from './user-agent.js'\nimport * as pkg from './version.js'\nimport type { Components } from './components.js'\nimport type { Libp2p as Libp2pInterface, Libp2pInit } from './index.js'\nimport type { PeerRouting, ContentRouting, Libp2pEvents, PendingDial, ServiceMap, AbortOptions, ComponentLogger, Logger, Connection, NewStreamOptions, Stream, Metrics, PeerId, PeerInfo, PeerStore, Topology, Libp2pStatus, IsDialableOptions, DialOptions, PublicKey, Ed25519PeerId, Secp256k1PeerId, RSAPublicKey, RSAPeerId, URLPeerId, Ed25519PublicKey, Secp256k1PublicKey, StreamHandler, StreamHandlerOptions } from '@libp2p/interface'\n\nexport class Libp2p<T extends ServiceMap = ServiceMap> extends TypedEventEmitter<Libp2pEvents> implements Libp2pInterface<T> {\n  public peerId: PeerId\n  public peerStore: PeerStore\n  public contentRouting: ContentRouting\n  public peerRouting: PeerRouting\n  public metrics?: Metrics\n  public services: T\n  public logger: ComponentLogger\n  public status: Libp2pStatus\n\n  public components: Components & T\n  private readonly log: Logger\n\n  // eslint-disable-next-line complexity\n  constructor (init: Libp2pInit<T> & { peerId: PeerId }) {\n    super()\n\n    this.status = 'stopped'\n\n    // event bus - components can listen to this emitter to be notified of system events\n    // and also cause them to be emitted\n    const events = new TypedEventEmitter<Libp2pEvents>()\n    const originalDispatch = events.dispatchEvent.bind(events)\n    events.dispatchEvent = (evt: any) => {\n      const internalResult = originalDispatch(evt)\n      const externalResult = this.dispatchEvent(\n        new CustomEvent(evt.type, { detail: evt.detail })\n      )\n\n      return internalResult || externalResult\n    }\n\n    // This emitter gets listened to a lot\n    setMaxListeners(Infinity, events)\n\n    this.peerId = init.peerId\n    this.logger = init.logger ?? defaultLogger()\n    this.log = this.logger.forComponent('libp2p')\n    // @ts-expect-error {} may not be of type T\n    this.services = {}\n\n    const nodeInfoName = init.nodeInfo?.name ?? pkg.name\n    const nodeInfoVersion = init.nodeInfo?.version ?? pkg.version\n\n    // @ts-expect-error defaultComponents is missing component types added later\n    const components = this.components = defaultComponents({\n      peerId: init.peerId,\n      privateKey: init.privateKey,\n      nodeInfo: {\n        name: nodeInfoName,\n        version: nodeInfoVersion,\n        userAgent: init.nodeInfo?.userAgent ?? userAgent(nodeInfoName, nodeInfoVersion)\n      },\n      logger: this.logger,\n      events,\n      datastore: init.datastore ?? new MemoryDatastore(),\n      connectionGater: connectionGater(init.connectionGater),\n      dns: init.dns\n    })\n\n    this.peerStore = this.configureComponent('peerStore', persistentPeerStore(components, {\n      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,\n      ...init.peerStore\n    }))\n\n    // Create Metrics\n    if (init.metrics != null) {\n      this.metrics = this.configureComponent('metrics', init.metrics(this.components))\n    }\n\n    components.events.addEventListener('peer:update', evt => {\n      // if there was no peer previously in the peer store this is a new peer\n      if (evt.detail.previous == null) {\n        const peerInfo: PeerInfo = {\n          id: evt.detail.peer.id,\n          multiaddrs: evt.detail.peer.addresses.map(a => a.multiaddr)\n        }\n\n        components.events.safeDispatchEvent('peer:discovery', { detail: peerInfo })\n      }\n    })\n\n    // Set up connection protector if configured\n    if (init.connectionProtector != null) {\n      this.configureComponent('connectionProtector', init.connectionProtector(components))\n    }\n\n    // Set up the Upgrader\n    this.components.upgrader = new Upgrader(this.components, {\n      connectionEncrypters: (init.connectionEncrypters ?? []).map((fn, index) => this.configureComponent(`connection-encryption-${index}`, fn(this.components))),\n      streamMuxers: (init.streamMuxers ?? []).map((fn, index) => this.configureComponent(`stream-muxers-${index}`, fn(this.components))),\n      inboundUpgradeTimeout: init.connectionManager?.inboundUpgradeTimeout,\n      inboundStreamProtocolNegotiationTimeout: init.connectionManager?.inboundStreamProtocolNegotiationTimeout ?? init.connectionManager?.protocolNegotiationTimeout,\n      outboundStreamProtocolNegotiationTimeout: init.connectionManager?.outboundStreamProtocolNegotiationTimeout ?? init.connectionManager?.protocolNegotiationTimeout\n    })\n\n    // Setup the transport manager\n    this.configureComponent('transportManager', new DefaultTransportManager(this.components, init.transportManager))\n\n    // Create the Connection Manager\n    this.configureComponent('connectionManager', new DefaultConnectionManager(this.components, init.connectionManager))\n\n    if (init.connectionMonitor?.enabled !== false) {\n      // Create the Connection Monitor if not disabled\n      this.configureComponent('connectionMonitor', new ConnectionMonitor(this.components, init.connectionMonitor))\n    }\n\n    // Create the Registrar\n    this.configureComponent('registrar', new Registrar(this.components))\n\n    // Addresses {listen, announce, noAnnounce}\n    this.configureComponent('addressManager', new AddressManager(this.components, init.addresses))\n\n    // Peer routers\n    const peerRouters: PeerRouting[] = (init.peerRouters ?? []).map((fn, index) => this.configureComponent(`peer-router-${index}`, fn(this.components)))\n    this.peerRouting = this.components.peerRouting = this.configureComponent('peerRouting', new DefaultPeerRouting(this.components, {\n      routers: peerRouters\n    }))\n\n    // Content routers\n    const contentRouters: ContentRouting[] = (init.contentRouters ?? []).map((fn, index) => this.configureComponent(`content-router-${index}`, fn(this.components)))\n    this.contentRouting = this.components.contentRouting = this.configureComponent('contentRouting', new CompoundContentRouting(this.components, {\n      routers: contentRouters\n    }))\n\n    // Random walk\n    this.configureComponent('randomWalk', new RandomWalk(this.components))\n\n    // Discovery modules\n    ;(init.peerDiscovery ?? []).forEach((fn, index) => {\n      const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components))\n\n      service.addEventListener('peer', (evt) => {\n        this.#onDiscoveryPeer(evt)\n      })\n    })\n\n    // Transport modules\n    init.transports?.forEach((fn, index) => {\n      this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)))\n    })\n\n    // User defined modules\n    if (init.services != null) {\n      for (const name of Object.keys(init.services)) {\n        const createService = init.services[name]\n        const service: any = createService(this.components)\n\n        if (service == null) {\n          this.log.error('service factory %s returned null or undefined instance', name)\n          continue\n        }\n\n        this.services[name as keyof T] = service\n        this.configureComponent(name, service)\n\n        if (service[contentRoutingSymbol] != null) {\n          this.log('registering service %s for content routing', name)\n          contentRouters.push(service[contentRoutingSymbol])\n        }\n\n        if (service[peerRoutingSymbol] != null) {\n          this.log('registering service %s for peer routing', name)\n          peerRouters.push(service[peerRoutingSymbol])\n        }\n\n        if (service[peerDiscoverySymbol] != null) {\n          this.log('registering service %s for peer discovery', name)\n          service[peerDiscoverySymbol].addEventListener?.('peer', (evt: CustomEvent<PeerInfo>) => {\n            this.#onDiscoveryPeer(evt)\n          })\n        }\n      }\n    }\n\n    // Ensure all services have their required dependencies\n    checkServiceDependencies(components)\n  }\n\n  private configureComponent <T> (name: string, component: T): T {\n    if (component == null) {\n      this.log.error('component %s was null or undefined', name)\n    }\n\n    // @ts-expect-error cannot assign props\n    this.components[name] = component\n\n    return component\n  }\n\n  /**\n   * Starts the libp2p node and all its subsystems\n   */\n  async start (): Promise<void> {\n    if (this.status !== 'stopped') {\n      return\n    }\n\n    this.status = 'starting'\n\n    this.log('libp2p is starting')\n\n    try {\n      await this.components.beforeStart?.()\n      await this.components.start()\n      await this.components.afterStart?.()\n\n      this.status = 'started'\n      this.safeDispatchEvent('start', { detail: this })\n      this.log('libp2p has started')\n    } catch (err: any) {\n      this.log.error('An error occurred starting libp2p', err)\n      // set status to 'started' so this.stop() will stop any running components\n      this.status = 'started'\n      await this.stop()\n      throw err\n    }\n  }\n\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   */\n  async stop (): Promise<void> {\n    if (this.status !== 'started') {\n      return\n    }\n\n    this.log('libp2p is stopping')\n\n    this.status = 'stopping'\n\n    await this.components.beforeStop?.()\n    await this.components.stop()\n    await this.components.afterStop?.()\n\n    this.status = 'stopped'\n    this.safeDispatchEvent('stop', { detail: this })\n    this.log('libp2p has stopped')\n  }\n\n  getConnections (peerId?: PeerId): Connection[] {\n    return this.components.connectionManager.getConnections(peerId)\n  }\n\n  getDialQueue (): PendingDial[] {\n    return this.components.connectionManager.getDialQueue()\n  }\n\n  getPeers (): PeerId[] {\n    const peerSet = new PeerSet()\n\n    for (const conn of this.components.connectionManager.getConnections()) {\n      peerSet.add(conn.remotePeer)\n    }\n\n    return Array.from(peerSet)\n  }\n\n  async dial (peer: PeerId | Multiaddr | Multiaddr[], options: DialOptions = {}): Promise<Connection> {\n    return this.components.connectionManager.openConnection(peer, {\n      // ensure any userland dials take top priority in the queue\n      priority: 75,\n      ...options\n    })\n  }\n\n  async dialProtocol (peer: PeerId | Multiaddr | Multiaddr[], protocols: string | string[], options: NewStreamOptions = {}): Promise<Stream> {\n    if (protocols == null) {\n      throw new InvalidParametersError('no protocols were provided to open a stream')\n    }\n\n    protocols = Array.isArray(protocols) ? protocols : [protocols]\n\n    if (protocols.length === 0) {\n      throw new InvalidParametersError('no protocols were provided to open a stream')\n    }\n\n    const connection = await this.dial(peer, options)\n\n    return connection.newStream(protocols, options)\n  }\n\n  getMultiaddrs (): Multiaddr[] {\n    return this.components.addressManager.getAddresses()\n  }\n\n  getProtocols (): string[] {\n    return this.components.registrar.getProtocols()\n  }\n\n  async hangUp (peer: PeerId | Multiaddr, options: AbortOptions = {}): Promise<void> {\n    if (isMultiaddr(peer)) {\n      peer = peerIdFromString(peer.getPeerId() ?? '')\n    }\n\n    await this.components.connectionManager.closeConnections(peer, options)\n  }\n\n  /**\n   * Get the public key for the given peer id\n   */\n  async getPublicKey (peer: Ed25519PeerId, options?: AbortOptions): Promise<Ed25519PublicKey>\n  async getPublicKey (peer: Secp256k1PeerId, options?: AbortOptions): Promise<Secp256k1PublicKey>\n  async getPublicKey (peer: RSAPeerId, options?: AbortOptions): Promise<RSAPublicKey>\n  async getPublicKey (peer: URLPeerId, options?: AbortOptions): Promise<never>\n  async getPublicKey (peer: PeerId, options?: AbortOptions): Promise<PublicKey>\n  async getPublicKey (peer: PeerId, options: AbortOptions = {}): Promise<PublicKey> {\n    this.log('getPublicKey %p', peer)\n\n    if (peer.publicKey != null) {\n      return peer.publicKey\n    }\n\n    try {\n      const peerInfo = await this.peerStore.get(peer)\n\n      if (peerInfo.id.publicKey != null) {\n        return peerInfo.id.publicKey\n      }\n    } catch (err: any) {\n      if (err.name !== 'NotFoundError') {\n        throw err\n      }\n    }\n\n    const peerKey = uint8ArrayConcat([\n      uint8ArrayFromString('/pk/'),\n      peer.toMultihash().bytes\n    ])\n\n    // search any available content routing methods\n    const bytes = await this.contentRouting.get(peerKey, options)\n\n    // ensure the returned key is valid\n    const publicKey = publicKeyFromProtobuf(bytes)\n\n    await this.peerStore.patch(peer, {\n      publicKey\n    })\n\n    return publicKey\n  }\n\n  async handle (protocols: string | string[], handler: StreamHandler, options?: StreamHandlerOptions): Promise<void> {\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols]\n    }\n\n    await Promise.all(\n      protocols.map(async protocol => {\n        await this.components.registrar.handle(protocol, handler, options)\n      })\n    )\n  }\n\n  async unhandle (protocols: string[] | string): Promise<void> {\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols]\n    }\n\n    await Promise.all(\n      protocols.map(async protocol => {\n        await this.components.registrar.unhandle(protocol)\n      })\n    )\n  }\n\n  async register (protocol: string, topology: Topology): Promise<string> {\n    return this.components.registrar.register(protocol, topology)\n  }\n\n  unregister (id: string): void {\n    this.components.registrar.unregister(id)\n  }\n\n  async isDialable (multiaddr: Multiaddr, options: IsDialableOptions = {}): Promise<boolean> {\n    return this.components.connectionManager.isDialable(multiaddr, options)\n  }\n\n  /**\n   * Called whenever peer discovery services emit `peer` events and adds peers\n   * to the peer store.\n   */\n  #onDiscoveryPeer (evt: CustomEvent<PeerInfo>): void {\n    const { detail: peer } = evt\n\n    if (peer.id.toString() === this.peerId.toString()) {\n      this.log.error('peer discovery mechanism discovered self')\n      return\n    }\n\n    void this.components.peerStore.merge(peer.id, {\n      multiaddrs: peer.multiaddrs\n    })\n      .catch(err => { this.log.error(err) })\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Use the `createLibp2p` function to create a libp2p node.\n *\n * @example\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n *\n * const node = await createLibp2p({\n *   // ...other options\n * })\n * ```\n */\n\nimport { generateKeyPair } from '@libp2p/crypto/keys'\nimport { peerIdFromPrivateKey } from '@libp2p/peer-id'\nimport { validateConfig } from './config.js'\nimport { Libp2p as Libp2pClass } from './libp2p.js'\nimport type { AddressManagerInit, AddressFilter } from './address-manager/index.js'\nimport type { Components } from './components.js'\nimport type { ConnectionManagerInit } from './connection-manager/index.js'\nimport type { ConnectionMonitorInit } from './connection-monitor.js'\nimport type { TransportManagerInit } from './transport-manager.js'\nimport type { Libp2p, ServiceMap, ComponentLogger, NodeInfo, ConnectionProtector, ConnectionEncrypter, ConnectionGater, ContentRouting, Metrics, PeerDiscovery, PeerRouting, StreamMuxerFactory, Transport, PrivateKey } from '@libp2p/interface'\nimport type { PersistentPeerStoreInit } from '@libp2p/peer-store'\nimport type { DNS } from '@multiformats/dns'\nimport type { Datastore } from 'interface-datastore'\n\nexport type ServiceFactoryMap<T extends ServiceMap = ServiceMap> = {\n  [Property in keyof T]: (components: Components & T) => T[Property]\n}\n\nexport type { AddressManagerInit, AddressFilter }\n\n/**\n * For Libp2p configurations and modules details read the [Configuration Document](https://github.com/libp2p/js-libp2p/tree/main/doc/CONFIGURATION.md).\n */\nexport interface Libp2pInit<T extends ServiceMap = ServiceMap> {\n  /**\n   * The private key is used in cryptographic operations and the Peer ID derived\n   * from it's corresponding public key is used to identify the node to other\n   * peers on the network.\n   *\n   * If this is not passed a new Ed25519 private key will be generated.\n   */\n  privateKey?: PrivateKey\n\n  /**\n   * Metadata about the node - implementation name, version number, etc\n   */\n  nodeInfo?: Partial<NodeInfo>\n\n  /**\n   * Addresses for transport listening and to advertise to the network\n   */\n  addresses?: AddressManagerInit\n\n  /**\n   * libp2p Connection Manager configuration\n   */\n  connectionManager?: ConnectionManagerInit\n\n  /**\n   * libp2p Connection Monitor configuration\n   */\n  connectionMonitor?: ConnectionMonitorInit\n\n  /**\n   * A connection gater can deny new connections based on user criteria\n   */\n  connectionGater?: ConnectionGater\n\n  /**\n   * libp2p transport manager configuration\n   */\n  transportManager?: TransportManagerInit\n\n  /**\n   * An optional datastore to persist peer information, DHT records, etc.\n   *\n   * An in-memory datastore will be used if one is not provided.\n   */\n  datastore?: Datastore\n\n  /**\n   * libp2p PeerStore configuration\n   */\n  peerStore?: PersistentPeerStoreInit\n\n  /**\n   * Transports are low-level communication channels\n   */\n  transports?: Array<(components: Components) => Transport>\n\n  /**\n   * Stream muxers allow the creation of many data streams over a single\n   * connection.\n   */\n  streamMuxers?: Array<(components: Components) => StreamMuxerFactory>\n\n  /**\n   * Connection encrypters ensure that data sent over connections cannot be\n   * eavesdropped on, and that the remote peer possesses the private key that\n   * corresponds to the public key that it's Peer ID is derived from.\n   */\n  connectionEncrypters?: Array<(components: Components) => ConnectionEncrypter>\n\n  /**\n   * Peer discovery mechanisms allow finding peers on the network\n   */\n  peerDiscovery?: Array<(components: Components) => PeerDiscovery>\n\n  /**\n   * Peer routers provide implementations for peer routing queries\n   */\n  peerRouters?: Array<(components: Components) => PeerRouting>\n\n  /**\n   * Content routers provide implementations for content routing queries\n   */\n  contentRouters?: Array<(components: Components) => ContentRouting>\n\n  /**\n   * A Metrics implementation can be supplied to collect metrics on this node\n   */\n  metrics?(components: Components): Metrics\n\n  /**\n   * A ConnectionProtector can be used to create a secure overlay on top of the network using pre-shared keys\n   */\n  connectionProtector?(components: Components): ConnectionProtector\n\n  /**\n   * Arbitrary libp2p modules\n   */\n  services?: ServiceFactoryMap<T>\n\n  /**\n   * An optional logging implementation that can be used to write runtime logs.\n   *\n   * Set the `DEBUG` env var or the `debug` key on LocalStorage to see logs.\n   *\n   * @example\n   *\n   * Node.js:\n   *\n   * ```console\n   * $ DEBUG=\"*libp2p:*\" node myscript.js\n   * ```\n   *\n   * Browsers:\n   *\n   * ```TypeScript\n   * localStorage.setItem('debug', '*libp2p:*')\n   * ```\n   */\n  logger?: ComponentLogger\n\n  /**\n   * An optional DNS resolver configuration. If omitted the default DNS resolver\n   * for the platform will be used which means `node:dns` on Node.js and\n   * DNS-JSON-over-HTTPS for browsers using Google and Cloudflare servers.\n   */\n  dns?: DNS\n}\n\nexport type { Libp2p, ConnectionManagerInit, ConnectionMonitorInit, TransportManagerInit }\n\nexport type Libp2pOptions<T extends ServiceMap = ServiceMap> = Libp2pInit<T> & { start?: boolean }\n\n/**\n * Returns a new instance of the Libp2p interface, generating a new PeerId\n * if one is not passed as part of the options.\n *\n * The node will be started unless `start: false` is passed as an option.\n *\n * @example\n *\n * ```TypeScript\n * import { createLibp2p } from 'libp2p'\n * import { tcp } from '@libp2p/tcp'\n * import { mplex } from '@libp2p/mplex'\n * import { noise } from '@chainsafe/libp2p-noise'\n * import { yamux } from '@chainsafe/libp2p-yamux'\n *\n * // specify options\n * const options = {\n *   transports: [tcp()],\n *   streamMuxers: [yamux(), mplex()],\n *   connectionEncrypters: [noise()]\n * }\n *\n * // create libp2p\n * const libp2p = await createLibp2p(options)\n * ```\n */\nexport async function createLibp2p <T extends ServiceMap = ServiceMap> (options: Libp2pOptions<T> = {}): Promise<Libp2p<T>> {\n  options.privateKey ??= await generateKeyPair('Ed25519')\n\n  const node = new Libp2pClass({\n    ...await validateConfig(options),\n    peerId: peerIdFromPrivateKey(options.privateKey)\n  })\n\n  if (options.start !== false) {\n    await node.start()\n  }\n\n  return node\n}\n"],
  "mappings": "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",
  "names": ["EventEmitter", "events", "name", "cache", "name", "globalThis", "message", "original", "require_retry", "_queue", "EventEmitter", "_a", "_b", "TimeoutError", "delay", "filter", "_a", "response", "hashlru", "_a", "_b", "resolvers", "RecordType", "message", "dnsaddrResolver", "ma", "import_index", "mergeOptions", "_a", "_b", "message", "ms", "name", "ms", "name", "_a", "_b", "src_default", "src_default", "logger", "name", "src_default", "peerIdFromString", "_a", "peerIdFromString", "fnv1a", "fnv1a", "_a", "_b", "load", "fnv1a", "Envelope", "w", "message", "sort", "a", "b", "PeerRecord", "AddressInfo", "_codec", "w", "_a", "_b", "m", "PeerRecord", "arr", "src_default", "src_default", "event", "name", "browser_default", "src_default", "name", "defaultOptions", "browser_default", "Peer", "Peer$metadataEntry", "_codec", "w", "Peer$tagsEntry", "_a", "_b", "Address", "Tag", "filter", "multiaddr", "_a", "_b", "peerRecordEnvelope", "multiaddr", "addr", "src_default", "PeerRecord", "multiaddr", "message", "NotFoundError", "isAsyncIterable", "src_default", "isAsyncIterable", "src_default", "isAsyncIterable", "src_default", "src_default", "it", "NotFoundError", "_a", "tuple", "CODEC_IP4", "CODEC_IP6", "CODEC_IP4", "CODEC_IP6", "_a", "CODEC_IP4", "CODEC_IP6", "CODEC_DNS", "CODEC_DNS4", "CODEC_DNS6", "CODEC_DNSADDR", "defaultValues", "multiaddr", "_a", "defaultValues", "_a", "multiaddr", "ma", "messages", "message", "_a", "serviceCapabilities", "CODEC_IP4", "CODEC_IP6", "multiaddr", "message", "_a", "ma", "isIPv6", "defaultOptions", "_a", "_a", "_a", "_b", "PriorityQueue", "defaultOptions", "PriorityQueue", "_a", "_b", "multiaddr", "options", "err", "isError", "AbortError", "message", "retry", "_a", "defaultOptions", "_a", "_b", "multiaddr", "_a", "_b", "_a", "start", "_a", "_b", "_a", "_b", "peer", "_a", "_b", "start", "s", "_a", "_b", "name", "_a", "protocol", "response", "encode", "_a", "_b", "options", "_a", "_b", "maConn", "name", "version", "_a", "_b", "events", "name", "peerSet", "multiaddr"]
}
