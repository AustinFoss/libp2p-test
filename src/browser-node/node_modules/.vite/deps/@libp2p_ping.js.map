{
  "version": 3,
  "sources": ["../../.pnpm/@libp2p+ping@2.0.28/node_modules/@libp2p/ping/src/constants.ts", "../../.pnpm/@libp2p+ping@2.0.28/node_modules/@libp2p/ping/src/ping.ts", "../../.pnpm/@libp2p+ping@2.0.28/node_modules/@libp2p/ping/src/index.ts"],
  "sourcesContent": ["export const PING_PROTOCOL = '/ipfs/ping/1.0.0'\nexport const PING_LENGTH = 32\nexport const PROTOCOL_VERSION = '1.0.0'\nexport const PROTOCOL_NAME = 'ping'\nexport const PROTOCOL_PREFIX = 'ipfs'\nexport const TIMEOUT = 10000\n\n// See https://github.com/libp2p/specs/blob/d4b5fb0152a6bb86cfd9ea/ping/ping.md?plain=1#L38-L43\n// The dialing peer MUST NOT keep more than one outbound stream for the ping protocol per peer.\n// The listening peer SHOULD accept at most two streams per peer since cross-stream behavior is\n// non-linear and stream writes occur asynchronously. The listening peer may perceive the\n// dialing peer closing and opening the wrong streams (for instance, closing stream B and\n// opening stream A even though the dialing peer is opening stream B and closing stream A).\nexport const MAX_INBOUND_STREAMS = 2\nexport const MAX_OUTBOUND_STREAMS = 1\n", "import { randomBytes } from '@libp2p/crypto'\nimport { ProtocolError, TimeoutError, serviceCapabilities, setMaxListeners } from '@libp2p/interface'\nimport { byteStream } from 'it-byte-stream'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { PROTOCOL_PREFIX, PROTOCOL_NAME, PING_LENGTH, PROTOCOL_VERSION, TIMEOUT, MAX_INBOUND_STREAMS, MAX_OUTBOUND_STREAMS } from './constants.js'\nimport type { PingComponents, PingInit, Ping as PingInterface } from './index.js'\nimport type { AbortOptions, Logger, Stream, PeerId, Startable, IncomingStreamData } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport class Ping implements Startable, PingInterface {\n  public readonly protocol: string\n  private readonly components: PingComponents\n  private started: boolean\n  private readonly timeout: number\n  private readonly maxInboundStreams: number\n  private readonly maxOutboundStreams: number\n  private readonly runOnLimitedConnection: boolean\n  private readonly log: Logger\n\n  constructor (components: PingComponents, init: PingInit = {}) {\n    this.components = components\n    this.log = components.logger.forComponent('libp2p:ping')\n    this.started = false\n    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`\n    this.timeout = init.timeout ?? TIMEOUT\n    this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS\n    this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS\n    this.runOnLimitedConnection = init.runOnLimitedConnection ?? true\n\n    this.handleMessage = this.handleMessage.bind(this)\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/ping'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/ping'\n  ]\n\n  async start (): Promise<void> {\n    await this.components.registrar.handle(this.protocol, this.handleMessage, {\n      maxInboundStreams: this.maxInboundStreams,\n      maxOutboundStreams: this.maxOutboundStreams,\n      runOnLimitedConnection: this.runOnLimitedConnection\n    })\n    this.started = true\n  }\n\n  async stop (): Promise<void> {\n    await this.components.registrar.unhandle(this.protocol)\n    this.started = false\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  /**\n   * A handler to register with Libp2p to process ping messages\n   */\n  handleMessage (data: IncomingStreamData): void {\n    this.log('incoming ping from %p', data.connection.remotePeer)\n\n    const { stream } = data\n    const start = Date.now()\n    const bytes = byteStream(stream)\n    let pinged = false\n\n    Promise.resolve().then(async () => {\n      while (true) {\n        const signal = AbortSignal.timeout(this.timeout)\n        setMaxListeners(Infinity, signal)\n        signal.addEventListener('abort', () => {\n          stream?.abort(new TimeoutError('ping timeout'))\n        })\n\n        const buf = await bytes.read({\n          bytes: PING_LENGTH,\n          signal\n        })\n        await bytes.write(buf, {\n          signal\n        })\n\n        pinged = true\n      }\n    })\n      .catch(err => {\n        // ignore the error if we've processed at least one ping, the remote\n        // closed the stream and we handled or are handling the close cleanly\n        if (pinged && err.name === 'UnexpectedEOFError' && stream.readStatus !== 'ready') {\n          return\n        }\n\n        this.log.error('incoming ping from %p failed with error - %e', data.connection.remotePeer, err)\n        stream?.abort(err)\n      })\n      .finally(() => {\n        const ms = Date.now() - start\n        this.log('incoming ping from %p complete in %dms', data.connection.remotePeer, ms)\n\n        const signal = AbortSignal.timeout(this.timeout)\n        setMaxListeners(Infinity, signal)\n\n        stream.close({\n          signal\n        })\n          .catch(err => {\n            this.log.error('error closing ping stream from %p - %e', data.connection.remotePeer, err)\n            stream?.abort(err)\n          })\n      })\n  }\n\n  /**\n   * Ping a given peer and wait for its response, getting the operation latency.\n   */\n  async ping (peer: PeerId | Multiaddr | Multiaddr[], options: AbortOptions = {}): Promise<number> {\n    this.log('pinging %p', peer)\n\n    const start = Date.now()\n    const data = randomBytes(PING_LENGTH)\n    const connection = await this.components.connectionManager.openConnection(peer, options)\n    let stream: Stream | undefined\n\n    if (options.signal == null) {\n      const signal = AbortSignal.timeout(this.timeout)\n\n      options = {\n        ...options,\n        signal\n      }\n    }\n\n    try {\n      stream = await connection.newStream(this.protocol, {\n        ...options,\n        runOnLimitedConnection: this.runOnLimitedConnection\n      })\n\n      const bytes = byteStream(stream)\n\n      const [, result] = await Promise.all([\n        bytes.write(data, options),\n        bytes.read({\n          ...options,\n          bytes: PING_LENGTH\n        })\n      ])\n\n      const ms = Date.now() - start\n\n      if (!uint8ArrayEquals(data, result.subarray())) {\n        throw new ProtocolError(`Received wrong ping ack after ${ms}ms`)\n      }\n\n      this.log('ping %p complete in %dms', connection.remotePeer, ms)\n\n      return ms\n    } catch (err: any) {\n      this.log.error('error while pinging %p', connection.remotePeer, err)\n\n      stream?.abort(err)\n\n      throw err\n    } finally {\n      if (stream != null) {\n        await stream.close(options)\n      }\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * The ping service implements the [libp2p ping spec](https://github.com/libp2p/specs/blob/master/ping/ping.md) allowing you to make a latency measurement to a remote peer.\n *\n * @example\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { ping } from '@libp2p/ping'\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const node = await createLibp2p({\n *   services: {\n *     ping: ping()\n *   }\n * })\n *\n * const rtt = await node.services.ping.ping(multiaddr('/ip4/...'))\n *\n * console.info(rtt)\n * ```\n */\n\nimport { Ping as PingClass } from './ping.js'\nimport type { AbortOptions, ComponentLogger, PeerId } from '@libp2p/interface'\nimport type { ConnectionManager, Registrar } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface Ping {\n  ping(peer: PeerId | Multiaddr | Multiaddr[], options?: AbortOptions): Promise<number>\n}\n\n/**\n * @deprecated Use the `Ping` export instead\n */\nexport type PingService = Ping\n\nexport interface PingInit {\n  protocolPrefix?: string\n  maxInboundStreams?: number\n  maxOutboundStreams?: number\n  runOnLimitedConnection?: boolean\n\n  /**\n   * How long we should wait for a ping response\n   */\n  timeout?: number\n}\n\n/**\n * @deprecated Use the `PingInit` export instead\n */\nexport type PingServiceInit = PingInit\n\nexport interface PingComponents {\n  registrar: Registrar\n  connectionManager: ConnectionManager\n  logger: ComponentLogger\n}\n\nexport function ping (init: PingInit = {}): (components: PingComponents) => Ping {\n  return (components) => new PingClass(components, init)\n}\n\nexport { PING_PROTOCOL } from './constants.js'\n"],
  "mappings": "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",
  "names": []
}
